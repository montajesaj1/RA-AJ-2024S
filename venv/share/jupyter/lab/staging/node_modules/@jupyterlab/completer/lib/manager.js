// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { Signal } from '@lumino/signaling';
import { Widget } from '@lumino/widgets';
import { ProviderReconciliator } from './reconciliator';
import { CONTEXT_PROVIDER_ID } from './default/contextprovider';
import { KERNEL_PROVIDER_ID } from './default/kernelprovider';
import { CompletionHandler } from './handler';
import { CompleterModel } from './model';
import { InlineCompleter } from './inline';
import { Completer } from './widget';
/**
 * A manager for completion providers.
 */
export class CompletionProviderManager {
    /**
     * Construct a new completer manager.
     */
    constructor() {
        /**
         * The set of activated providers
         */
        this._activeProviders = new Set([KERNEL_PROVIDER_ID, CONTEXT_PROVIDER_ID]);
        this._inlineCompleterSettings = InlineCompleter.defaultSettings;
        this._providers = new Map();
        this._inlineProviders = new Map();
        this._panelHandlers = new Map();
        this._mostRecentContext = new Map();
        this._activeProvidersChanged = new Signal(this);
        this._inlineCompleterFactory = null;
    }
    /**
     * Signal emitted when active providers list is changed.
     */
    get activeProvidersChanged() {
        return this._activeProvidersChanged;
    }
    /**
     * Set provider timeout.
     *
     * @param {number} timeout - value of timeout in millisecond.
     */
    setTimeout(timeout) {
        this._timeout = timeout;
    }
    /**
     * Enable/disable the document panel.
     */
    setShowDocumentationPanel(showDoc) {
        this._panelHandlers.forEach(handler => (handler.completer.showDocsPanel = showDoc));
        this._showDoc = showDoc;
    }
    /**
     * Enable/disable continuous hinting mode.
     */
    setContinuousHinting(value) {
        this._panelHandlers.forEach(handler => (handler.autoCompletion = value));
        this._autoCompletion = value;
    }
    /**
     * Register a completer provider with the manager.
     *
     * @param {ICompletionProvider} provider - the provider to be registered.
     */
    registerProvider(provider) {
        const identifier = provider.identifier;
        if (this._providers.has(identifier)) {
            console.warn(`Completion provider with identifier ${identifier} is already registered`);
        }
        else {
            this._providers.set(identifier, provider);
            this._panelHandlers.forEach((handler, id) => {
                void this.updateCompleter(this._mostRecentContext.get(id));
            });
        }
    }
    registerInlineProvider(provider) {
        const identifier = provider.identifier;
        if (this._inlineProviders.has(identifier)) {
            console.warn(`Completion provider with identifier ${identifier} is already registered`);
        }
        else {
            this._inlineProviders.set(identifier, provider);
            this._panelHandlers.forEach((handler, id) => {
                void this.updateCompleter(this._mostRecentContext.get(id));
            });
        }
    }
    /**
     *
     * Return the map of providers.
     */
    getProviders() {
        return this._providers;
    }
    /**
     * Activate the providers by id, the list of ids is populated from user setting.
     * The non-existing providers will be discarded.
     *
     * @param {Array<string>} providerIds - Array of strings with ids of provider
     */
    activateProvider(providerIds) {
        this._activeProviders = new Set([]);
        providerIds.forEach(providerId => {
            if (this._providers.has(providerId)) {
                this._activeProviders.add(providerId);
            }
        });
        if (this._activeProviders.size === 0) {
            this._activeProviders.add(KERNEL_PROVIDER_ID);
            this._activeProviders.add(CONTEXT_PROVIDER_ID);
        }
        this._activeProvidersChanged.emit();
    }
    /**
     * Create or update completer handler of a widget with new context.
     *
     * @param newCompleterContext - The completion context.
     */
    async updateCompleter(newCompleterContext) {
        var _a, _b;
        const { widget, editor, sanitizer } = newCompleterContext;
        const id = widget.id;
        const handler = this._panelHandlers.get(id);
        const firstProvider = [...this._activeProviders][0];
        const provider = this._providers.get(firstProvider);
        let renderer = (_a = provider === null || provider === void 0 ? void 0 : provider.renderer) !== null && _a !== void 0 ? _a : Completer.getDefaultRenderer(sanitizer);
        const modelFactory = provider === null || provider === void 0 ? void 0 : provider.modelFactory;
        let model;
        if (modelFactory) {
            model = await modelFactory.call(provider, newCompleterContext);
        }
        else {
            model = new CompleterModel();
        }
        this._mostRecentContext.set(widget.id, newCompleterContext);
        const options = {
            model,
            editor,
            renderer,
            sanitizer,
            showDoc: this._showDoc
        };
        if (!handler) {
            // Create a new handler.
            const handler = await this._generateHandler(newCompleterContext, options);
            this._panelHandlers.set(widget.id, handler);
            widget.disposed.connect(old => {
                this.disposeHandler(old.id, handler);
                this._mostRecentContext.delete(id);
            });
        }
        else {
            // Update existing completer.
            const completer = handler.completer;
            (_b = completer.model) === null || _b === void 0 ? void 0 : _b.dispose();
            completer.model = options.model;
            completer.renderer = options.renderer;
            completer.showDocsPanel = options.showDoc;
            // Update other handler attributes.
            handler.autoCompletion = this._autoCompletion;
            if (editor) {
                handler.editor = editor;
                handler.reconciliator =
                    await this.generateReconciliator(newCompleterContext);
            }
        }
    }
    /**
     * Invoke the completer in the widget with provided id.
     *
     * @param id - the id of notebook panel, console panel or code editor.
     */
    invoke(id) {
        const handler = this._panelHandlers.get(id);
        if (handler) {
            handler.invoke();
        }
    }
    /**
     * Activate `select` command in the widget with provided id.
     *
     * @param {string} id - the id of notebook panel, console panel or code editor.
     */
    select(id) {
        const handler = this._panelHandlers.get(id);
        if (handler) {
            handler.completer.selectActive();
        }
    }
    /**
     * Set inline completer factory.
     */
    setInlineCompleterFactory(factory) {
        this._inlineCompleterFactory = factory;
        this._panelHandlers.forEach((handler, id) => {
            void this.updateCompleter(this._mostRecentContext.get(id));
        });
        if (this.inline) {
            return;
        }
        this.inline = {
            invoke: (id) => {
                const handler = this._panelHandlers.get(id);
                if (handler && handler.inlineCompleter) {
                    handler.invokeInline();
                }
            },
            cycle: (id, direction) => {
                const handler = this._panelHandlers.get(id);
                if (handler && handler.inlineCompleter) {
                    handler.inlineCompleter.cycle(direction);
                }
            },
            accept: (id) => {
                const handler = this._panelHandlers.get(id);
                if (handler && handler.inlineCompleter) {
                    handler.inlineCompleter.accept();
                }
            },
            configure: (settings) => {
                this._inlineCompleterSettings = settings;
                this._panelHandlers.forEach((handler, handlerId) => {
                    for (const [providerId, provider] of this._inlineProviders.entries()) {
                        if (provider.configure) {
                            provider.configure(settings.providers[providerId]);
                        }
                    }
                    if (handler.inlineCompleter) {
                        handler.inlineCompleter.configure(settings);
                    }
                    // trigger update to regenerate reconciliator
                    void this.updateCompleter(this._mostRecentContext.get(handlerId));
                });
            }
        };
    }
    /**
     * Inline providers information.
     */
    get inlineProviders() {
        return [...this._inlineProviders.values()];
    }
    /**
     * Helper function to generate a `ProviderReconciliator` with provided context.
     * The `isApplicable` method of provider is used to filter out the providers
     * which can not be used with provided context.
     *
     * @param {ICompletionContext} completerContext - the current completer context
     */
    async generateReconciliator(completerContext) {
        const enabledProviders = [];
        for (const [id, providerSettings] of Object.entries(this._inlineCompleterSettings.providers)) {
            if (providerSettings.enabled === true) {
                enabledProviders.push(id);
            }
        }
        const inlineProviders = [...this._inlineProviders.values()].filter(provider => enabledProviders.includes(provider.identifier));
        const providers = [];
        for (const id of this._activeProviders) {
            const provider = this._providers.get(id);
            if (provider) {
                providers.push(provider);
            }
        }
        return new ProviderReconciliator({
            context: completerContext,
            providers,
            inlineProviders,
            inlineProvidersSettings: this._inlineCompleterSettings.providers,
            timeout: this._timeout
        });
    }
    /**
     * Helper to dispose the completer handler on widget disposed event.
     *
     * @param {string} id - id of the widget
     * @param {CompletionHandler} handler - the handler to be disposed.
     */
    disposeHandler(id, handler) {
        var _a, _b, _c, _d;
        (_a = handler.completer.model) === null || _a === void 0 ? void 0 : _a.dispose();
        handler.completer.dispose();
        (_c = (_b = handler.inlineCompleter) === null || _b === void 0 ? void 0 : _b.model) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = handler.inlineCompleter) === null || _d === void 0 ? void 0 : _d.dispose();
        handler.dispose();
        this._panelHandlers.delete(id);
    }
    /**
     * Helper to generate a completer handler from provided context.
     */
    async _generateHandler(completerContext, options) {
        const completer = new Completer(options);
        const inlineCompleter = this._inlineCompleterFactory
            ? this._inlineCompleterFactory.factory({
                ...options,
                model: new InlineCompleter.Model()
            })
            : undefined;
        completer.hide();
        Widget.attach(completer, document.body);
        if (inlineCompleter) {
            Widget.attach(inlineCompleter, document.body);
            inlineCompleter.hide();
            inlineCompleter.configure(this._inlineCompleterSettings);
        }
        const reconciliator = await this.generateReconciliator(completerContext);
        const handler = new CompletionHandler({
            completer,
            inlineCompleter,
            reconciliator: reconciliator
        });
        handler.editor = completerContext.editor;
        return handler;
    }
}
//# sourceMappingURL=manager.js.map