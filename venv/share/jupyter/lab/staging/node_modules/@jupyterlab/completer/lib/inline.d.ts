import { Widget } from '@lumino/widgets';
import { IDisposable } from '@lumino/disposable';
import { ISignal, Signal } from '@lumino/signaling';
import { Message } from '@lumino/messaging';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { SourceChange } from '@jupyter/ydoc';
import { Toolbar } from '@jupyterlab/ui-components';
import { TranslationBundle } from '@jupyterlab/translation';
import { IInlineCompleterFactory, IInlineCompleterSettings, IInlineCompletionList } from './tokens';
import { CompletionHandler } from './handler';
/**
 * Widget enabling user to choose among inline completions,
 * typically by pressing next/previous buttons, and showing
 * additional metadata about active completion, such as
 * inline completion provider name.
 */
export declare class InlineCompleter extends Widget {
    constructor(options: InlineCompleter.IOptions);
    /**
     * Toolbar with buttons such as previous/next/accept.
     */
    get toolbar(): Toolbar<Widget>;
    /**
     * The editor used by the completion widget.
     */
    get editor(): CodeEditor.IEditor | null | undefined;
    set editor(newValue: CodeEditor.IEditor | null | undefined);
    /**
     * The model used by the completer widget.
     */
    get model(): InlineCompleter.IModel | null;
    set model(model: InlineCompleter.IModel | null);
    cycle(direction: 'next' | 'previous'): void;
    accept(): void;
    get current(): CompletionHandler.IInlineItem | null;
    private _updateStreamTracking;
    private _onStream;
    /**
     * Change user-configurable settings.
     */
    configure(settings: IInlineCompleterSettings): void;
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event: Event): void;
    /**
     * Handle `update-request` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Handle `after-attach` messages for the widget.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `before-detach` messages for the widget.
     */
    protected onBeforeDetach(msg: Message): void;
    /**
     * Handle pointerdown events for the widget.
     */
    private _evtPointerdown;
    /**
     * Handle scroll events for the widget
     */
    private _evtScroll;
    private _onEditorBlur;
    private _onModelSuggestionsChanged;
    private _onModelFilterTextChanged;
    private _onProvisionProgress;
    private _render;
    private _setText;
    private _onPointerOverGhost;
    private _onPointerLeaveGhost;
    private _setGeometry;
    private _updateShortcutsVisibility;
    private _updateDisplay;
    private _clearHoverTimeout;
    private _current;
    private _editor;
    private _ghostManager;
    private _lastItem;
    private _model;
    private _providerWidget;
    private _showShortcuts;
    private _showWidget;
    private _suggestionsCounter;
    private _trans;
    private _toolbar;
    private _progressBar;
}
/**
 * Map between old and new inline completion position in the list.
 */
export type IndexMap = Map<number, number>;
export interface ISuggestionsChangedArgs {
    /**
     * Whether completions were set (new query) or appended (for existing query)
     */
    event: 'set' | 'append' | 'clear';
    /**
     * Map between old and new inline indices, only present for `set` event.
     */
    indexMap?: IndexMap;
}
/**
 * A namespace for inline completer statics.
 */
export declare namespace InlineCompleter {
    /**
     * The initialization options for inline completer widget.
     */
    interface IOptions extends IInlineCompleterFactory.IOptions {
        /**
         * JupyterLab translation bundle.
         */
        trans: TranslationBundle;
    }
    /**
     * Defaults for runtime user-configurable settings.
     */
    const defaultSettings: IInlineCompleterSettings;
    /**
     * Progress in generation of completion candidates by providers.
     */
    interface IProvisionProgress {
        /**
         * The number of providers to yet provide a reply.
         * Excludes providers which resolved/rejected their promise, or timed out.
         */
        pendingProviders: number;
        /**
         * The number of providers from which inline completions were requested.
         */
        totalProviders: number;
    }
    /**
     * Model for inline completions.
     */
    interface IModel extends IDisposable {
        /**
         * A signal emitted when new suggestions are set on the model.
         */
        readonly suggestionsChanged: ISignal<IModel, ISuggestionsChangedArgs>;
        /**
         * A signal emitted when filter text is updated.
         * Emits a mapping from old to new index for items after filtering.
         */
        readonly filterTextChanged: ISignal<IModel, IndexMap>;
        /**
         * A signal emitted when new information about progress is available.
         */
        readonly provisionProgress: ISignal<IModel, IProvisionProgress>;
        /**
         * Original placement of cursor.
         */
        cursor: CodeEditor.IPosition;
        /**
         * Reset completer model.
         */
        reset(): void;
        /**
         * Set completions clearing existing ones.
         */
        setCompletions(reply: IInlineCompletionList<CompletionHandler.IInlineItem>): void;
        /**
         * Append completions while preserving new ones.
         */
        appendCompletions(reply: IInlineCompletionList<CompletionHandler.IInlineItem>): void;
        /**
         * Notify model about progress in generation of completion candidates by providers.
         */
        notifyProgress(providerProgress: IProvisionProgress): void;
        /**
         * Current inline completions.
         */
        readonly completions: IInlineCompletionList<CompletionHandler.IInlineItem> | null;
        /**
         * Handle a source change.
         */
        handleTextChange(change: SourceChange): void;
        /**
         * Handle cursor selection change.
         */
        handleSelectionChange(range: CodeEditor.IRange): void;
    }
    /**
     * Model for inline completions.
     */
    class Model implements InlineCompleter.IModel {
        setCompletions(reply: IInlineCompletionList<CompletionHandler.IInlineItem>): void;
        appendCompletions(reply: IInlineCompletionList<CompletionHandler.IInlineItem>): void;
        notifyProgress(progress: IProvisionProgress): void;
        get cursor(): CodeEditor.IPosition;
        set cursor(value: CodeEditor.IPosition);
        get completions(): IInlineCompletionList<CompletionHandler.IInlineItem> | null;
        reset(): void;
        /**
         * Get whether the model is disposed.
         */
        get isDisposed(): boolean;
        handleTextChange(sourceChange: SourceChange): void;
        handleSelectionChange(range: CodeEditor.IRange): void;
        /**
         * Dispose of the resources held by the model.
         */
        dispose(): void;
        suggestionsChanged: Signal<this, ISuggestionsChangedArgs>;
        filterTextChanged: Signal<this, IndexMap>;
        provisionProgress: Signal<this, IProvisionProgress>;
        private _isDisposed;
        private _completions;
        private _cursor;
    }
}
