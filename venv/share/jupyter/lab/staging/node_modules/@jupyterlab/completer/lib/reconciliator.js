// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { CompletionHandler } from './handler';
import { InlineCompletionTriggerKind } from './tokens';
import { Signal } from '@lumino/signaling';
/**
 * The reconciliator which is used to fetch and merge responses from multiple completion providers.
 */
export class ProviderReconciliator {
    /**
     * Creates an instance of ProviderReconciliator.
     */
    constructor(options) {
        var _a, _b;
        this._resolveFactory = (provider, el) => provider.resolve
            ? (patch) => provider.resolve(el, this._context, patch)
            : undefined;
        /**
         * Counter to reject current provider response if a new fetch request is created.
         */
        this._fetching = 0;
        /**
         * Counter to reject current inline provider response if a new `inlineFetch` request is created.
         */
        this._inlineFetching = 0;
        this._providers = options.providers;
        this._inlineProviders = (_a = options.inlineProviders) !== null && _a !== void 0 ? _a : [];
        this._inlineProvidersSettings = (_b = options.inlineProvidersSettings) !== null && _b !== void 0 ? _b : {};
        this._context = options.context;
        this._timeout = options.timeout;
    }
    /**
     * Check for the providers which are applicable with the current context
     *
     * @return  List of applicable providers
     */
    async applicableProviders() {
        const isApplicablePromises = this._providers.map(p => p.isApplicable(this._context));
        const applicableProviders = await Promise.all(isApplicablePromises);
        return this._providers.filter((_, idx) => applicableProviders[idx]);
    }
    fetchInline(request, trigger) {
        let promises = [];
        const current = ++this._inlineFetching;
        for (const provider of this._inlineProviders) {
            const settings = this._inlineProvidersSettings[provider.identifier];
            let delay = 0;
            if (trigger === InlineCompletionTriggerKind.Automatic) {
                delay = settings.debouncerDelay;
            }
            const fetch = () => {
                const promise = provider
                    .fetch(request, { ...this._context, triggerKind: trigger })
                    .then(completionList => {
                    return {
                        ...completionList,
                        items: completionList.items.map(item => {
                            const newItem = item;
                            newItem.stream = new Signal(newItem);
                            newItem.provider = provider;
                            void this._stream(newItem, provider);
                            return newItem;
                        })
                    };
                });
                const timeoutPromise = new Promise(resolve => {
                    return setTimeout(() => resolve(null), delay + settings.timeout);
                });
                return Promise.race([promise, timeoutPromise]);
            };
            const promise = delay === 0
                ? fetch()
                : new Promise((resolve, reject) => {
                    return setTimeout(() => {
                        if (current != this._inlineFetching) {
                            // User pressed another key or explicitly requested completions since.
                            return reject(null);
                        }
                        else {
                            return resolve(fetch());
                        }
                    }, delay);
                });
            // Wrap promise and return error in case of failure.
            promises.push(promise.catch(p => p));
        }
        return promises;
    }
    async _stream(item, provider) {
        if (!item.isIncomplete || !provider.stream || !item.token) {
            return;
        }
        const streamed = item.stream;
        const token = item.token;
        item.token = undefined;
        // Notify that streaming started.
        item.streaming = true;
        streamed.emit(CompletionHandler.StraemEvent.opened);
        for await (const reply of provider.stream(token)) {
            const updated = reply.response;
            const addition = updated.insertText.substring(item.insertText.length);
            // Stream an update.
            item.insertText = updated.insertText;
            item.lastStreamed = addition;
            streamed.emit(CompletionHandler.StraemEvent.update);
        }
        // Notify that streaming is no longer in progress.
        item.isIncomplete = false;
        item.lastStreamed = undefined;
        item.streaming = false;
        streamed.emit(CompletionHandler.StraemEvent.closed);
    }
    /**
     * Fetch response from multiple providers, If a provider can not return
     * the response for a completer request before timeout,
     * the result of this provider will be ignored.
     *
     * @param {CompletionHandler.IRequest} request - The completion request.
     */
    async fetch(request, trigger) {
        const current = ++this._fetching;
        let promises = [];
        const applicableProviders = await this.applicableProviders();
        for (const provider of applicableProviders) {
            let promise;
            promise = provider.fetch(request, this._context, trigger).then(reply => {
                if (current !== this._fetching) {
                    return Promise.reject(void 0);
                }
                const items = reply.items.map(el => ({
                    ...el,
                    resolve: this._resolveFactory(provider, el)
                }));
                return { ...reply, items };
            });
            const timeoutPromise = new Promise(resolve => {
                return setTimeout(() => resolve(null), this._timeout);
            });
            promise = Promise.race([promise, timeoutPromise]);
            // Wrap promise and return error in case of failure.
            promises.push(promise.catch(p => p));
        }
        // TODO: maybe use `Promise.allSettled` once library is at es2020 instead of adding a catch.
        const combinedPromise = Promise.all(promises);
        return this._mergeCompletions(combinedPromise);
    }
    /**
     * Check if completer should make request to fetch completion responses
     * on user typing. If the provider with highest rank does not have
     * `shouldShowContinuousHint` method, a default one will be used.
     *
     * @param completerIsVisible - The visible status of completer widget.
     * @param changed - CodeMirror changed argument.
     */
    async shouldShowContinuousHint(completerIsVisible, changed) {
        const applicableProviders = await this.applicableProviders();
        if (applicableProviders.length === 0) {
            return false;
        }
        if (applicableProviders[0].shouldShowContinuousHint) {
            return applicableProviders[0].shouldShowContinuousHint(completerIsVisible, changed, this._context);
        }
        return this._defaultShouldShowContinuousHint(completerIsVisible, changed);
    }
    _alignPrefixes(replies, minStart, maxStart) {
        if (minStart != maxStart) {
            const editor = this._context.editor;
            if (!editor) {
                return replies;
            }
            const cursor = editor.getCursorPosition();
            const line = editor.getLine(cursor.line);
            if (!line) {
                return replies;
            }
            return replies.map(reply => {
                // No prefix to strip, return as-is.
                if (reply.start == maxStart) {
                    return reply;
                }
                let prefix = line.substring(reply.start, maxStart);
                return {
                    ...reply,
                    items: reply.items.map(item => {
                        let insertText = item.insertText || item.label;
                        item.insertText = insertText.startsWith(prefix)
                            ? insertText.slice(prefix.length)
                            : insertText;
                        return item;
                    })
                };
            });
        }
        return replies;
    }
    async _mergeCompletions(promises) {
        let replies = (await promises).filter(reply => {
            // Ignore it errors out.
            if (!reply || reply instanceof Error) {
                return false;
            }
            // Ignore if no matches.
            if (!reply.items.length) {
                return false;
            }
            // Otherwise keep.
            return true;
        });
        // Fast path for a single reply or no replies.
        if (replies.length == 0) {
            return null;
        }
        else if (replies.length == 1) {
            return replies[0];
        }
        const minEnd = Math.min(...replies.map(reply => reply.end));
        // If any of the replies uses a wider range, we need to align them
        // so that all responses use the same range.
        const starts = replies.map(reply => reply.start);
        const minStart = Math.min(...starts);
        const maxStart = Math.max(...starts);
        replies = this._alignPrefixes(replies, minStart, maxStart);
        const insertTextSet = new Set();
        const mergedItems = new Array();
        for (const reply of replies) {
            reply.items.forEach(item => {
                // IPython returns 'import' and 'import '; while the latter is more useful,
                // user should not see two suggestions with identical labels and nearly-identical
                // behaviour as they could not distinguish the two either way.
                let text = (item.insertText || item.label).trim();
                if (insertTextSet.has(text)) {
                    return;
                }
                insertTextSet.add(text);
                mergedItems.push(item);
            });
        }
        return {
            start: maxStart,
            end: minEnd,
            items: mergedItems
        };
    }
    _defaultShouldShowContinuousHint(completerIsVisible, changed) {
        return (!completerIsVisible &&
            (changed.sourceChange == null ||
                changed.sourceChange.some(delta => delta.insert != null && delta.insert.length > 0)));
    }
}
//# sourceMappingURL=reconciliator.js.map