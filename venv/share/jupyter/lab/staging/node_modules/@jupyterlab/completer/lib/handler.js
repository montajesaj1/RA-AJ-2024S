// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { COMPLETER_ACTIVE_CLASS, COMPLETER_ENABLED_CLASS } from '@jupyterlab/codeeditor';
import { Text } from '@jupyterlab/coreutils';
import { Message, MessageLoop } from '@lumino/messaging';
import { Signal } from '@lumino/signaling';
import { CompletionTriggerKind, InlineCompletionTriggerKind } from './tokens';
/**
 * A completion handler for editors.
 */
export class CompletionHandler {
    /**
     * Construct a new completion handler for a widget.
     */
    constructor(options) {
        this._fetchingInline = 0;
        this._editor = null;
        this._enabled = false;
        this._isDisposed = false;
        this._autoCompletion = false;
        this._continuousInline = true;
        this.completer = options.completer;
        this.inlineCompleter = options.inlineCompleter;
        this.completer.selected.connect(this.onCompletionSelected, this);
        this.completer.visibilityChanged.connect(this.onVisibilityChanged, this);
        this._reconciliator = options.reconciliator;
    }
    set reconciliator(reconciliator) {
        this._reconciliator = reconciliator;
    }
    /**
     * The editor used by the completion handler.
     */
    get editor() {
        return this._editor;
    }
    set editor(newValue) {
        if (newValue === this._editor) {
            return;
        }
        let editor = this._editor;
        // Clean up and disconnect from old editor.
        if (editor && !editor.isDisposed) {
            const model = editor.model;
            editor.host.classList.remove(COMPLETER_ENABLED_CLASS);
            editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);
            model.selections.changed.disconnect(this.onSelectionsChanged, this);
            model.sharedModel.changed.disconnect(this._onSharedModelChanged, this);
        }
        // Reset completer state.
        this.completer.reset();
        this.completer.editor = newValue;
        // Update the editor and signal connections.
        editor = this._editor = newValue;
        if (editor) {
            const model = editor.model;
            this._enabled = false;
            model.selections.changed.connect(this.onSelectionsChanged, this);
            // We expect the model to be an editor, a file editor, or a cell.
            const sharedModel = model.sharedModel;
            // For cells and files the `changed` signal is not limited to text,
            // but also fires on changes to metadata, outputs, execution count,
            // and state changes, hence we need to filter the change type.
            sharedModel.changed.connect(this._onSharedModelChanged, this);
            // On initial load, manually check the cursor position.
            this.onSelectionsChanged();
            if (this.inlineCompleter) {
                this.inlineCompleter.editor = editor;
            }
        }
    }
    /**
     * Get whether the completion handler is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Enable/disable continuous hinting mode.
     */
    set autoCompletion(value) {
        this._autoCompletion = value;
    }
    get autoCompletion() {
        return this._autoCompletion;
    }
    /**
     * Dispose of the resources used by the handler.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        Signal.clearData(this);
    }
    /**
     * Invoke the inline completer on explicit user request.
     */
    invokeInline() {
        const editor = this._editor;
        if (editor) {
            this._makeInlineRequest(editor.getCursorPosition(), InlineCompletionTriggerKind.Invoke).catch(reason => {
                console.warn('Inline invoke request bailed', reason);
            });
        }
    }
    /**
     * Invoke the handler and launch a completer.
     */
    invoke() {
        MessageLoop.sendMessage(this, CompletionHandler.Msg.InvokeRequest);
    }
    /**
     * Process a message sent to the completion handler.
     */
    processMessage(msg) {
        switch (msg.type) {
            case CompletionHandler.Msg.InvokeRequest.type:
                this.onInvokeRequest(msg);
                break;
            default:
                break;
        }
    }
    /**
     * Get the state of the text editor at the given position.
     */
    getState(editor, position) {
        return {
            text: editor.model.sharedModel.getSource(),
            line: position.line,
            column: position.column
        };
    }
    /**
     * Handle a completion selected signal from the completion widget.
     */
    onCompletionSelected(completer, val) {
        const model = completer.model;
        const editor = this._editor;
        if (!editor || !model) {
            return;
        }
        const patch = model.createPatch(val);
        if (!patch) {
            return;
        }
        const { start, end, value } = patch;
        const cursorBeforeChange = editor.getOffsetAt(editor.getCursorPosition());
        // we need to update the shared model in a single transaction so that the undo manager works as expected
        editor.model.sharedModel.updateSource(start, end, value);
        if (cursorBeforeChange <= end && cursorBeforeChange >= start) {
            editor.setCursorPosition(editor.getPositionAt(start + value.length));
        }
    }
    /**
     * Handle `invoke-request` messages.
     */
    onInvokeRequest(msg) {
        // If there is no completer model, bail.
        if (!this.completer.model) {
            return;
        }
        // If a completer session is already active, bail.
        if (this.completer.model.original) {
            return;
        }
        const editor = this._editor;
        if (editor) {
            this._makeRequest(editor.getCursorPosition(), CompletionTriggerKind.Invoked).catch(reason => {
                console.warn('Invoke request bailed', reason);
            });
        }
    }
    /**
     * Handle selection changed signal from an editor.
     *
     * #### Notes
     * If a sub-class reimplements this method, then that class must either call
     * its super method or it must take responsibility for adding and removing
     * the completer completable class to the editor host node.
     *
     * Despite the fact that the editor widget adds a class whenever there is a
     * primary selection, this method checks independently for two reasons:
     *
     * 1. The editor widget connects to the same signal to add that class, so
     *    there is no guarantee that the class will be added before this method
     *    is invoked so simply checking for the CSS class's existence is not an
     *    option. Secondarily, checking the editor state should be faster than
     *    querying the DOM in either case.
     * 2. Because this method adds a class that indicates whether completer
     *    functionality ought to be enabled, relying on the behavior of the
     *    `jp-mod-has-primary-selection` to filter out any editors that have
     *    a selection means the semantic meaning of `jp-mod-completer-enabled`
     *    is obscured because there may be cases where the enabled class is added
     *    even though the completer is not available.
     */
    onSelectionsChanged() {
        var _a;
        const model = this.completer.model;
        const editor = this._editor;
        if (!editor) {
            return;
        }
        const inlineModel = (_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.model;
        if (inlineModel) {
            // Dispatch selection change.
            inlineModel.handleSelectionChange(editor.getSelection());
        }
        const host = editor.host;
        // If there is no model, return.
        if (!model) {
            this._enabled = false;
            host.classList.remove(COMPLETER_ENABLED_CLASS);
            return;
        }
        // If we are currently performing a subset match,
        // return without resetting the completer.
        if (model.subsetMatch) {
            return;
        }
        const position = editor.getCursorPosition();
        const line = editor.getLine(position.line);
        if (!line) {
            this._enabled = false;
            model.reset(true);
            host.classList.remove(COMPLETER_ENABLED_CLASS);
            return;
        }
        const { start, end } = editor.getSelection();
        // If there is a text selection, return.
        if (start.column !== end.column || start.line !== end.line) {
            this._enabled = false;
            model.reset(true);
            host.classList.remove(COMPLETER_ENABLED_CLASS);
            return;
        }
        // If the part of the line before the cursor is white space, return.
        if (line.slice(0, position.column).match(/^\s*$/)) {
            this._enabled = false;
            model.reset(true);
            host.classList.remove(COMPLETER_ENABLED_CLASS);
            return;
        }
        // Enable completion.
        if (!this._enabled) {
            this._enabled = true;
            host.classList.add(COMPLETER_ENABLED_CLASS);
        }
        // Dispatch the cursor change.
        model.handleCursorChange(this.getState(editor, editor.getCursorPosition()));
    }
    /**
     * Handle a text changed signal from an editor.
     */
    async onTextChanged(str, changed) {
        var _a;
        if (!this._enabled) {
            return;
        }
        const model = this.completer.model;
        const editor = this.editor;
        if (!editor) {
            return;
        }
        if (model &&
            this._autoCompletion &&
            this._reconciliator.shouldShowContinuousHint &&
            (await this._reconciliator.shouldShowContinuousHint(this.completer.isVisible, changed))) {
            void this._makeRequest(editor.getCursorPosition(), CompletionTriggerKind.TriggerCharacter);
        }
        const inlineModel = (_a = this.inlineCompleter) === null || _a === void 0 ? void 0 : _a.model;
        if (inlineModel) {
            // Dispatch the text change to inline completer
            // (this happens before request is sent)
            inlineModel.handleTextChange(changed);
            if (this._continuousInline) {
                void this._makeInlineRequest(editor.getCursorPosition(), InlineCompletionTriggerKind.Automatic);
            }
        }
        if (model) {
            // If there is a text selection, no completion is allowed.
            const { start, end } = editor.getSelection();
            if (start.column !== end.column || start.line !== end.line) {
                return;
            }
            // Dispatch the text change.
            model.handleTextChange(this.getState(editor, editor.getCursorPosition()));
        }
    }
    /**
     * Handle a visibility change signal from a completer widget.
     */
    onVisibilityChanged(completer) {
        // Completer is not active.
        if (completer.isDisposed || completer.isHidden) {
            if (this._editor) {
                this._editor.host.classList.remove(COMPLETER_ACTIVE_CLASS);
                this._editor.focus();
            }
            return;
        }
        // Completer is active.
        if (this._editor) {
            this._editor.host.classList.add(COMPLETER_ACTIVE_CLASS);
        }
    }
    /**
     * Handle a text shared model change signal from an editor.
     */
    async _onSharedModelChanged(str, changed) {
        if (changed.sourceChange) {
            await this.onTextChanged(str, changed);
        }
    }
    /**
     * Make a completion request.
     */
    _makeRequest(position, trigger) {
        const editor = this.editor;
        if (!editor) {
            return Promise.reject(new Error('No active editor'));
        }
        const request = this._composeRequest(editor, position);
        const state = this.getState(editor, position);
        return this._reconciliator
            .fetch(request, trigger)
            .then(reply => {
            if (!reply) {
                return;
            }
            const model = this._updateModel(state, reply.start, reply.end);
            if (!model) {
                return;
            }
            if (model.setCompletionItems) {
                model.setCompletionItems(reply.items);
            }
        })
            .catch(p => {
            /* Fails silently. */
        });
    }
    async _makeInlineRequest(position, trigger) {
        const editor = this.editor;
        if (!editor) {
            return Promise.reject(new Error('No active editor'));
        }
        if (!this.inlineCompleter) {
            return Promise.reject(new Error('No inline completer'));
        }
        const line = editor.getLine(position.line);
        if (trigger === InlineCompletionTriggerKind.Automatic &&
            (typeof line === 'undefined' || position.column < line.length)) {
            // only auto-trigger on end of line
            return;
        }
        const request = this._composeRequest(editor, position);
        const model = this.inlineCompleter.model;
        if (!model) {
            return;
        }
        model.cursor = position;
        const current = ++this._fetchingInline;
        const promises = this._reconciliator.fetchInline(request, trigger);
        const completed = new Set();
        for (const promise of promises) {
            promise
                .then(result => {
                if (!result || !result.items) {
                    return;
                }
                if (current !== this._fetchingInline) {
                    return;
                }
                completed.add(promise);
                if (completed.size === 1) {
                    model.setCompletions(result);
                }
                else {
                    model.appendCompletions(result);
                }
            })
                .catch(e => {
                // Emit warning for debugging.
                console.warn(e);
            })
                .finally(() => {
                // Mark the provider promise as completed.
                completed.add(promise);
                // Let the model know that we are awaiting for fewer providers now.
                const remaining = promises.length - completed.size;
                model.notifyProgress({
                    pendingProviders: remaining,
                    totalProviders: promises.length
                });
            });
        }
    }
    _composeRequest(editor, position) {
        const text = editor.model.sharedModel.getSource();
        const mimeType = editor.model.mimeType;
        const offset = Text.jsIndexToCharIndex(editor.getOffsetAt(position), text);
        return { text, offset, mimeType };
    }
    /**
     * Updates model with text state and current cursor position.
     */
    _updateModel(state, start, end) {
        const model = this.completer.model;
        const text = state.text;
        if (!model) {
            return null;
        }
        // Update the original request.
        model.original = state;
        // Update the cursor.
        model.cursor = {
            start: Text.charIndexToJsIndex(start, text),
            end: Text.charIndexToJsIndex(end, text)
        };
        return model;
    }
}
/**
 * A namespace for cell completion handler statics.
 */
(function (CompletionHandler) {
    /**
     * Stream event type.
     */
    let StraemEvent;
    (function (StraemEvent) {
        StraemEvent[StraemEvent["opened"] = 0] = "opened";
        StraemEvent[StraemEvent["update"] = 1] = "update";
        StraemEvent[StraemEvent["closed"] = 2] = "closed";
    })(StraemEvent = CompletionHandler.StraemEvent || (CompletionHandler.StraemEvent = {}));
    /**
     * A namespace for completion handler messages.
     */
    let Msg;
    (function (Msg) {
        /**
         * A singleton `'invoke-request'` message.
         */
        Msg.InvokeRequest = new Message('invoke-request');
    })(Msg = CompletionHandler.Msg || (CompletionHandler.Msg = {}));
})(CompletionHandler || (CompletionHandler = {}));
//# sourceMappingURL=handler.js.map