import { nullTranslator } from '@jupyterlab/translation';
import { historyIcon } from '@jupyterlab/ui-components';
/**
 * An example inline completion provider using history to populate suggestions.
 */
export class HistoryInlineCompletionProvider {
    constructor(options) {
        this.options = options;
        this.identifier = '@jupyterlab/inline-completer:history';
        this._maxSuggestions = 100;
        const translator = options.translator || nullTranslator;
        this._trans = translator.load('jupyterlab');
    }
    get name() {
        return this._trans.__('History');
    }
    get icon() {
        return historyIcon;
    }
    get schema() {
        return {
            properties: {
                maxSuggestions: {
                    title: this._trans.__('Maximum number of suggestions'),
                    description: this._trans.__('The maximum number of suggestions to retrieve from history.'),
                    type: 'number'
                }
            },
            default: {
                // make this provider opt-in
                enabled: false,
                maxSuggestions: 100
            }
        };
    }
    configure(settings) {
        var _a;
        this._maxSuggestions = (_a = settings.maxSuggestions) !== null && _a !== void 0 ? _a : 100;
    }
    async fetch(request, context, trigger) {
        var _a;
        const kernel = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel;
        if (!kernel) {
            throw new Error('No kernel for completion request.');
        }
        const multiLinePrefix = request.text.slice(0, request.offset);
        const linePrefix = multiLinePrefix.split('\n').slice(-1)[0];
        const historyRequest = {
            output: false,
            raw: true,
            hist_access_type: 'search',
            pattern: linePrefix + '*',
            unique: true,
            n: this._maxSuggestions
        };
        const reply = await kernel.requestHistory(historyRequest);
        const items = [];
        if (linePrefix === '') {
            return { items: [] };
        }
        if (reply.content.status === 'ok') {
            for (const entry of reply.content.history) {
                const sourceLines = entry[2].split('\n');
                for (let i = 0; i < sourceLines.length; i++) {
                    const line = sourceLines[i];
                    if (line.startsWith(linePrefix)) {
                        const followingLines = line.slice(linePrefix.length, line.length) +
                            '\n' +
                            sourceLines.slice(i + 1).join('\n');
                        items.push({
                            insertText: followingLines
                        });
                    }
                }
            }
        }
        return { items };
    }
}
//# sourceMappingURL=inlinehistoryprovider.js.map