// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { PanelLayout, Widget } from '@lumino/widgets';
import { Signal } from '@lumino/signaling';
import { HoverBox } from '@jupyterlab/ui-components';
import { kernelIcon, Toolbar } from '@jupyterlab/ui-components';
import { GhostTextManager } from './ghost';
const INLINE_COMPLETER_CLASS = 'jp-InlineCompleter';
const INLINE_COMPLETER_ACTIVE_CLASS = 'jp-mod-inline-completer-active';
const HOVER_CLASS = 'jp-InlineCompleter-hover';
const PROGRESS_BAR_CLASS = 'jp-InlineCompleter-progressBar';
/**
 * Widget enabling user to choose among inline completions,
 * typically by pressing next/previous buttons, and showing
 * additional metadata about active completion, such as
 * inline completion provider name.
 */
export class InlineCompleter extends Widget {
    constructor(options) {
        var _a, _b;
        super({ node: document.createElement('div') });
        this._clearHoverTimeout = null;
        this._current = 0;
        this._editor = null;
        this._lastItem = null;
        this._model = null;
        this._providerWidget = new Widget();
        this._showShortcuts = InlineCompleter.defaultSettings.showShortcuts;
        this._showWidget = InlineCompleter.defaultSettings.showWidget;
        this._suggestionsCounter = new Widget();
        this._toolbar = new Toolbar();
        this.model = (_a = options.model) !== null && _a !== void 0 ? _a : null;
        this.editor = (_b = options.editor) !== null && _b !== void 0 ? _b : null;
        this.addClass(INLINE_COMPLETER_CLASS);
        this._ghostManager = new GhostTextManager({
            onBlur: this._onEditorBlur.bind(this)
        });
        this._trans = options.trans;
        const layout = (this.layout = new PanelLayout());
        layout.addWidget(this._suggestionsCounter);
        layout.addWidget(this.toolbar);
        layout.addWidget(this._providerWidget);
        this._progressBar = document.createElement('div');
        this._progressBar.className = PROGRESS_BAR_CLASS;
        this.node.appendChild(this._progressBar);
        this._updateShortcutsVisibility();
        this._updateDisplay();
        // Allow the node to receive focus, which prevents removing the ghost text
        // when user mis-clicks on the tooltip instead of the button in the tooltip.
        this.node.tabIndex = 0;
    }
    /**
     * Toolbar with buttons such as previous/next/accept.
     */
    get toolbar() {
        return this._toolbar;
    }
    /**
     * The editor used by the completion widget.
     */
    get editor() {
        return this._editor;
    }
    set editor(newValue) {
        var _a;
        (_a = this.model) === null || _a === void 0 ? void 0 : _a.reset();
        this._editor = newValue;
    }
    /**
     * The model used by the completer widget.
     */
    get model() {
        return this._model;
    }
    set model(model) {
        if ((!model && !this._model) || model === this._model) {
            return;
        }
        if (this._model) {
            this._model.suggestionsChanged.disconnect(this._onModelSuggestionsChanged, this);
            this._model.filterTextChanged.disconnect(this._onModelFilterTextChanged, this);
            this._model.provisionProgress.disconnect(this._onProvisionProgress, this);
        }
        this._model = model;
        if (this._model) {
            this._model.suggestionsChanged.connect(this._onModelSuggestionsChanged, this);
            this._model.filterTextChanged.connect(this._onModelFilterTextChanged, this);
            this._model.provisionProgress.connect(this._onProvisionProgress, this);
        }
    }
    cycle(direction) {
        var _a, _b;
        const items = (_b = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions) === null || _b === void 0 ? void 0 : _b.items;
        if (!items) {
            return;
        }
        if (direction === 'next') {
            const proposed = this._current + 1;
            this._current = proposed === items.length ? 0 : proposed;
        }
        else {
            const proposed = this._current - 1;
            this._current = proposed === -1 ? items.length - 1 : proposed;
        }
        this._updateStreamTracking();
        this._render();
    }
    accept() {
        const model = this.model;
        const candidate = this.current;
        const editor = this._editor;
        if (!editor || !model || !candidate) {
            return;
        }
        const position = model.cursor;
        const value = candidate.insertText;
        const cursorBeforeChange = editor.getOffsetAt(editor.getCursorPosition());
        const requestPosition = editor.getOffsetAt(position);
        const start = requestPosition;
        const end = cursorBeforeChange;
        // update the shared model in a single transaction so that the undo manager works as expected
        editor.model.sharedModel.updateSource(requestPosition, cursorBeforeChange, value);
        if (cursorBeforeChange <= end && cursorBeforeChange >= start) {
            editor.setCursorPosition(editor.getPositionAt(start + value.length));
        }
        model.reset();
        this.update();
    }
    get current() {
        var _a;
        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;
        if (!completions) {
            return null;
        }
        return completions.items[this._current];
    }
    _updateStreamTracking() {
        if (this._lastItem) {
            this._lastItem.stream.disconnect(this._onStream, this);
        }
        const current = this.current;
        if (current) {
            current.stream.connect(this._onStream, this);
        }
        this._lastItem = current;
    }
    _onStream(_emitter, _change) {
        var _a;
        // TODO handle stuck streams, i.e. if we connected and received 'opened'
        // but then did not receive 'closed' for a long time we should disconnect
        // and update widget with an 'timed out' status.
        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;
        if (!completions || !completions.items || completions.items.length === 0) {
            return;
        }
        if (this.isHidden) {
            return;
        }
        const candidate = completions.items[this._current];
        this._setText(candidate);
    }
    /**
     * Change user-configurable settings.
     */
    configure(settings) {
        this._showWidget = settings.showWidget;
        this._updateDisplay();
        if (settings.showShortcuts !== this._showShortcuts) {
            this._showShortcuts = settings.showShortcuts;
            this._updateShortcutsVisibility();
        }
        GhostTextManager.streamingAnimation = settings.streamingAnimation;
    }
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event) {
        if (this.isHidden || !this._editor) {
            return;
        }
        switch (event.type) {
            case 'pointerdown':
                this._evtPointerdown(event);
                break;
            case 'scroll':
                this._evtScroll(event);
                break;
            default:
                break;
        }
    }
    /**
     * Handle `update-request` messages.
     */
    onUpdateRequest(msg) {
        super.onUpdateRequest(msg);
        const model = this._model;
        if (!model) {
            return;
        }
        let reply = model.completions;
        // If there are no items, hide.
        if (!reply || !reply.items || reply.items.length === 0) {
            if (!this.isHidden) {
                this.hide();
            }
            return;
        }
        if (this.isHidden) {
            this.show();
            this._setGeometry();
        }
    }
    /**
     * Handle `after-attach` messages for the widget.
     */
    onAfterAttach(msg) {
        document.addEventListener('scroll', this, true);
        document.addEventListener('pointerdown', this, true);
    }
    /**
     * Handle `before-detach` messages for the widget.
     */
    onBeforeDetach(msg) {
        document.removeEventListener('scroll', this, true);
        document.removeEventListener('pointerdown', this, true);
    }
    /**
     * Handle pointerdown events for the widget.
     */
    _evtPointerdown(event) {
        var _a;
        if (this.isHidden || !this._editor) {
            return;
        }
        const target = event.target;
        if (this.node.contains(target)) {
            return true;
        }
        this.hide();
        (_a = this.model) === null || _a === void 0 ? void 0 : _a.reset();
    }
    /**
     * Handle scroll events for the widget
     */
    _evtScroll(event) {
        if (this.isHidden || !this._editor) {
            return;
        }
        const { node } = this;
        // All scrolls except scrolls in the actual hover box node may cause the
        // referent editor that anchors the node to move, so the only scroll events
        // that can safely be ignored are ones that happen inside the hovering node.
        if (node.contains(event.target)) {
            return;
        }
        // Set the geometry of the node asynchronously.
        requestAnimationFrame(() => {
            this._setGeometry();
        });
    }
    _onEditorBlur(event) {
        var _a;
        if (this.node.contains(event.relatedTarget)) {
            // Cancel removing ghost text if our node is receiving focus
            return false;
        }
        // The ghost text will be removed, so nothing to accept
        (_a = this._editor) === null || _a === void 0 ? void 0 : _a.host.classList.remove(INLINE_COMPLETER_ACTIVE_CLASS);
        // Hide the widget if editor was blurred.
        this.hide();
    }
    _onModelSuggestionsChanged(_emitter, args) {
        var _a;
        if (!this.isAttached) {
            this.update();
            return;
        }
        if (args.event === 'set') {
            this._current = (_a = args.indexMap.get(this._current)) !== null && _a !== void 0 ? _a : 0;
        }
        else if (args.event === 'clear') {
            const editor = this.editor;
            if (editor) {
                this._ghostManager.clearGhosts(editor.editor);
                editor.host.classList.remove(INLINE_COMPLETER_ACTIVE_CLASS);
            }
        }
        this._updateStreamTracking();
        this.update();
        this._render();
    }
    _onModelFilterTextChanged(_emitter, mapping) {
        var _a, _b;
        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;
        if (!completions || !completions.items || completions.items.length === 0) {
            return;
        }
        this._current = (_b = mapping.get(this._current)) !== null && _b !== void 0 ? _b : 0;
        this._updateStreamTracking();
        // Because the signal will be emitted during `EditorView.update` we want to
        // wait for the update to complete before calling `this._render()`. As there
        // is no API to check if update is done, we instead defer to next engine tick.
        setTimeout(() => {
            this._render();
            // (reading layout to get coordinate to position hoverbox is not allowed either)
            this._setGeometry();
        }, 0);
    }
    _onProvisionProgress(_emitter, progress) {
        requestAnimationFrame(() => {
            if (progress.pendingProviders === 0) {
                this._progressBar.style.display = 'none';
            }
            else {
                this._progressBar.style.display = '';
                this._progressBar.style.width =
                    (100 * progress.pendingProviders) / progress.totalProviders + '%';
            }
        });
    }
    _render() {
        var _a, _b;
        const completions = (_a = this.model) === null || _a === void 0 ? void 0 : _a.completions;
        if (!completions || !completions.items || completions.items.length === 0) {
            return;
        }
        const candidate = completions.items[this._current];
        this._setText(candidate);
        if (this._showWidget === 'never') {
            return;
        }
        this._suggestionsCounter.node.innerText = this._trans.__('%1/%2', this._current + 1, completions.items.length);
        this._providerWidget.node.title = this._trans.__('Provider: %1', candidate.provider.name);
        const icon = (_b = candidate.provider.icon) !== null && _b !== void 0 ? _b : kernelIcon;
        icon.render(this._providerWidget.node);
    }
    _setText(item) {
        const text = item.insertText;
        const editor = this._editor;
        const model = this._model;
        if (!model || !editor) {
            return;
        }
        const view = editor.editor;
        this._ghostManager.placeGhost(view, {
            from: editor.getOffsetAt(model.cursor),
            content: text,
            providerId: item.provider.identifier,
            addedPart: item.lastStreamed,
            streaming: item.streaming,
            onPointerOver: this._onPointerOverGhost.bind(this),
            onPointerLeave: this._onPointerLeaveGhost.bind(this)
        });
        editor.host.classList.add(INLINE_COMPLETER_ACTIVE_CLASS);
    }
    _onPointerOverGhost() {
        if (this._clearHoverTimeout !== null) {
            window.clearTimeout(this._clearHoverTimeout);
            this._clearHoverTimeout = null;
        }
        this.node.classList.add(HOVER_CLASS);
    }
    _onPointerLeaveGhost() {
        // Remove after a small delay to avoid flicker when moving cursor
        // between the lines or around the edges of the ghost text.
        this._clearHoverTimeout = window.setTimeout(() => this.node.classList.remove(HOVER_CLASS), 500);
    }
    _setGeometry() {
        const { node } = this;
        const model = this._model;
        const editor = this._editor;
        if (!editor || !model || !model.cursor) {
            return;
        }
        const host = editor.host.closest('.jp-MainAreaWidget > .lm-Widget') ||
            editor.host;
        let anchor;
        try {
            anchor = editor.getCoordinateForPosition(model.cursor);
        }
        catch (_a) {
            // if coordinate is no longer in editor (e.g. after deleting a line), hide widget
            this.hide();
            return;
        }
        HoverBox.setGeometry({
            anchor,
            host: host,
            maxHeight: 40,
            minHeight: 20,
            node: node,
            privilege: 'forceAbove',
            outOfViewDisplay: {
                top: 'stick-outside',
                bottom: 'stick-inside',
                left: 'stick-inside',
                right: 'stick-outside'
            }
        });
    }
    _updateShortcutsVisibility() {
        this.node.dataset.showShortcuts = this._showShortcuts + '';
    }
    _updateDisplay() {
        this.node.dataset.display = this._showWidget;
    }
}
/**
 * A namespace for inline completer statics.
 */
(function (InlineCompleter) {
    /**
     * Defaults for runtime user-configurable settings.
     */
    InlineCompleter.defaultSettings = {
        showWidget: 'onHover',
        showShortcuts: true,
        streamingAnimation: 'uncover',
        providers: {}
    };
    /**
     * Model for inline completions.
     */
    class Model {
        constructor() {
            this.suggestionsChanged = new Signal(this);
            this.filterTextChanged = new Signal(this);
            this.provisionProgress = new Signal(this);
            this._isDisposed = false;
            this._completions = null;
        }
        setCompletions(reply) {
            var _a, _b;
            const previousPositions = new Map((_b = (_a = this._completions) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.map((item, index) => [item.insertText, index]));
            this._completions = reply;
            const indexMap = new Map(reply.items.map((item, newIndex) => [
                previousPositions.get(item.insertText),
                newIndex
            ]));
            this.suggestionsChanged.emit({
                event: 'set',
                indexMap
            });
        }
        appendCompletions(reply) {
            if (!this._completions || !this._completions.items) {
                console.warn('No completions to append to');
                return;
            }
            this._completions.items.push(...reply.items);
            this.suggestionsChanged.emit({ event: 'append' });
        }
        notifyProgress(progress) {
            this.provisionProgress.emit(progress);
        }
        get cursor() {
            return this._cursor;
        }
        set cursor(value) {
            this._cursor = value;
        }
        get completions() {
            return this._completions;
        }
        reset() {
            this._completions = null;
            this.suggestionsChanged.emit({ event: 'clear' });
        }
        /**
         * Get whether the model is disposed.
         */
        get isDisposed() {
            return this._isDisposed;
        }
        handleTextChange(sourceChange) {
            var _a;
            const completions = this._completions;
            if (!completions ||
                !completions.items ||
                completions.items.length === 0) {
                return;
            }
            const originalPositions = new Map(completions.items.map((item, index) => [item, index]));
            for (let change of (_a = sourceChange.sourceChange) !== null && _a !== void 0 ? _a : []) {
                const insert = change.insert;
                if (insert) {
                    const items = completions.items.filter(item => {
                        var _a;
                        const filterText = (_a = item.filterText) !== null && _a !== void 0 ? _a : item.insertText;
                        if (!filterText.startsWith(insert)) {
                            return false;
                        }
                        item.filterText = filterText.substring(insert.length);
                        item.insertText = item.insertText.substring(insert.length);
                        return true;
                    });
                    if (items.length === 0) {
                        // all items from this provider were filtered out
                        this._completions = null;
                    }
                    completions.items = items;
                }
                else {
                    if (!change.retain) {
                        this._completions = null;
                    }
                }
            }
            const indexMap = new Map(completions.items.map((item, newIndex) => [
                originalPositions.get(item),
                newIndex
            ]));
            this.filterTextChanged.emit(indexMap);
        }
        handleSelectionChange(range) {
            const initialCursor = this.cursor;
            if (!initialCursor) {
                return;
            }
            const { start, end } = range;
            if (start.column !== end.column || start.line !== end.line) {
                // Cancel if user started selecting text.
                this.reset();
            }
            if (start.line !== initialCursor.line ||
                start.column < initialCursor.column) {
                // Cancel if user moved cursor to next line or receded to before the origin
                this.reset();
            }
        }
        /**
         * Dispose of the resources held by the model.
         */
        dispose() {
            // Do nothing if already disposed.
            if (this._isDisposed) {
                return;
            }
            this._isDisposed = true;
            Signal.clearData(this);
        }
    }
    InlineCompleter.Model = Model;
})(InlineCompleter || (InlineCompleter = {}));
//# sourceMappingURL=inline.js.map