/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
import { Dialog, showDialog } from '@jupyterlab/apputils';
import { URLExt } from '@jupyterlab/coreutils';
import { ServerConnection } from '@jupyterlab/services';
import { VDomModel } from '@jupyterlab/ui-components';
import { Signal } from '@lumino/signaling';
import { PromiseDelegate } from '@lumino/coreutils';
import { nullTranslator } from '@jupyterlab/translation';
import { PluginInUseMessage, PluginRequiredMessage } from './dialogs';
/**
 * The server API path for querying/modifying available plugins.
 */
const PLUGIN_API_PATH = 'lab/api/plugins';
/**
 * The model representing plugin list.
 */
export class PluginListModel extends VDomModel {
    constructor(options) {
        var _a, _b, _c;
        super();
        /**
         * Contains an error message if an error occurred when querying plugin status.
         */
        this.statusError = null;
        /**
         * Contains an error message if an error occurred when enabling/disabling plugin.
         */
        this.actionError = null;
        this._trackerDataChanged = new Signal(this);
        this._isLoading = false;
        this._pendingActions = [];
        this._ready = new PromiseDelegate();
        this._pluginData = options.pluginData;
        this._serverSettings =
            options.serverSettings || ServerConnection.makeSettings();
        this._query = options.query || '';
        this._isDisclaimed = (_a = options.isDisclaimed) !== null && _a !== void 0 ? _a : false;
        this._extraLockedPlugins = (_b = options.extraLockedPlugins) !== null && _b !== void 0 ? _b : [];
        this.refresh()
            .then(() => this._ready.resolve())
            .catch(e => this._ready.reject(e));
        this._trans = ((_c = options.translator) !== null && _c !== void 0 ? _c : nullTranslator).load('jupyterlab');
    }
    get available() {
        return [...this._available.values()];
    }
    /**
     * Whether plugin data is still getting loaded.
     */
    get isLoading() {
        return this._isLoading;
    }
    /**
     * Whether the warning is disclaimed or not.
     */
    get isDisclaimed() {
        return this._isDisclaimed;
    }
    set isDisclaimed(v) {
        if (v !== this._isDisclaimed) {
            this._isDisclaimed = v;
            this.stateChanged.emit();
            this._trackerDataChanged.emit(void 0);
        }
    }
    /**
     * The search query.
     *
     * Setting its value triggers a new search.
     */
    get query() {
        return this._query;
    }
    set query(value) {
        if (this._query !== value) {
            this._query = value;
            this.stateChanged.emit();
            this._trackerDataChanged.emit(void 0);
        }
    }
    /**
     * A promise that resolves when the trackable data changes
     */
    get trackerDataChanged() {
        return this._trackerDataChanged;
    }
    /**
     * A promise that resolves when the plugins were fetched from the server
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * Enable a plugin.
     *
     * @param entry An entry indicating which plugin to enable.
     */
    async enable(entry) {
        if (!this.isDisclaimed) {
            throw new Error('User has not confirmed the disclaimer');
        }
        await this._performAction('enable', entry);
        entry.enabled = true;
    }
    /**
     * Disable a plugin.
     *
     * @param entry An entry indicating which plugin to disable.
     * @returns Whether the plugin was disabled
     */
    async disable(entry) {
        if (!this.isDisclaimed) {
            throw new Error('User has not confirmed the disclaimer');
        }
        const { dependants, optionalDependants } = this.getDependants(entry);
        if (dependants.length > 0) {
            // We require user to disable plugins one-by-one as each of them may have
            // further dependencies (or optional dependencies) and we want the user to
            // take a pause to think about those.
            void showDialog({
                title: this._trans.__('This plugin is required by other plugins'),
                body: PluginRequiredMessage({
                    plugin: entry,
                    dependants,
                    trans: this._trans
                }),
                buttons: [Dialog.okButton()]
            });
            return;
        }
        if (optionalDependants.length > 0) {
            const userConfirmation = await showDialog({
                title: this._trans.__('This plugin is used by other plugins'),
                body: PluginInUseMessage({
                    plugin: entry,
                    optionalDependants,
                    trans: this._trans
                }),
                buttons: [
                    Dialog.okButton({ label: this._trans.__('Disable anyway') }),
                    Dialog.cancelButton()
                ]
            });
            if (!userConfirmation.button.accept) {
                return;
            }
        }
        await this._performAction('disable', entry);
        if (this.actionError) {
            return;
        }
        entry.enabled = false;
    }
    getDependants(entry) {
        const dependants = [];
        const optionalDependants = [];
        if (entry.provides) {
            const tokenName = entry.provides.name;
            for (const plugin of this._available.values()) {
                if (!plugin.enabled) {
                    continue;
                }
                if (plugin.requires
                    .filter(token => !!token)
                    .some(token => token.name === tokenName)) {
                    dependants.push(plugin);
                }
                if (plugin.optional
                    .filter(token => !!token)
                    .some(token => token.name === tokenName)) {
                    optionalDependants.push(plugin);
                }
            }
        }
        return {
            dependants,
            optionalDependants
        };
    }
    /**
     * Whether there are currently any actions pending.
     */
    hasPendingActions() {
        return this._pendingActions.length > 0;
    }
    /**
     * Send a request to the server to perform an action on a plugin.
     *
     * @param action A valid action to perform.
     * @param entry The plugin to perform the action on.
     */
    _performAction(action, entry) {
        this.actionError = null;
        const actionRequest = this._requestAPI({}, {
            method: 'POST',
            body: JSON.stringify({
                cmd: action,
                plugin_name: entry.id
            })
        });
        actionRequest.catch(reason => {
            this.actionError = reason.toString();
        });
        this._addPendingAction(actionRequest);
        return actionRequest;
    }
    /**
     * Add a pending action.
     *
     * @param pending A promise that resolves when the action is completed.
     */
    _addPendingAction(pending) {
        // Add to pending actions collection
        this._pendingActions.push(pending);
        // Ensure action is removed when resolved
        const remove = () => {
            const i = this._pendingActions.indexOf(pending);
            this._pendingActions.splice(i, 1);
            this.stateChanged.emit(undefined);
        };
        pending.then(remove, remove);
        // Signal changed state
        this.stateChanged.emit(undefined);
    }
    /**
     * Refresh plugin lock statuses
     */
    async refresh() {
        var _a;
        this.statusError = null;
        this._isLoading = true;
        this.stateChanged.emit();
        try {
            // Get the lock status from backend; if backend is not available,
            // we assume that all plugins are locked.
            const fallback = {
                allLocked: true,
                lockRules: []
            };
            const status = (_a = (await this._requestAPI())) !== null && _a !== void 0 ? _a : fallback;
            this._available = new Map(this._pluginData.availablePlugins.map(plugin => {
                let tokenLabel = plugin.provides
                    ? plugin.provides.name.split(':')[1]
                    : undefined;
                if (plugin.provides && !tokenLabel) {
                    tokenLabel = plugin.provides.name;
                }
                return [
                    plugin.id,
                    {
                        ...plugin,
                        locked: this._isLocked(plugin.id, status),
                        tokenLabel
                    }
                ];
            }));
        }
        catch (reason) {
            this.statusError = reason.toString();
        }
        finally {
            this._isLoading = false;
            this.stateChanged.emit();
        }
    }
    _isLocked(pluginId, status) {
        if (status.allLocked) {
            // All plugins are locked.
            return true;
        }
        if (this._extraLockedPlugins.includes(pluginId)) {
            // Plugin is locked on client side.
            return true;
        }
        const extension = pluginId.split(':')[0];
        if (status.lockRules.includes(extension)) {
            // Entire extension is locked.
            return true;
        }
        if (status.lockRules.includes(pluginId)) {
            // This plugin specifically is locked.
            return true;
        }
        return false;
    }
    /**
     * Call the plugin API
     *
     * @param endPoint API REST end point for the plugin
     * @param init Initial values for the request
     * @returns The response body interpreted as JSON
     */
    async _requestAPI(queryArgs = {}, init = {}) {
        // Make request to Jupyter API
        const settings = this._serverSettings;
        const requestUrl = URLExt.join(settings.baseUrl, PLUGIN_API_PATH);
        let response;
        try {
            response = await ServerConnection.makeRequest(requestUrl + URLExt.objectToQueryString(queryArgs), init, settings);
        }
        catch (error) {
            throw new ServerConnection.NetworkError(error);
        }
        let data = await response.text();
        if (data.length > 0) {
            try {
                data = JSON.parse(data);
            }
            catch (error) {
                console.log('Not a JSON response body.', response);
            }
        }
        if (!response.ok) {
            throw new ServerConnection.ResponseError(response, data.message || data);
        }
        return data;
    }
}
//# sourceMappingURL=model.js.map