import type { JupyterLab } from '@jupyterlab/application';
import { ServerConnection } from '@jupyterlab/services';
import { VDomModel } from '@jupyterlab/ui-components';
import { ISignal } from '@lumino/signaling';
import { ITranslator } from '@jupyterlab/translation';
/**
 * Extension actions that the server API accepts.
 */
export type Action = 'enable' | 'disable';
/**
 * Information about a plugin.
 */
export interface IEntry extends JupyterLab.IPluginInfo {
    /**
     * Whether the plugin is locked (cannot be enabled/disabled).
     *
     * Administrators can lock plugins preventing users from introducing modifications.
     * The check is performed on the server side, this field is only to show users
     * an indicator of the lock status.
     */
    readonly locked: boolean;
    /**
     * Token name (if any) excluding the plugin prefix (unless none)
     */
    tokenLabel?: string;
}
/**
 * An object representing a server reply to performing an action.
 */
export interface IActionReply {
    /**
     * The status category of the reply.
     */
    status: 'ok' | 'warning' | 'error' | null;
    /**
     * An optional message when the status is not 'ok'.
     */
    message?: string;
}
/**
 * The namespace for PluginListModel.
 */
export declare namespace PluginListModel {
    interface IConfigurableState {
        /**
         * The plugin list search query.
         */
        query?: string;
        /**
         * Whether the warning is disclaimed or not.
         */
        isDisclaimed?: boolean;
    }
    /** A subset of `JupyterLab.IInfo` interface (defined to reduce API surface) */
    interface IPluginData {
        readonly availablePlugins: JupyterLab.IPluginInfo[];
    }
    /**
     * The initialization options for a plugins list model.
     */
    interface IOptions extends IConfigurableState {
        /**
         * Plugin data.
         */
        pluginData: IPluginData;
        /**
         * Translator.
         */
        translator?: ITranslator;
        /**
         * Server connection settings.
         */
        serverSettings?: ServerConnection.ISettings;
        /**
         * Additional plugins to lock in addition to plugins locked on the server-side.
         *
         * This is intended exclusively to protect user from shooting themselves in
         * the foot by accidentally disabling the plugin manager or other core plugins
         * (which would mean they cannot recover) and is not enforced on server side.
         */
        extraLockedPlugins?: string[];
    }
}
/**
 * The model representing plugin list.
 */
export declare class PluginListModel extends VDomModel {
    constructor(options: PluginListModel.IOptions);
    get available(): ReadonlyArray<IEntry>;
    /**
     * Contains an error message if an error occurred when querying plugin status.
     */
    statusError: string | null;
    /**
     * Contains an error message if an error occurred when enabling/disabling plugin.
     */
    actionError: string | null;
    /**
     * Whether plugin data is still getting loaded.
     */
    get isLoading(): boolean;
    /**
     * Whether the warning is disclaimed or not.
     */
    get isDisclaimed(): boolean;
    set isDisclaimed(v: boolean);
    /**
     * The search query.
     *
     * Setting its value triggers a new search.
     */
    get query(): string;
    set query(value: string);
    /**
     * A promise that resolves when the trackable data changes
     */
    get trackerDataChanged(): ISignal<PluginListModel, void>;
    /**
     * A promise that resolves when the plugins were fetched from the server
     */
    get ready(): Promise<void>;
    /**
     * Enable a plugin.
     *
     * @param entry An entry indicating which plugin to enable.
     */
    enable(entry: IEntry): Promise<void>;
    /**
     * Disable a plugin.
     *
     * @param entry An entry indicating which plugin to disable.
     * @returns Whether the plugin was disabled
     */
    disable(entry: IEntry): Promise<void>;
    protected getDependants(entry: IEntry): {
        dependants: IEntry[];
        optionalDependants: IEntry[];
    };
    /**
     * Whether there are currently any actions pending.
     */
    hasPendingActions(): boolean;
    /**
     * Send a request to the server to perform an action on a plugin.
     *
     * @param action A valid action to perform.
     * @param entry The plugin to perform the action on.
     */
    private _performAction;
    /**
     * Add a pending action.
     *
     * @param pending A promise that resolves when the action is completed.
     */
    private _addPendingAction;
    /**
     * Refresh plugin lock statuses
     */
    refresh(): Promise<void>;
    private _isLocked;
    /**
     * Call the plugin API
     *
     * @param endPoint API REST end point for the plugin
     * @param init Initial values for the request
     * @returns The response body interpreted as JSON
     */
    private _requestAPI;
    private _trackerDataChanged;
    private _available;
    private _isLoading;
    private _pendingActions;
    private _serverSettings;
    private _ready;
    private _query;
    private _pluginData;
    private _extraLockedPlugins;
    private _trans;
    private _isDisclaimed;
}
