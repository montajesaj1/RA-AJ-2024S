import { Cell } from '@jupyterlab/cells';
import { ISessionContext } from '@jupyterlab/apputils';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { KernelMessage } from '@jupyterlab/services';
import { ITranslator } from '@jupyterlab/translation';
import { IDisposable } from '@lumino/disposable';
/**
 * The definition of a console history manager object.
 */
export interface INotebookHistory extends IDisposable {
    /**
     * The current editor used by the history widget.
     */
    editor: CodeEditor.IEditor | null;
    /**
     * The placeholder text that a history session began with.
     */
    readonly placeholder: string;
    /**
     * The session number of the current kernel session
     */
    readonly kernelSession: string;
    /**
     * Get the previous item in the console history.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     *
     * @returns A Promise for console command text or `undefined` if unavailable.
     */
    back(activeCell: Cell): Promise<string | undefined>;
    /**
     * Get the next item in the console history.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     *
     * @returns A Promise for console command text or `undefined` if unavailable.
     */
    forward(activeCell: Cell): Promise<string | undefined>;
    /**
     * Reset the history navigation state, i.e., start a new history session.
     */
    reset(): void;
    /**
     * Get the next item in the console history.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     * @param content - the result from back or forward
     */
    updateEditor(activeCell: Cell, content: string | undefined): void;
}
/**
 * A console history manager object.
 */
export declare class NotebookHistory implements INotebookHistory {
    /**
     * Construct a new console history object.
     */
    constructor(options: NotebookHistory.IOptions);
    /**
     * The client session used to query history.
     */
    private _sessionContext;
    /**
     * Translator to be used for warnings
     */
    private _trans;
    /**
     * The number of history items to request.
     */
    private _toRequest;
    /**
     * The number of history items to increase a batch size by per subsequent request.
     */
    private _requestBatchSize;
    /**
     * The current editor used by the history manager.
     */
    get editor(): CodeEditor.IEditor | null;
    set editor(value: CodeEditor.IEditor | null);
    /**
     * The placeholder text that a history session began with.
     */
    get placeholder(): string;
    /**
     * Kernel session number for filtering
     */
    get kernelSession(): string;
    /**
     * Get whether the notebook history manager is disposed.
     */
    get isDisposed(): boolean;
    /**
     * Dispose of the resources held by the notebook history manager.
     */
    dispose(): void;
    /**
     * Set placeholder and editor. Start session if one is not already started.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     */
    protected checkSession(activeCell: Cell): Promise<void>;
    /**
     * Get the previous item in the notebook history.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     *
     * @returns A Promise resolving to the historical cell content text.
     */
    back(activeCell: Cell): Promise<string | undefined>;
    /**
     * Get the next item in the notebook history.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     *
     * @returns A Promise resolving to the historical cell content text.
     */
    forward(activeCell: Cell): Promise<string | undefined>;
    /**
     * Update the editor of the cell with provided text content.
     *
     * @param activeCell - The currently selected Cell in the notebook.
     * @param content - the result from back or forward
     */
    updateEditor(activeCell: Cell, content: string | undefined): void;
    /**
     * Reset the history navigation state, i.e., start a new history session.
     */
    reset(): void;
    /**
     * Fetches a subsequent batch of history. Updates the filtered history and cursor to correct place in history,
     * accounting for potentially new history items above it.
     */
    private fetchBatch;
    /**
     * Populate the history collection on history reply from a kernel.
     *
     * @param value The kernel message history reply.
     *
     * #### Notes
     * History entries have the shape:
     * [session: number, line: number, input: string]
     * Contiguous duplicates are stripped out of the API response.
     */
    protected onHistory(value: KernelMessage.IHistoryReplyMsg, cell?: Cell): void;
    /**
     * Handle a text change signal from the editor.
     */
    protected onTextChange(): void;
    /**
     * Handle the current kernel changing.
     */
    private _handleKernel;
    /**
     * retrieve the history from the kernel
     *
     * @param cell - The string to use when filtering the data.
     */
    private _retrieveHistory;
    /**
     * Set the filter data.
     *
     * @param filterStr - The string to use when filtering the data.
     */
    protected setFilter(filterStr?: string): void;
    private _cursor;
    private _hasSession;
    private _history;
    private _placeholder;
    private _kernelSession;
    private _setByHistory;
    private _isDisposed;
    private _editor;
    private _filtered;
    private _kernel;
}
/**
 * A namespace for NotebookHistory statics.
 */
export declare namespace NotebookHistory {
    /**
     * The initialization options for a console history object.
     */
    interface IOptions {
        /**
         * The client session used by the foreign handler.
         */
        sessionContext: ISessionContext;
        /**
         * The application language translator.
         */
        translator?: ITranslator;
    }
}
