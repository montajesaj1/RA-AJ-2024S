/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
/**
 * Semantic group of commands
 */
export class SemanticCommand {
    constructor() {
        this._commands = new Array();
    }
    /**
     * The command IDs used by this semantic command.
     */
    get ids() {
        return this._commands.map(c => c.id);
    }
    /**
     * Add a command to the semantic group
     *
     * @param command Command to add
     */
    add(command) {
        if (this._commands.map(c => c.id).includes(command.id)) {
            throw Error(`Command ${command.id} is already defined.`);
        }
        this._commands.push({
            isEnabled: () => true,
            rank: SemanticCommand.DEFAULT_RANK,
            ...command
        });
    }
    /**
     * Get the command id of the enabled command from this group
     * for the given widget.
     *
     * @param widget Widget
     * @returns Command id
     */
    getActiveCommandId(widget) {
        var _a;
        const commands = this._commands
            .filter(c => c.isEnabled(widget))
            .sort((a, b) => {
            const rankDelta = a.rank - b.rank;
            return rankDelta || (a.id < b.id ? -1 : 1);
        });
        const command = (_a = commands[0]) !== null && _a !== void 0 ? _a : { id: null };
        return command.id;
    }
    /**
     * Remove a command ID.
     *
     * @param id Command ID to remove
     */
    remove(id) {
        const index = this._commands.findIndex(c => c.id === id);
        if (index >= 0) {
            this._commands.splice(index, 1);
        }
    }
}
/**
 * Default rank for semantic command
 */
SemanticCommand.DEFAULT_RANK = 500;
//# sourceMappingURL=semanticCommand.js.map