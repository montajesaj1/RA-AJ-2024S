/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
import { Poll } from '@lumino/polling';
import { Signal } from '@lumino/signaling';
/**
 * The default duration of the auto-refresh in ms
 */
const DEFAULT_REFRESH_INTERVAL = 10000;
/**
 * An implementation of a workspaces model.
 */
export class WorkspacesModel {
    constructor(options) {
        var _a;
        this._refreshed = new Signal(this);
        this._isDisposed = false;
        this._workspaceData = {
            ids: [],
            values: []
        };
        this._manager = options.manager;
        const refreshInterval = options.refreshInterval || DEFAULT_REFRESH_INTERVAL;
        this._poll = new Poll({
            auto: (_a = options.auto) !== null && _a !== void 0 ? _a : true,
            name: '@jupyterlab/workspaces:Model',
            factory: () => this._fetchList(),
            frequency: {
                interval: refreshInterval,
                backoff: true,
                max: 300 * 1000
            },
            standby: options.refreshStandby || 'when-hidden'
        });
    }
    /**
     * The list of available workspaces.
     */
    get workspaces() {
        return this._workspaceData.values;
    }
    /**
     * The list of workspace identifiers.
     */
    get identifiers() {
        return this._workspaceData.ids;
    }
    /**
     * Create an empty workspace.
     */
    async create(workspaceId) {
        await this._manager.save(workspaceId, {
            metadata: { id: workspaceId },
            data: {}
        });
        await this.refresh();
    }
    /**
     * A signal emitted when the workspaces list is refreshed.
     */
    get refreshed() {
        return this._refreshed;
    }
    /**
     * Force a refresh of the workspaces list.
     */
    async refresh() {
        await this._poll.refresh();
        await this._poll.tick;
    }
    /**
     * Rename a workspace.
     */
    async rename(workspaceId, newName) {
        const workspace = await this._manager.fetch(workspaceId);
        workspace.metadata.id = newName;
        await this._manager.save(newName, workspace);
        await this._manager.remove(workspaceId);
        await this.refresh();
    }
    /**
     * Reset a workspace.
     */
    async reset(workspaceId) {
        const workspace = await this._manager.fetch(workspaceId);
        workspace.data = {};
        await this._manager.save(workspaceId, workspace);
        await this.refresh();
    }
    /**
     * Remove a workspace.
     */
    async remove(workspaceId) {
        await this._manager.remove(workspaceId);
        await this.refresh();
    }
    /**
     * Save workspace under a different name.
     */
    async saveAs(workspaceId, newName) {
        const data = await this._manager.fetch(workspaceId);
        data.metadata.id = newName;
        await this._manager.save(newName, data);
        await this.refresh();
    }
    /**
     * Get whether the model is disposed.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Dispose of the resources held by the model.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        this._poll.dispose();
        Signal.clearData(this);
    }
    async _fetchList() {
        this._workspaceData = await this._manager.list();
        this._refreshed.emit(void 0);
    }
}
//# sourceMappingURL=model.js.map