/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module markedparser-extension
 */
import { PromiseDelegate } from '@lumino/coreutils';
import { LruCache } from '@jupyterlab/coreutils';
import { IEditorLanguageRegistry } from '@jupyterlab/codemirror';
import { IMarkdownParser } from '@jupyterlab/rendermime';
import { IMermaidMarkdown } from '@jupyterlab/mermaid';
// highlight cache key separator
const FENCE = '```~~~';
/**
 * Create a markdown parser
 *
 * @param languages Editor languages
 * @returns Markdown parser
 */
export function createMarkdownParser(languages, options) {
    return {
        render: (content) => {
            return Private.render(content, languages, options);
        }
    };
}
/**
 * The markdown parser plugin.
 */
const plugin = {
    id: '@jupyterlab/markedparser-extension:plugin',
    description: 'Provides the Markdown parser.',
    autoStart: true,
    provides: IMarkdownParser,
    requires: [IEditorLanguageRegistry],
    optional: [IMermaidMarkdown],
    activate: (app, languages, mermaidMarkdown) => {
        return createMarkdownParser(languages, {
            blocks: mermaidMarkdown ? [mermaidMarkdown] : []
        });
    }
};
/**
 * Export the plugin as default.
 */
export default plugin;
/**
 * A namespace for private marked functions
 */
var Private;
(function (Private) {
    let _initializing = null;
    let _marked = null;
    let _blocks = [];
    let _languages = null;
    let _markedOptions = {};
    let _highlights = new LruCache();
    async function render(content, languages, options) {
        _languages = languages;
        if (!_marked) {
            _marked = await initializeMarked(options);
        }
        return _marked(content, _markedOptions);
    }
    Private.render = render;
    /**
     * Load marked lazily and exactly once.
     */
    async function initializeMarked(options) {
        if (_marked) {
            return _marked;
        }
        if (_initializing) {
            return await _initializing.promise;
        }
        // order blocks by `rank`
        _blocks = (options === null || options === void 0 ? void 0 : options.blocks) || [];
        _blocks = _blocks.sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); });
        _initializing = new PromiseDelegate();
        // load marked lazily, and exactly once
        const [{ marked, Renderer }, plugins] = await Promise.all([
            import('marked'),
            loadMarkedPlugins()
        ]);
        // use load marked plugins
        for (const plugin of plugins) {
            marked.use(plugin);
        }
        // finish marked configuration
        _markedOptions = {
            // use the explicit async paradigm for `walkTokens`
            async: true,
            // enable all built-in GitHub-flavored Markdown opinions
            gfm: true,
            // asynchronously prepare for any special tokens, like highlighting and mermaid
            walkTokens,
            // use custom renderer
            renderer: makeRenderer(Renderer)
        };
        // complete initialization
        _marked = marked;
        _initializing.resolve(_marked);
        return _marked;
    }
    Private.initializeMarked = initializeMarked;
    /**
     * Load and use marked plugins.
     *
     * As of writing, both of these features would work without plugins, but emit
     * deprecation warnings.
     */
    async function loadMarkedPlugins() {
        // use loaded marked plugins
        return Promise.all([
            (async () => (await import('marked-gfm-heading-id')).gfmHeadingId())(),
            (async () => (await import('marked-mangle')).mangle())()
        ]);
    }
    /**
     * Build a custom marked renderer.
     */
    function makeRenderer(Renderer_) {
        const renderer = new Renderer_();
        const originalCode = renderer.code;
        renderer.code = (code, language) => {
            // handle block renderers
            for (const block of _blocks) {
                if (block.languages.includes(language)) {
                    const rendered = block.render(code);
                    if (rendered != null) {
                        return rendered;
                    }
                }
            }
            // handle known highlighting
            const key = `${language}${FENCE}${code}${FENCE}`;
            const highlight = _highlights.get(key);
            if (highlight != null) {
                return highlight;
            }
            // fall back to calling with the renderer as `this`
            return originalCode.call(renderer, code, language);
        };
        return renderer;
    }
    /**
     * Apply and cache syntax highlighting for code blocks.
     */
    async function highlight(token) {
        const { lang, text } = token;
        if (!lang || !_languages) {
            // no language(s), no highlight
            return;
        }
        const key = `${lang}${FENCE}${text}${FENCE}`;
        if (_highlights.get(key)) {
            // already cached, don't make another DOM element
            return;
        }
        const el = document.createElement('div');
        try {
            await _languages.highlight(text, _languages.findBest(lang), el);
            const html = `<pre><code class="language-${lang}">${el.innerHTML}</code></pre>`;
            _highlights.set(key, html);
        }
        catch (err) {
            console.error(`Failed to highlight ${lang} code`, err);
        }
        finally {
            el.remove();
        }
    }
    /**
     * After parsing, lazily load and render or highlight code blocks
     */
    async function walkTokens(token) {
        switch (token.type) {
            case 'code':
                if (token.lang) {
                    for (const block of _blocks) {
                        if (block.languages.includes(token.lang)) {
                            await block.walk(token.text);
                            return;
                        }
                    }
                }
                await highlight(token);
        }
    }
})(Private || (Private = {}));
//# sourceMappingURL=index.js.map