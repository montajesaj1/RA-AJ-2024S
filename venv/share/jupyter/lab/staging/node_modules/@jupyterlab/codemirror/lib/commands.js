/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
import { indentLess, indentMore, insertBlankLine, insertNewlineAndIndent, insertTab, simplifySelection } from '@codemirror/commands';
import { COMPLETER_ACTIVE_CLASS, COMPLETER_ENABLED_CLASS } from '@jupyterlab/codeeditor';
/**
 * Selector for a widget that can run code.
 */
const CODE_RUNNER_SELECTOR = '[data-jp-code-runner]';
/**
 * Selector for a widget that can run code in terminal mode.
 */
const TERMINAL_CODE_RUNNER_SELECTOR = '[data-jp-interaction-mode="terminal"]';
/**
 * Selector for a widget that can open a tooltip.
 */
const TOOLTIP_OPENER_SELECTOR = '.jp-CodeMirrorEditor:not(.jp-mod-has-primary-selection):not(.jp-mod-in-leading-whitespace):not(.jp-mod-completer-active)';
/**
 * Selector for an active cell in edit mode.
 */
const ACTIVE_CELL_IN_EDIT_MODE_SELECTOR = '.jp-mod-editMode .jp-Cell.jp-mod-active';
/**
 * CodeMirror commands namespace
 */
export var StateCommands;
(function (StateCommands) {
    /**
     * Indent or insert a tab as appropriate.
     */
    function indentMoreOrInsertTab(target) {
        var _a;
        if ((_a = target.dom.parentElement) === null || _a === void 0 ? void 0 : _a.classList.contains(COMPLETER_ENABLED_CLASS)) {
            return false;
        }
        const arg = { state: target.state, dispatch: target.dispatch };
        const from = target.state.selection.main.from;
        const to = target.state.selection.main.to;
        if (from != to) {
            return indentMore(arg);
        }
        const line = target.state.doc.lineAt(from);
        const before = target.state.doc.slice(line.from, from).toString();
        if (/^\s*$/.test(before)) {
            return indentMore(arg);
        }
        else {
            return insertTab(arg);
        }
    }
    StateCommands.indentMoreOrInsertTab = indentMoreOrInsertTab;
    /**
     * Insert new line if completer is not active.
     */
    function completerOrInsertNewLine(target) {
        var _a;
        if ((_a = target.dom.parentElement) === null || _a === void 0 ? void 0 : _a.classList.contains(COMPLETER_ACTIVE_CLASS)) {
            // do not prevent default to allow completer `enter` action
            return false;
        }
        if (target.dom.closest(TERMINAL_CODE_RUNNER_SELECTOR)) {
            // do not prevent default to allow for the cell to run
            return false;
        }
        const arg = { state: target.state, dispatch: target.dispatch };
        return insertNewlineAndIndent(arg);
    }
    StateCommands.completerOrInsertNewLine = completerOrInsertNewLine;
    /**
     * Prevent insertion of new line when running cell with Ctrl/Command + Enter
     * @deprecated
     */
    function preventNewLineOnRun(target) {
        if (target.dom.closest(CODE_RUNNER_SELECTOR)) {
            return true;
        }
        return false;
    }
    StateCommands.preventNewLineOnRun = preventNewLineOnRun;
    /**
     * Insert a new line or run a cell with Ctrl/Command + Enter
     */
    function insertBlankLineOnRun(target) {
        if (target.dom.closest(CODE_RUNNER_SELECTOR)) {
            // do not prevent default to allow `run` action to be handled by lumino
            return false;
        }
        else {
            const arg = { state: target.state, dispatch: target.dispatch };
            return insertBlankLine(arg);
        }
    }
    StateCommands.insertBlankLineOnRun = insertBlankLineOnRun;
    /**
     * Simplify selection but do not prevent default to allow switching to command mode.
     */
    function simplifySelectionAndMaybeSwitchToCommandMode(target) {
        const arg = { state: target.state, dispatch: target.dispatch };
        const preventDefault = simplifySelection(arg);
        if (target.dom.closest(ACTIVE_CELL_IN_EDIT_MODE_SELECTOR)) {
            // do not prevent default to allow switching to command mode
            return false;
        }
        else {
            return preventDefault;
        }
    }
    StateCommands.simplifySelectionAndMaybeSwitchToCommandMode = simplifySelectionAndMaybeSwitchToCommandMode;
    /**
     * Prevent dedenting when launching inspection request (a.k.a tooltip).
     *
     * This function should be removed once a better way to prevent default
     * CodeMirror commands is implemented, as tracked in
     * https://github.com/jupyterlab/jupyterlab/issues/15897
     */
    function dedentIfNotLaunchingTooltip(target) {
        if (target.dom.closest(TOOLTIP_OPENER_SELECTOR)) {
            return false;
        }
        return indentLess(target);
    }
    StateCommands.dedentIfNotLaunchingTooltip = dedentIfNotLaunchingTooltip;
})(StateCommands || (StateCommands = {}));
//# sourceMappingURL=commands.js.map