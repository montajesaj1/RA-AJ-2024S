// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module completer-extension
 */
import { CommandToolbarButton } from '@jupyterlab/ui-components';
import { CompletionProviderManager, ContextCompleterProvider, HistoryInlineCompletionProvider, ICompletionProviderManager, IInlineCompleterFactory, InlineCompleter, KernelCompleterProvider } from '@jupyterlab/completer';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { caretLeftIcon, caretRightIcon, checkIcon, IFormRendererRegistry } from '@jupyterlab/ui-components';
import { ITranslator, nullTranslator } from '@jupyterlab/translation';
import { CommandRegistry } from '@lumino/commands';
import { renderAvailableProviders } from './renderer';
const COMPLETION_MANAGER_PLUGIN = '@jupyterlab/completer-extension:manager';
const INLINE_COMPLETER_PLUGIN = '@jupyterlab/completer-extension:inline-completer';
var CommandIDs;
(function (CommandIDs) {
    CommandIDs.nextInline = 'inline-completer:next';
    CommandIDs.previousInline = 'inline-completer:previous';
    CommandIDs.acceptInline = 'inline-completer:accept';
    CommandIDs.invokeInline = 'inline-completer:invoke';
})(CommandIDs || (CommandIDs = {}));
const defaultProviders = {
    id: '@jupyterlab/completer-extension:base-service',
    description: 'Adds context and kernel completion providers.',
    requires: [ICompletionProviderManager],
    autoStart: true,
    activate: (app, completionManager) => {
        completionManager.registerProvider(new ContextCompleterProvider());
        completionManager.registerProvider(new KernelCompleterProvider());
    }
};
const inlineHistoryProvider = {
    id: '@jupyterlab/completer-extension:inline-history',
    description: 'Adds inline completion provider suggesting code from execution history.',
    requires: [ICompletionProviderManager],
    optional: [ITranslator],
    autoStart: true,
    activate: (app, completionManager, translator) => {
        completionManager.registerInlineProvider(new HistoryInlineCompletionProvider({
            translator: translator !== null && translator !== void 0 ? translator : nullTranslator
        }));
    }
};
const inlineCompleterFactory = {
    id: '@jupyterlab/completer-extension:inline-completer-factory',
    description: 'Provides a factory for inline completer.',
    provides: IInlineCompleterFactory,
    optional: [ITranslator],
    autoStart: true,
    activate: (app, translator) => {
        const trans = (translator || nullTranslator).load('jupyterlab');
        return {
            factory: options => {
                const inlineCompleter = new InlineCompleter({
                    ...options,
                    trans: trans
                });
                const describeShortcut = (commandID) => {
                    const binding = app.commands.keyBindings.find(binding => binding.command === commandID);
                    const keys = binding
                        ? CommandRegistry.formatKeystroke(binding.keys)
                        : '';
                    return keys ? `${keys}` : '';
                };
                const labelCache = {
                    [CommandIDs.previousInline]: describeShortcut(CommandIDs.previousInline),
                    [CommandIDs.nextInline]: describeShortcut(CommandIDs.nextInline),
                    [CommandIDs.acceptInline]: describeShortcut(CommandIDs.acceptInline)
                };
                app.commands.keyBindingChanged.connect((_emitter, change) => {
                    const command = change.binding.command;
                    if (labelCache.hasOwnProperty(command)) {
                        labelCache[command] =
                            describeShortcut(command);
                    }
                });
                inlineCompleter.toolbar.addItem('previous-inline-completion', new CommandToolbarButton({
                    commands: app.commands,
                    icon: caretLeftIcon,
                    id: CommandIDs.previousInline,
                    label: () => labelCache[CommandIDs.previousInline],
                    caption: trans.__('Previous')
                }));
                inlineCompleter.toolbar.addItem('next-inline-completion', new CommandToolbarButton({
                    commands: app.commands,
                    icon: caretRightIcon,
                    id: CommandIDs.nextInline,
                    label: () => labelCache[CommandIDs.nextInline],
                    caption: trans.__('Next')
                }));
                inlineCompleter.toolbar.addItem('accept-inline-completion', new CommandToolbarButton({
                    commands: app.commands,
                    icon: checkIcon,
                    id: CommandIDs.acceptInline,
                    label: () => labelCache[CommandIDs.acceptInline],
                    caption: trans.__('Accept')
                }));
                return inlineCompleter;
            }
        };
    }
};
const inlineCompleter = {
    id: INLINE_COMPLETER_PLUGIN,
    description: 'Provides a factory for inline completer.',
    requires: [
        ICompletionProviderManager,
        IInlineCompleterFactory,
        ISettingRegistry
    ],
    optional: [ITranslator],
    autoStart: true,
    activate: (app, completionManager, factory, settings, translator) => {
        completionManager.setInlineCompleterFactory(factory);
        const trans = (translator || nullTranslator).load('jupyterlab');
        const isEnabled = () => !!app.shell.currentWidget && !!completionManager.inline;
        app.commands.addCommand(CommandIDs.nextInline, {
            execute: () => {
                var _a;
                (_a = completionManager.inline) === null || _a === void 0 ? void 0 : _a.cycle(app.shell.currentWidget.id, 'next');
            },
            label: trans.__('Next Inline Completion'),
            isEnabled
        });
        app.commands.addCommand(CommandIDs.previousInline, {
            execute: () => {
                var _a;
                (_a = completionManager.inline) === null || _a === void 0 ? void 0 : _a.cycle(app.shell.currentWidget.id, 'previous');
            },
            label: trans.__('Previous Inline Completion'),
            isEnabled
        });
        app.commands.addCommand(CommandIDs.acceptInline, {
            execute: () => {
                var _a;
                (_a = completionManager.inline) === null || _a === void 0 ? void 0 : _a.accept(app.shell.currentWidget.id);
            },
            label: trans.__('Accept Inline Completion'),
            isEnabled
        });
        app.commands.addCommand(CommandIDs.invokeInline, {
            execute: () => {
                var _a;
                (_a = completionManager.inline) === null || _a === void 0 ? void 0 : _a.invoke(app.shell.currentWidget.id);
            },
            label: trans.__('Invoke Inline Completer'),
            isEnabled
        });
        const updateSettings = (settings) => {
            var _a;
            (_a = completionManager.inline) === null || _a === void 0 ? void 0 : _a.configure(settings.composite);
        };
        app.restored
            .then(() => {
            var _a;
            const availableProviders = (_a = completionManager.inlineProviders) !== null && _a !== void 0 ? _a : [];
            const composeDefaults = (provider) => {
                var _a, _b;
                return {
                    // By default all providers are opt-out, but
                    // any provider can configure itself to be opt-in.
                    enabled: true,
                    timeout: 5000,
                    debouncerDelay: 0,
                    ...((_b = (_a = provider.schema) === null || _a === void 0 ? void 0 : _a.default) !== null && _b !== void 0 ? _b : {})
                };
            };
            settings.transform(INLINE_COMPLETER_PLUGIN, {
                compose: plugin => {
                    var _a, _b;
                    const providers = (_a = plugin.data.composite['providers']) !== null && _a !== void 0 ? _a : {};
                    for (const provider of availableProviders) {
                        const defaults = composeDefaults(provider);
                        providers[provider.identifier] = {
                            ...defaults,
                            ...((_b = providers[provider.identifier]) !== null && _b !== void 0 ? _b : {})
                        };
                    }
                    // Add fallback defaults in composite settings values
                    plugin.data['composite']['providers'] = providers;
                    return plugin;
                },
                fetch: plugin => {
                    var _a, _b;
                    const schema = plugin.schema.properties;
                    const providersSchema = {};
                    for (const provider of availableProviders) {
                        providersSchema[provider.identifier] = {
                            title: trans.__('%1 provider', provider.name),
                            properties: {
                                ...((_b = (_a = provider.schema) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}),
                                timeout: {
                                    title: trans.__('Timeout'),
                                    description: trans.__('Timeout for %1 provider (in milliseconds).', provider.name),
                                    type: 'number',
                                    minimum: 0
                                },
                                debouncerDelay: {
                                    title: trans.__('Debouncer delay'),
                                    minimum: 0,
                                    description: trans.__('Time since the last key press to wait before requesting completions from %1 provider (in milliseconds).', provider.name),
                                    type: 'number'
                                },
                                enabled: {
                                    title: trans.__('Enabled'),
                                    description: trans.__('Whether to fetch completions %1 provider.', provider.name),
                                    type: 'boolean'
                                }
                            },
                            default: composeDefaults(provider),
                            type: 'object'
                        };
                    }
                    // Populate schema for providers settings
                    schema['providers']['properties'] = providersSchema;
                    return plugin;
                }
            });
            const settingsPromise = settings.load(INLINE_COMPLETER_PLUGIN);
            settingsPromise
                .then(settingValues => {
                updateSettings(settingValues);
                settingValues.changed.connect(newSettings => {
                    updateSettings(newSettings);
                });
            })
                .catch(console.error);
        })
            .catch(console.error);
        const findKeybinding = (commandID) => {
            return app.commands.keyBindings.find(binding => binding.command === commandID);
        };
        const keyBindings = {
            [CommandIDs.acceptInline]: findKeybinding(CommandIDs.acceptInline),
            [CommandIDs.invokeInline]: findKeybinding(CommandIDs.invokeInline)
        };
        app.commands.keyBindingChanged.connect((_emitter, change) => {
            const command = change.binding.command;
            if (keyBindings.hasOwnProperty(command)) {
                keyBindings[command] =
                    findKeybinding(command);
            }
        });
        const evtKeydown = (event) => {
            // Handle bindings to `Tab` key specially
            if (!(event.target instanceof Element)) {
                return;
            }
            const target = event.target;
            switch (event.keyCode) {
                case 9: {
                    // Tab key
                    const potentialTabBindings = [
                        // Note: `accept` should come ahead of `invoke` due to specificity
                        keyBindings[CommandIDs.acceptInline],
                        keyBindings[CommandIDs.invokeInline]
                    ];
                    for (const binding of potentialTabBindings) {
                        if (binding &&
                            binding.keys.length === 1 &&
                            binding.keys[0] === 'Tab' &&
                            target.closest(binding.selector)) {
                            app.commands.execute(binding.command).catch(console.error);
                            event.preventDefault();
                            event.stopPropagation();
                            event.stopImmediatePropagation();
                            return;
                        }
                    }
                    break;
                }
                default:
                    return;
            }
        };
        document.addEventListener('keydown', evtKeydown, true);
    }
};
const manager = {
    id: COMPLETION_MANAGER_PLUGIN,
    description: 'Provides the completion provider manager.',
    requires: [ISettingRegistry],
    optional: [IFormRendererRegistry],
    provides: ICompletionProviderManager,
    autoStart: true,
    activate: (app, settings, editorRegistry) => {
        const AVAILABLE_PROVIDERS = 'availableProviders';
        const PROVIDER_TIMEOUT = 'providerTimeout';
        const SHOW_DOCUMENT_PANEL = 'showDocumentationPanel';
        const CONTINUOUS_HINTING = 'autoCompletion';
        const manager = new CompletionProviderManager();
        const updateSetting = (settingValues, availableProviders) => {
            var _a;
            const providersData = settingValues.get(AVAILABLE_PROVIDERS);
            const timeout = settingValues.get(PROVIDER_TIMEOUT);
            const showDoc = settingValues.get(SHOW_DOCUMENT_PANEL);
            const continuousHinting = settingValues.get(CONTINUOUS_HINTING);
            manager.setTimeout(timeout.composite);
            manager.setShowDocumentationPanel(showDoc.composite);
            manager.setContinuousHinting(continuousHinting.composite);
            const selectedProviders = (_a = providersData.user) !== null && _a !== void 0 ? _a : providersData.composite;
            const sortedProviders = Object.entries(selectedProviders !== null && selectedProviders !== void 0 ? selectedProviders : {})
                .filter(val => val[1] >= 0 && availableProviders.includes(val[0]))
                .sort(([, rank1], [, rank2]) => rank2 - rank1)
                .map(item => item[0]);
            manager.activateProvider(sortedProviders);
        };
        app.restored
            .then(() => {
            const availableProviders = [...manager.getProviders().entries()];
            const availableProviderIDs = availableProviders.map(([key, value]) => key);
            settings.transform(COMPLETION_MANAGER_PLUGIN, {
                fetch: plugin => {
                    const schema = plugin.schema.properties;
                    const defaultValue = {};
                    availableProviders.forEach(([key, value], index) => {
                        var _a;
                        defaultValue[key] = (_a = value.rank) !== null && _a !== void 0 ? _a : (index + 1) * 10;
                    });
                    schema[AVAILABLE_PROVIDERS]['default'] = defaultValue;
                    return plugin;
                }
            });
            const settingsPromise = settings.load(COMPLETION_MANAGER_PLUGIN);
            settingsPromise
                .then(settingValues => {
                updateSetting(settingValues, availableProviderIDs);
                settingValues.changed.connect(newSettings => {
                    updateSetting(newSettings, availableProviderIDs);
                });
            })
                .catch(console.error);
        })
            .catch(console.error);
        if (editorRegistry) {
            const renderer = {
                fieldRenderer: (props) => {
                    return renderAvailableProviders(props);
                }
            };
            editorRegistry.addRenderer(`${COMPLETION_MANAGER_PLUGIN}.availableProviders`, renderer);
        }
        return manager;
    }
};
/**
 * Export the plugins as default.
 */
const plugins = [
    manager,
    defaultProviders,
    inlineHistoryProvider,
    inlineCompleterFactory,
    inlineCompleter
];
export default plugins;
//# sourceMappingURL=index.js.map