#!/usr/bin/env node
"use strict";
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.upgradeLock = void 0;
const core_1 = require("@yarnpkg/core");
const parsers_1 = require("@yarnpkg/parsers");
const commander_1 = require("commander");
const fs_1 = __importDefault(require("fs"));
const micromatch_1 = __importDefault(require("micromatch"));
const semver_1 = __importDefault(require("semver"));
const utils_1 = require("./utils");
// Copied from https://github.com/yarnpkg/berry/blob/d85702c61e3b19715c728fa9d2ecec68dcbf39b2/packages/yarnpkg-core/sources/Project.ts#L1988
const yarnLockHeader = `${[
    `# This file is generated by running "yarn install" inside your project.\n`,
    `# Manual changes might be lost - proceed with caution!\n`
].join(``)}\n`;
function upgradeLock(packages, options) {
    var _a;
    (0, utils_1.exitOnUncaughtException)();
    const lockFile = (_a = options.lock) !== null && _a !== void 0 ? _a : 'yarn.lock';
    // Load current yarn.lock
    const pkgs = loadPackages(lockFile);
    const pkgToDescriptor = new Map();
    for (const pkg in pkgs) {
        if (pkg.startsWith('__')) {
            continue;
        }
        const name = extractNameFromDescriptor(pkgs[pkg].resolution);
        if (pkgToDescriptor.has(name)) {
            pkgToDescriptor.get(name).push(pkg);
        }
        else {
            pkgToDescriptor.set(name, [pkg]);
        }
    }
    // Update the yarn.lock file recursevily at most 5 times (normally twice is enough)
    let counter = 5;
    do {
        (0, utils_1.run)('jlpm install', { cwd: options.cwd });
    } while (upgradeSelectedPackages(lockFile, pkgToDescriptor, packages, pkgs) &&
        counter-- > 0);
    // Check that the yarn.lock is immutable
    (0, utils_1.run)('jlpm install --immutable', { cwd: options.cwd });
}
exports.upgradeLock = upgradeLock;
/**
 * Downgrade package versions to match old locked version expect
 * for the package matching the provided pattern.
 *
 * @param lockFile yarn.lock file
 * @param pkgToDescriptor Package name to yarn descriptors
 * @param packages Package pattern to update
 * @param pkgs Original package versions
 * @returns Whether some versions have been downgraded or not
 */
function upgradeSelectedPackages(lockFile, pkgToDescriptor, packages, pkgs) {
    let hasChange = false;
    const newPkgs = loadPackages(lockFile);
    for (const pkg in newPkgs) {
        if (pkg.startsWith('__')) {
            continue;
        }
        const name = extractNameFromDescriptor(newPkgs[pkg].resolution);
        if (pkgToDescriptor.has(name)) {
            if (!micromatch_1.default.isMatch(name, packages)) {
                let noMatch = true;
                for (const origDescriptor of pkgToDescriptor.get(name)) {
                    const origPkg = pkgs[origDescriptor];
                    if (pkg.split(',').every(desc => {
                        const parsedDesc = core_1.structUtils.parseDescriptor(desc.trim());
                        const range = core_1.structUtils.parseRange(parsedDesc.range);
                        return (!semver_1.default.validRange(range.selector) ||
                            semver_1.default.satisfies(origPkg.version, range.selector));
                    })) {
                        noMatch = false;
                        if (origPkg.version !== newPkgs[pkg].version) {
                            hasChange = true;
                            console.log(`Downgrade '${name}' from ${newPkgs[pkg].version} to ${origPkg.version}`);
                            newPkgs[pkg] = origPkg;
                        }
                        break;
                    }
                }
                if (noMatch) {
                    console.warn(`No package found for '${pkg}'.`);
                }
            }
            else {
                console.log(`Ignoring package '${pkg}'.`);
            }
        }
        else {
            console.warn(`New package '${pkg}' added.`);
        }
    }
    if (hasChange) {
        const newLock = yarnLockHeader + (0, parsers_1.stringifySyml)(newPkgs);
        fs_1.default.writeFileSync(lockFile, newLock, { encoding: 'utf-8' });
    }
    return hasChange;
}
function extractNameFromDescriptor(name) {
    const descriptor = core_1.structUtils.parseDescriptor(name.split(',')[0].trim());
    return descriptor.scope
        ? `@${descriptor.scope}/${descriptor.name}`
        : descriptor.name;
}
function loadPackages(lockFile) {
    const yarnLock = fs_1.default.readFileSync(lockFile, { encoding: 'utf-8' });
    return (0, parsers_1.parseSyml)(yarnLock);
}
if (require.main === module) {
    commander_1.program
        .description('Update yarn.lock at minima; aka only packages matching the provided pattern (support fnmatch syntax) are updated.')
        .option('--lock', 'yarn.lock file name', 'yarn.lock')
        .arguments('packages')
        .action(upgradeLock);
    commander_1.program.parse(process.argv);
}
//# sourceMappingURL=update-staging-lock.js.map