/**
 * Shortcut registry used by Shortcut UI component.
 */
export class ShortcutRegistry extends Map {
    constructor(options) {
        var _a, _b, _c;
        super();
        const { settings, commandRegistry } = options;
        const userBindings = (_a = settings.user.shortcuts) !== null && _a !== void 0 ? _a : [];
        const setByUser = new Set(userBindings.map(this._computeKeybindingId.bind(this)));
        const luminoKeybindings = (_b = settings.composite.shortcuts) !== null && _b !== void 0 ? _b : [];
        for (const shortcut of luminoKeybindings) {
            const targetKey = this._computeTargetId(shortcut);
            const keybindingKey = this._computeKeybindingId(shortcut);
            const keybinding = {
                keys: shortcut.keys,
                isDefault: !setByUser.has(keybindingKey)
            };
            const shortcutTarget = this.get(targetKey);
            if (shortcutTarget) {
                shortcutTarget.keybindings.push(keybinding);
            }
            else {
                const commandParts = shortcut.command.split(':');
                const label = (_c = commandRegistry.label(shortcut.command, shortcut.args)) !== null && _c !== void 0 ? _c : (commandParts.length > 1 ? commandParts[1] : undefined);
                const category = commandParts[0];
                this.set(targetKey, {
                    id: targetKey,
                    selector: shortcut.selector,
                    command: shortcut.command,
                    category,
                    label,
                    args: shortcut.args,
                    keybindings: [keybinding]
                });
            }
        }
    }
    /**
     * Find targets that would conflict with given keys chord under given sequence.
     */
    findConflictsFor(keys, selector) {
        const checker = new KeybindingsConflictChecker({ registry: this });
        // First check the full chain
        let conflicts = checker.findConflicts(keys, selector);
        if (conflicts.length !== 0) {
            return conflicts;
        }
        // Then check each piece of the chain
        for (const binding of keys) {
            conflicts = checker.findConflicts([binding], selector);
            if (conflicts.length !== 0) {
                return conflicts;
            }
        }
        return [];
    }
    _computeTargetId(shortcut) {
        var _a;
        return (shortcut.command +
            '_' +
            shortcut.selector +
            '_' +
            JSON.stringify((_a = shortcut.args) !== null && _a !== void 0 ? _a : {}));
    }
    _computeKeybindingId(shortcut) {
        var _a;
        return [
            shortcut.command,
            shortcut.selector,
            JSON.stringify((_a = shortcut.args) !== null && _a !== void 0 ? _a : {}),
            shortcut.keys.join(' ')
        ].join('_');
    }
}
/**
 * Allows checking if a given keybinding is available, or directly conflicts with other targets.
 */
class KeybindingsConflictChecker {
    constructor(options) {
        var _a;
        const keybindingsMap = new Map();
        for (const shortcutTarget of options.registry.values()) {
            for (const keybinding of shortcutTarget.keybindings) {
                const hash = this._keybindingHash(keybinding.keys, shortcutTarget.selector);
                const list = (_a = keybindingsMap.get(hash)) !== null && _a !== void 0 ? _a : [];
                list.push(shortcutTarget);
                keybindingsMap.set(hash, list);
            }
        }
        this._keybindingsMap = keybindingsMap;
    }
    findConflicts(keys, selector) {
        var _a;
        const hash = this._keybindingHash(keys, selector);
        return (_a = this._keybindingsMap.get(hash)) !== null && _a !== void 0 ? _a : [];
    }
    _keybindingHash(keys, selector) {
        return keys.join(' ') + '_' + selector;
    }
}
//# sourceMappingURL=registry.js.map