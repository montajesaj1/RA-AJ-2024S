/*
 * Copyright (c) Jupyter Development Team.
 * Distributed under the terms of the Modified BSD License.
 */
import { Platform } from '@lumino/domutils';
import * as React from 'react';
import { ShortcutInput } from './ShortcutInput';
/** React component for each command shortcut item */
export class ShortcutItem extends React.Component {
    constructor(props) {
        super(props);
        /** Toggle display state of input box */
        this.toggleInputNew = () => {
            this.setState({
                displayNewInput: !this.state.displayNewInput
            });
        };
        /** Transform special key names into unicode characters */
        this.toSymbols = (value) => {
            return value.split(' ').reduce((result, key) => {
                if (key === 'Ctrl') {
                    return (result + ' ⌃').trim();
                }
                else if (key === 'Alt') {
                    return (result + ' ⌥').trim();
                }
                else if (key === 'Shift') {
                    return (result + ' ⇧').trim();
                }
                else if (key === 'Accel' && Platform.IS_MAC) {
                    return (result + ' ⌘').trim();
                }
                else if (key === 'Accel') {
                    return (result + ' ⌃').trim();
                }
                else {
                    return (result + ' ' + key).trim();
                }
            }, '');
        };
        this._trans = this.props.external.translator.load('jupyterlab');
        this.state = {
            displayNewInput: false,
            displayReplaceInput: Object.freeze({}),
            conflicts: new Map()
        };
    }
    componentDidMount() {
        this.props.external.actionRequested.connect(this._onActionRequested, this);
    }
    componentWillUnmount() {
        this.props.external.actionRequested.disconnect(this._onActionRequested, this);
    }
    async _onActionRequested(_, action) {
        if ('shortcutId' in action &&
            action.shortcutId !== this.props.shortcut.id) {
            return;
        }
        if (action.request === 'add-keybinding') {
            return this.toggleInputNew();
        }
        if (action.request === 'edit-keybinding') {
            this.toggleInputReplaceMethod(action.keybinding);
        }
        if (action.request === 'delete-keybinding') {
            const target = this.props.shortcut;
            const binding = target.keybindings[action.keybinding];
            this.props.deleteKeybinding(target, binding).catch(console.error);
        }
    }
    getCategoryCell() {
        return (React.createElement("div", { className: "jp-Shortcuts-Cell" }, this.props.shortcut.category));
    }
    getLabelCell() {
        var _a;
        return (React.createElement("div", { className: "jp-Shortcuts-Cell" },
            React.createElement("div", { className: "jp-label" }, (_a = this.props.shortcut.label) !== null && _a !== void 0 ? _a : this._trans.__('(Command label missing)'))));
    }
    getResetShortCutLink() {
        return (React.createElement("a", { className: "jp-Shortcuts-Reset", onClick: () => this.props.resetKeybindings(this.props.shortcut) }, this._trans.__('Reset')));
    }
    getSourceCell() {
        const allDefault = this.props.shortcut.keybindings.every(binding => binding.isDefault);
        return (React.createElement("div", { className: "jp-Shortcuts-Cell" },
            React.createElement("div", { className: "jp-Shortcuts-SourceCell" }, allDefault ? this._trans.__('Default') : this._trans.__('Custom')),
            !allDefault ? this.getResetShortCutLink() : ''));
    }
    getOptionalSelectorCell() {
        return this.props.showSelectors ? (React.createElement("div", { className: "jp-Shortcuts-Cell" },
            React.createElement("div", { className: "jp-selector" }, this.props.shortcut.selector))) : null;
    }
    getClassNameForShortCuts(nonEmptyBindings) {
        const classes = ['jp-Shortcuts-ShortcutCell'];
        switch (nonEmptyBindings.length) {
            case 1:
                classes.push('jp-Shortcuts-SingleCell');
                break;
            case 0:
                classes.push('jp-Shortcuts-EmptyCell');
                break;
        }
        return classes.join(' ');
    }
    toggleInputReplaceMethod(location) {
        const previous = this.state.displayReplaceInput[location];
        this.setState({
            displayReplaceInput: {
                ...this.state.displayReplaceInput,
                [location]: !previous
            }
        });
    }
    getDisplayReplaceInput(location) {
        return this.state.displayReplaceInput[location];
    }
    getOrDiplayIfNeeded(force) {
        const classes = ['jp-Shortcuts-Or'];
        if (force || this.state.displayNewInput) {
            classes.push('jp-Shortcuts-Or-Forced');
        }
        return React.createElement("div", { className: classes.join(' ') }, this._trans.__('or'));
    }
    getShortCutAsInput(binding, location) {
        return (React.createElement(ShortcutInput, { addKeybinding: this.props.addKeybinding, replaceKeybinding: this.props.replaceKeybinding, deleteKeybinding: this.props.deleteKeybinding, findConflictsFor: this.props.findConflictsFor, toggleInput: () => this.toggleInputReplaceMethod(location), shortcut: this.props.shortcut, keybinding: binding, displayConflicts: (data) => {
                const conflicts = new Map(this.state.conflicts);
                conflicts.set(binding, data);
                this.setState({ conflicts });
            }, toSymbols: this.toSymbols, displayInput: this.getDisplayReplaceInput(location), placeholder: this.toSymbols(binding.keys.join(', ')), translator: this.props.external.translator }));
    }
    getShortCutForDisplayOnly(binding) {
        return binding.keys.map((keyboardKey, index) => (React.createElement("div", { className: "jp-Shortcuts-ShortcutKeysContainer", key: index },
            React.createElement("div", { className: "jp-Shortcuts-ShortcutKeys" }, this.toSymbols(keyboardKey)),
            index + 1 < binding.keys.length ? (React.createElement("div", { className: "jp-Shortcuts-Comma" }, ",")) : null)));
    }
    isLocationBeingEdited(location) {
        return this.state.displayReplaceInput[location];
    }
    getDivForKey(index, binding, nonEmptyBindings) {
        return (React.createElement("div", { className: "jp-Shortcuts-ShortcutContainer", key: this.props.shortcut.id + '_' + index, "data-keybinding": index, "data-shortcut": this.props.shortcut.id, onClick: () => this.toggleInputReplaceMethod(index) },
            this.isLocationBeingEdited(index)
                ? this.getShortCutAsInput(binding, index)
                : this.getShortCutForDisplayOnly(binding),
            this.getOrDiplayIfNeeded(index < nonEmptyBindings.length - 1)));
    }
    getAddLink() {
        return (React.createElement("a", { className: !this.state.displayNewInput ? 'jp-Shortcuts-Plus' : '', onClick: () => {
                this.toggleInputNew();
            } }, this._trans.__('Add')));
    }
    getInputBoxWhenToggled() {
        return this.state.displayNewInput ? (React.createElement(ShortcutInput, { addKeybinding: this.props.addKeybinding, replaceKeybinding: this.props.replaceKeybinding, deleteKeybinding: this.props.deleteKeybinding, findConflictsFor: this.props.findConflictsFor, toggleInput: this.toggleInputNew, shortcut: this.props.shortcut, displayConflicts: (data) => {
                const conflicts = new Map(this.state.conflicts);
                conflicts.set(null, data);
                this.setState({ conflicts });
            }, toSymbols: this.toSymbols, displayInput: this.state.displayNewInput, placeholder: '', translator: this.props.external.translator })) : (React.createElement("div", null));
    }
    getShortCutsCell(nonEmptyBindings) {
        return (React.createElement("div", { className: "jp-Shortcuts-Cell" },
            React.createElement("div", { className: this.getClassNameForShortCuts(nonEmptyBindings) },
                nonEmptyBindings.map((key, index) => this.getDivForKey(index, key, nonEmptyBindings)),
                nonEmptyBindings.length >= 1 &&
                    !this.state.displayNewInput &&
                    !this.state.displayReplaceInput[0] &&
                    this.getAddLink(),
                nonEmptyBindings.length === 0 &&
                    !this.state.displayNewInput &&
                    this.getAddLink(),
                this.getInputBoxWhenToggled())));
    }
    getConflicts() {
        const conflicts = [...this.state.conflicts.values()].filter(conflict => conflict.conflictsWith.length !== 0);
        if (conflicts.length === 0) {
            return React.createElement(React.Fragment, null);
        }
        return (React.createElement("div", { className: "jp-Shortcuts-Row" },
            React.createElement("div", { className: "jp-Shortcuts-ConflictContainer" }, conflicts.map(conflict => {
                const key = conflict.keys.join(' ') +
                    '_' +
                    conflict.conflictsWith.map(target => target.id).join('');
                return (React.createElement("div", { className: "jp-Shortcuts-Conflict", key: key },
                    React.createElement("div", { className: "jp-Shortcuts-ErrorMessage" }, this._trans.__('Shortcut already in use by %1. Overwrite it?', conflict.conflictsWith
                        .map(target => { var _a; return (_a = target.label) !== null && _a !== void 0 ? _a : target.command; })
                        .join(', '))),
                    React.createElement("div", { className: "jp-Shortcuts-ErrorButton" },
                        React.createElement("button", null, this._trans.__('Cancel')),
                        React.createElement("button", { id: "no-blur", onClick: () => {
                                conflict.overwrite();
                            } }, this._trans.__('Overwrite')))));
            }))));
    }
    get _nonEmptyBindings() {
        return this.props.shortcut.keybindings.filter(binding => binding.keys.filter(k => k != '').length !== 0);
    }
    render() {
        return (React.createElement(React.Fragment, null,
            React.createElement("div", { className: "jp-Shortcuts-Row", "data-shortcut": this.props.shortcut.id },
                this.getCategoryCell(),
                this.getLabelCell(),
                this.getShortCutsCell(this._nonEmptyBindings),
                this.getSourceCell(),
                this.getOptionalSelectorCell()),
            this.getConflicts()));
    }
}
//# sourceMappingURL=ShortcutItem.js.map