// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module documentsearch-extension
 */
import { ILabShell } from '@jupyterlab/application';
import { ICommandPalette, MainAreaWidget } from '@jupyterlab/apputils';
import { ISearchProviderRegistry, SearchDocumentModel, SearchDocumentView, SearchProviderRegistry } from '@jupyterlab/documentsearch';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { ITranslator } from '@jupyterlab/translation';
import { Widget } from '@lumino/widgets';
/**
 * Class added to widgets that can be searched (have a search provider).
 */
const SEARCHABLE_CLASS = 'jp-mod-searchable';
/**
 * Class added to widgets with open search view (not necessarily focused).
 */
const SEARCH_ACTIVE_CLASS = 'jp-mod-search-active';
var CommandIDs;
(function (CommandIDs) {
    /**
     * Start search in a document
     */
    CommandIDs.search = 'documentsearch:start';
    /**
     * Start search and replace in a document
     */
    CommandIDs.searchAndReplace = 'documentsearch:startWithReplace';
    /**
     * Find next search match
     */
    CommandIDs.findNext = 'documentsearch:highlightNext';
    /**
     * Find previous search match
     */
    CommandIDs.findPrevious = 'documentsearch:highlightPrevious';
    /**
     * End search in a document
     */
    CommandIDs.end = 'documentsearch:end';
    /**
     * Toggle search in selection
     */
    CommandIDs.toggleSearchInSelection = 'documentsearch:toggleSearchInSelection';
})(CommandIDs || (CommandIDs = {}));
const labShellWidgetListener = {
    id: '@jupyterlab/documentsearch-extension:labShellWidgetListener',
    description: 'Active search on valid document',
    requires: [ILabShell, ISearchProviderRegistry],
    autoStart: true,
    activate: (app, labShell, registry) => {
        // If a given widget is searchable, apply the searchable class.
        // If it's not searchable, remove the class.
        const transformWidgetSearchability = (widget) => {
            if (!widget) {
                return;
            }
            if (registry.hasProvider(widget)) {
                widget.addClass(SEARCHABLE_CLASS);
            }
            else {
                widget.removeClass(SEARCHABLE_CLASS);
            }
        };
        // Update searchability of the active widget when the registry
        // changes, in case a provider for the current widget was added
        // or removed
        registry.changed.connect(() => transformWidgetSearchability(labShell.activeWidget));
        // Apply the searchable class only to the active widget if it is actually
        // searchable. Remove the searchable class from a widget when it's
        // no longer active.
        labShell.activeChanged.connect((_, args) => {
            const oldWidget = args.oldValue;
            if (oldWidget) {
                oldWidget.removeClass(SEARCHABLE_CLASS);
            }
            transformWidgetSearchability(args.newValue);
        });
    }
};
/**
 * Exposes the current keybindings to search box view.
 */
class SearchKeyBindings {
    constructor(_commandRegistry) {
        this._commandRegistry = _commandRegistry;
        this._cache = this._buildCache();
        this._commandRegistry.keyBindingChanged.connect(this._rebuildCache, this);
    }
    get next() {
        return this._cache.next;
    }
    get previous() {
        return this._cache.previous;
    }
    get toggleSearchInSelection() {
        return this._cache.toggleSearchInSelection;
    }
    _rebuildCache() {
        this._cache = this._buildCache();
    }
    _buildCache() {
        const next = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.findNext);
        const previous = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.findPrevious);
        const toggleSearchInSelection = this._commandRegistry.keyBindings.find(binding => binding.command === CommandIDs.toggleSearchInSelection);
        return {
            next,
            previous,
            toggleSearchInSelection
        };
    }
    dispose() {
        this._commandRegistry.keyBindingChanged.disconnect(this._rebuildCache, this);
    }
}
/**
 * Initialization data for the document-search extension.
 */
const extension = {
    id: '@jupyterlab/documentsearch-extension:plugin',
    description: 'Provides the document search registry.',
    provides: ISearchProviderRegistry,
    requires: [ITranslator],
    optional: [ICommandPalette, ISettingRegistry],
    autoStart: true,
    activate: (app, translator, palette, settingRegistry) => {
        var _a;
        const trans = translator.load('jupyterlab');
        let searchDebounceTime = 500;
        let autoSearchInSelection = 'never';
        // Create registry
        const registry = new SearchProviderRegistry(translator);
        const searchViews = new Map();
        if (settingRegistry) {
            const loadSettings = settingRegistry.load(extension.id);
            const updateSettings = (settings) => {
                searchDebounceTime = settings.get('searchDebounceTime')
                    .composite;
                autoSearchInSelection = settings.get('autoSearchInSelection')
                    .composite;
            };
            Promise.all([loadSettings, app.restored])
                .then(([settings]) => {
                updateSettings(settings);
                settings.changed.connect(settings => {
                    updateSettings(settings);
                });
            })
                .catch((reason) => {
                console.error(reason.message);
            });
        }
        const isEnabled = () => {
            const widget = app.shell.currentWidget;
            if (!widget) {
                return false;
            }
            return registry.hasProvider(widget);
        };
        const getSearchWidget = (widget) => {
            if (!widget) {
                return;
            }
            const widgetId = widget.id;
            let searchView = searchViews.get(widgetId);
            if (!searchView) {
                const searchProvider = registry.getProvider(widget);
                if (!searchProvider) {
                    return;
                }
                const searchModel = new SearchDocumentModel(searchProvider, searchDebounceTime);
                const keyBingingsInfo = new SearchKeyBindings(app.commands);
                const newView = new SearchDocumentView(searchModel, translator, keyBingingsInfo);
                searchViews.set(widgetId, newView);
                // find next, previous and end are now enabled
                [
                    CommandIDs.findNext,
                    CommandIDs.findPrevious,
                    CommandIDs.end,
                    CommandIDs.toggleSearchInSelection
                ].forEach(id => {
                    app.commands.notifyCommandChanged(id);
                });
                /**
                 * Activate the target widget when the search panel is closing
                 */
                newView.closed.connect(() => {
                    if (!widget.isDisposed) {
                        widget.activate();
                        widget.removeClass(SEARCH_ACTIVE_CLASS);
                    }
                });
                /**
                 * Remove from mapping when the search view is disposed.
                 */
                newView.disposed.connect(() => {
                    if (!widget.isDisposed) {
                        widget.activate();
                        widget.removeClass(SEARCH_ACTIVE_CLASS);
                    }
                    searchViews.delete(widgetId);
                    // find next, previous and end are now disabled
                    [
                        CommandIDs.findNext,
                        CommandIDs.findPrevious,
                        CommandIDs.end,
                        CommandIDs.toggleSearchInSelection
                    ].forEach(id => {
                        app.commands.notifyCommandChanged(id);
                    });
                });
                /**
                 * Dispose resources when the widget is disposed.
                 */
                widget.disposed.connect(() => {
                    newView.dispose();
                    searchModel.dispose();
                    searchProvider.dispose();
                    keyBingingsInfo.dispose();
                });
                searchView = newView;
            }
            if (!searchView.isAttached) {
                Widget.attach(searchView, widget.node);
                widget.addClass(SEARCH_ACTIVE_CLASS);
                if (widget instanceof MainAreaWidget) {
                    // Offset the position of the search widget to not cover the toolbar nor the content header.
                    // TODO this does not update once the search widget is displayed.
                    searchView.node.style.top = `${widget.toolbar.node.getBoundingClientRect().height +
                        widget.contentHeader.node.getBoundingClientRect().height}px`;
                }
                if (searchView.model.searchExpression) {
                    searchView.model.refresh();
                }
            }
            return searchView;
        };
        app.commands.addCommand(CommandIDs.search, {
            label: trans.__('Find…'),
            isEnabled: isEnabled,
            execute: async (args) => {
                const searchWidget = getSearchWidget(app.shell.currentWidget);
                if (searchWidget) {
                    const searchText = args['searchText'];
                    if (searchText) {
                        searchWidget.setSearchText(searchText);
                    }
                    else {
                        searchWidget.setSearchText(searchWidget.model.suggestedInitialQuery);
                    }
                    const selectionState = searchWidget.model.selectionState;
                    let enableSelectionMode = false;
                    switch (autoSearchInSelection) {
                        case 'multiple-selected':
                            enableSelectionMode = selectionState === 'multiple';
                            break;
                        case 'any-selected':
                            enableSelectionMode =
                                selectionState === 'multiple' || selectionState === 'single';
                            break;
                        case 'never':
                            // no-op
                            break;
                    }
                    if (enableSelectionMode) {
                        await searchWidget.model.setFilter('selection', true);
                    }
                    searchWidget.focusSearchInput();
                }
            }
        });
        app.commands.addCommand(CommandIDs.searchAndReplace, {
            label: trans.__('Find and Replace…'),
            isEnabled: isEnabled,
            execute: args => {
                const searchWidget = getSearchWidget(app.shell.currentWidget);
                if (searchWidget) {
                    const searchText = args['searchText'];
                    if (searchText) {
                        searchWidget.setSearchText(searchText);
                    }
                    else {
                        searchWidget.setSearchText(searchWidget.model.suggestedInitialQuery);
                    }
                    const replaceText = args['replaceText'];
                    if (replaceText) {
                        searchWidget.setReplaceText(replaceText);
                    }
                    searchWidget.showReplace();
                    searchWidget.focusSearchInput();
                }
            }
        });
        app.commands.addCommand(CommandIDs.findNext, {
            label: trans.__('Find Next'),
            isEnabled: () => !!app.shell.currentWidget &&
                searchViews.has(app.shell.currentWidget.id),
            execute: async () => {
                var _a;
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                await ((_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model.highlightNext());
            }
        });
        app.commands.addCommand(CommandIDs.findPrevious, {
            label: trans.__('Find Previous'),
            isEnabled: () => !!app.shell.currentWidget &&
                searchViews.has(app.shell.currentWidget.id),
            execute: async () => {
                var _a;
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                await ((_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model.highlightPrevious());
            }
        });
        app.commands.addCommand(CommandIDs.end, {
            label: trans.__('End Search'),
            isEnabled: () => !!app.shell.currentWidget &&
                searchViews.has(app.shell.currentWidget.id),
            execute: async () => {
                var _a;
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                (_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.close();
            }
        });
        app.commands.addCommand(CommandIDs.toggleSearchInSelection, {
            label: trans.__('Search in Selection'),
            isEnabled: () => !!app.shell.currentWidget &&
                searchViews.has(app.shell.currentWidget.id) &&
                'selection' in
                    searchViews.get(app.shell.currentWidget.id).model.filtersDefinition,
            execute: async () => {
                var _a;
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                const model = (_a = searchViews.get(currentWidget.id)) === null || _a === void 0 ? void 0 : _a.model;
                if (!model) {
                    return;
                }
                const currentValue = model.filters['selection'];
                return model.setFilter('selection', !currentValue);
            }
        });
        (_a = app.shell.currentChanged) === null || _a === void 0 ? void 0 : _a.connect(() => {
            Object.values(CommandIDs).forEach(cmd => {
                app.commands.notifyCommandChanged(cmd);
            });
        });
        // Add the command to the palette.
        if (palette) {
            [
                CommandIDs.search,
                CommandIDs.findNext,
                CommandIDs.findPrevious,
                CommandIDs.end,
                CommandIDs.toggleSearchInSelection
            ].forEach(command => {
                palette.addItem({
                    command,
                    category: trans.__('Main Area')
                });
            });
        }
        // Provide the registry to the system.
        return registry;
    }
};
export default [extension, labShellWidgetListener];
//# sourceMappingURL=index.js.map