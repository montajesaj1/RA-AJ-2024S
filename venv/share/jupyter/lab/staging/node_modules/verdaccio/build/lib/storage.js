"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _assert = _interopRequireDefault(require("assert"));
var _async = _interopRequireDefault(require("async"));
var _lodash = _interopRequireDefault(require("lodash"));
var _stream = _interopRequireDefault(require("stream"));
var _core = require("@verdaccio/core");
var _search = require("@verdaccio/search");
var _streams = require("@verdaccio/streams");
var _logger = require("../lib/logger");
var _configUtils = require("./config-utils");
var _constants = require("./constants");
var _localStorage = _interopRequireDefault(require("./local-storage"));
var _metadataUtils = require("./metadata-utils");
var _storageUtils = require("./storage-utils");
var _upStorage = _interopRequireDefault(require("./up-storage"));
var _uplinkUtil = require("./uplink-util");
var _utils = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
class Storage {
  constructor(config) {
    this.config = config;
    this.uplinks = (0, _uplinkUtil.setupUpLinks)(config);
    this.logger = _logger.logger;
    this.filters = [];
    // @ts-ignore
    this.localStorage = null;
  }
  init(config, filters = []) {
    this.filters = filters;
    this.localStorage = new _localStorage.default(this.config, _logger.logger);
    return this.localStorage.getSecret(config);
  }

  /**
   *  Add a {name} package to a system
   Function checks if package with the same name is available from uplinks.
   If it isn't, we create package locally
   Used storages: local (write) && uplinks
   */
  async addPackage(name, metadata, callback) {
    try {
      await (0, _storageUtils.checkPackageLocal)(name, this.localStorage);
      await (0, _storageUtils.checkPackageRemote)(name, this._isAllowPublishOffline(), this._syncUplinksMetadata.bind(this));
      await (0, _storageUtils.publishPackage)(name, metadata, this.localStorage);
      callback();
    } catch (err) {
      callback(err);
    }
  }
  _isAllowPublishOffline() {
    return typeof this.config.publish !== 'undefined' && _lodash.default.isBoolean(this.config.publish.allow_offline) && this.config.publish.allow_offline;
  }
  readTokens(filter) {
    return this.localStorage.readTokens(filter);
  }
  saveToken(token) {
    return this.localStorage.saveToken(token);
  }
  deleteToken(user, tokenKey) {
    return this.localStorage.deleteToken(user, tokenKey);
  }

  /**
   * Add a new version of package {name} to a system
   Used storages: local (write)
   */
  addVersion(name, version, metadata, tag, callback) {
    this.localStorage.addVersion(name, version, metadata, tag, callback);
  }

  /**
   * Tags a package version with a provided tag
   Used storages: local (write)
   */
  mergeTags(name, tagHash, callback) {
    this.localStorage.mergeTags(name, tagHash, callback);
  }

  /**
   * Change an existing package (i.e. unpublish one version)
   Function changes a package info from local storage and all uplinks with write access./
   Used storages: local (write)
   */
  changePackage(name, metadata, revision, callback) {
    this.localStorage.changePackage(name, metadata, revision, callback);
  }

  /**
   * Remove a package from a system
   Function removes a package from local storage
   Used storages: local (write)
   */
  removePackage(name, callback) {
    this.localStorage.removePackage(name, callback);
    // update the indexer
    _search.SearchMemoryIndexer.remove(name).catch(reason => {
      _logger.logger.error('indexer has failed on remove item');
    });
  }

  /**
   Remove a tarball from a system
   Function removes a tarball from local storage.
   Tarball in question should not be linked to in any existing
   versions, i.e. package version should be unpublished first.
   Used storage: local (write)
   */
  removeTarball(name, filename, revision, callback) {
    this.localStorage.removeTarball(name, filename, revision, callback);
  }

  /**
   * Upload a tarball for {name} package
   Function is synchronous and returns a WritableStream
   Used storages: local (write)
   */
  addTarball(name, filename) {
    return this.localStorage.addTarball(name, filename);
  }
  hasLocalTarball(name, filename) {
    const self = this;
    return new Promise((resolve, reject) => {
      let localStream = self.localStorage.getTarball(name, filename);
      let isOpen = false;
      localStream.on('error', err => {
        if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
          reject(err);
        }
        // local reported 404 or request was aborted already
        if (localStream) {
          localStream.abort();
          localStream = null;
        }
        resolve(false);
      });
      localStream.on('open', function () {
        isOpen = true;
        localStream.abort();
        localStream = null;
        resolve(true);
      });
    });
  }

  /**
   Get a tarball from a storage for {name} package
   Function is synchronous and returns a ReadableStream
   Function tries to read tarball locally, if it fails then it reads package
   information in order to figure out where we can get this tarball from
   Used storages: local || uplink (just one)
   */
  getTarball(name, filename) {
    const readStream = new _streams.ReadTarball({});
    readStream.abort = function () {};
    const self = this;

    // if someone requesting tarball, it means that we should already have some
    // information about it, so fetching package info is unnecessary

    // trying local first
    // flow: should be IReadTarball
    let localStream = self.localStorage.getTarball(name, filename);
    let isOpen = false;
    localStream.on('error', err => {
      if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
        return readStream.emit('error', err);
      }

      // local reported 404
      const err404 = err;
      localStream.abort();
      localStream = null; // we force for garbage collector
      self.localStorage.getPackageMetadata(name, (err, info) => {
        if (_lodash.default.isNil(err) && info._distfiles && _lodash.default.isNil(info._distfiles[filename]) === false) {
          // information about this file exists locally
          serveFile(info._distfiles[filename]);
        } else {
          // we know nothing about this file, trying to get information elsewhere
          self._syncUplinksMetadata(name, info, {}, (err, info) => {
            if (_lodash.default.isNil(err) === false) {
              return readStream.emit('error', err);
            }
            if (_lodash.default.isNil(info._distfiles) || _lodash.default.isNil(info._distfiles[filename])) {
              return readStream.emit('error', err404);
            }
            serveFile(info._distfiles[filename]);
          });
        }
      });
    });
    localStream.on('content-length', function (v) {
      readStream.emit('content-length', v);
    });
    localStream.on('open', function () {
      isOpen = true;
      localStream.pipe(readStream);
    });
    return readStream;

    /**
     * Fetch and cache local/remote packages.
     * @param {Object} file define the package shape
     */
    function serveFile(file) {
      let uplink = null;
      for (const uplinkId in self.uplinks) {
        if ((0, _configUtils.hasProxyTo)(name, uplinkId, self.config.packages)) {
          uplink = self.uplinks[uplinkId];
        }
      }
      if (uplink == null) {
        uplink = new _upStorage.default({
          url: file.url,
          cache: true,
          _autogenerated: true
        }, self.config);
      }
      let savestream = null;
      if (uplink.config.cache) {
        savestream = self.localStorage.addTarball(name, filename);
      }
      let on_open = function () {
        // prevent it from being called twice
        on_open = function () {};
        const rstream2 = uplink.fetchTarball(file.url);
        rstream2.on('error', function (err) {
          if (savestream) {
            savestream.abort();
          }
          savestream = null;
          readStream.emit('error', err);
        });
        rstream2.on('end', function () {
          if (savestream) {
            savestream.done();
          }
        });
        rstream2.on('content-length', function (v) {
          readStream.emit('content-length', v);
          if (savestream) {
            savestream.emit('content-length', v);
          }
        });
        rstream2.pipe(readStream);
        if (savestream) {
          rstream2.pipe(savestream);
        }
      };
      if (savestream) {
        savestream.on('open', function () {
          on_open();
        });
        savestream.on('error', function (err) {
          self.logger.warn({
            err: err,
            fileName: file
          }, 'error saving file @{fileName}: @{err.message}\n@{err.stack}');
          if (savestream) {
            savestream.abort();
          }
          savestream = null;
          on_open();
        });
      } else {
        on_open();
      }
    }
  }

  /**
   Retrieve a package metadata for {name} package
   Function invokes localStorage.getPackage and uplink.get_package for every
   uplink with proxy_access rights against {name} and combines results
   into one json object
   Used storages: local && uplink (proxy_access)
    * @param {object} options
   * @property {string} options.name Package Name
   * @property {object}  options.req Express `req` object
   * @property {boolean} options.keepUpLinkData keep up link info in package meta, last update, etc.
   * @property {function} options.callback Callback for receive data
   */
  getPackage(options) {
    this.localStorage.getPackageMetadata(options.name, (err, data) => {
      if (err && (!err.status || err.status >= _constants.HTTP_STATUS.INTERNAL_ERROR)) {
        // report internal errors right away
        return options.callback(err);
      }
      this._syncUplinksMetadata(options.name, data, {
        req: options.req,
        uplinksLook: options.uplinksLook
      }, function getPackageSynUpLinksCallback(err, result, uplinkErrors) {
        if (err) {
          return options.callback(err);
        }
        (0, _utils.normalizeDistTags)((0, _storageUtils.cleanUpLinksRef)(options.keepUpLinkData, result));

        // npm can throw if this field doesn't exist
        result._attachments = {};
        if (options.abbreviated === true) {
          options.callback(null, (0, _storageUtils.convertAbbreviatedManifest)(result), uplinkErrors);
        } else {
          options.callback(null, result, uplinkErrors);
        }
      });
    });
  }

  /**
   Retrieve remote and local packages more recent than {startkey}
   Function streams all packages from all uplinks first, and then
   local packages.
   Note that local packages could override registry ones just because
   they appear in JSON last. That's a trade-off we make to avoid
   memory issues.
   Used storages: local && uplink (proxy_access)
   * @param {*} startkey
   * @param {*} options
   * @return {Stream}
   */
  search(startkey, options) {
    const self = this;
    const searchStream = new _stream.default.PassThrough({
      objectMode: true
    });
    _async.default.eachSeries(Object.keys(this.uplinks), function (up_name, cb) {
      var _options$req, _options$req$query;
      // shortcut: if `local=1` is supplied, don't call uplinks
      if (((_options$req = options.req) === null || _options$req === void 0 ? void 0 : (_options$req$query = _options$req.query) === null || _options$req$query === void 0 ? void 0 : _options$req$query.local) !== undefined) {
        return cb();
      }
      _logger.logger.info(`search for uplink ${up_name}`);
      // search by keyword for each uplink
      const uplinkStream = self.uplinks[up_name].search(options);
      // join uplink stream with streams PassThrough
      uplinkStream.pipe(searchStream, {
        end: false
      });
      uplinkStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'uplink error: @{err.message}');
        cb();
        // to avoid call callback more than once
        cb = function () {};
      });
      uplinkStream.on('end', function () {
        cb();
        // to avoid call callback more than once
        cb = function () {};
      });
      searchStream.abort = function () {
        if (uplinkStream.abort) {
          uplinkStream.abort();
        }
        cb();
        // to avoid call callback more than once
        cb = function () {};
      };
    },
    // executed after all series
    function () {
      // attach a local search results
      const localSearchStream = self.localStorage.search(startkey, options);
      searchStream.abort = function () {
        localSearchStream.abort();
      };
      localSearchStream.pipe(searchStream, {
        end: true
      });
      localSearchStream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'search error: @{err.message}');
        searchStream.end();
      });
    });
    return searchStream;
  }

  /**
   * Retrieve only private local packages
   * @param {*} callback
   */
  getLocalDatabase(callback) {
    const self = this;
    this.localStorage.storagePlugin.get((err, locals) => {
      if (err) {
        callback(err);
      }
      const packages = [];
      const getPackage = function (itemPkg) {
        self.localStorage.getPackageMetadata(locals[itemPkg], function (err, pkgMetadata) {
          if (_lodash.default.isNil(err)) {
            const latest = pkgMetadata[_constants.DIST_TAGS].latest;
            if (latest && pkgMetadata.versions[latest]) {
              const version = pkgMetadata.versions[latest];
              const timeList = pkgMetadata.time;
              const time = timeList[latest];
              // @ts-ignore
              version.time = time;

              // Add for stars api
              // @ts-ignore
              version.users = pkgMetadata.users;
              packages.push(version);
            } else {
              self.logger.warn({
                package: locals[itemPkg]
              }, 'package @{package} does not have a "latest" tag?');
            }
          }
          if (itemPkg >= locals.length - 1) {
            callback(null, packages);
          } else {
            getPackage(itemPkg + 1);
          }
        });
      };
      if (locals.length) {
        getPackage(0);
      } else {
        callback(null, []);
      }
    });
  }

  /**
   * Function fetches package metadata from uplinks and synchronizes it with local data
   if package is available locally, it MUST be provided in pkginfo
   returns callback(err, result, uplink_errors)
   */
  _syncUplinksMetadata(name, packageInfo, options, callback) {
    let found = true;
    const self = this;
    const upLinks = [];
    const hasToLookIntoUplinks = _lodash.default.isNil(options.uplinksLook) || options.uplinksLook;
    if (!packageInfo) {
      found = false;
      packageInfo = (0, _storageUtils.generatePackageTemplate)(name);
    }
    for (const uplink in this.uplinks) {
      if ((0, _configUtils.hasProxyTo)(name, uplink, this.config.packages) && hasToLookIntoUplinks) {
        upLinks.push(this.uplinks[uplink]);
      }
    }
    _async.default.map(upLinks, (upLink, cb) => {
      const _options = Object.assign({}, options);
      const upLinkMeta = packageInfo._uplinks[upLink.upname];
      if ((0, _utils.isObject)(upLinkMeta)) {
        const fetched = upLinkMeta.fetched;
        if (fetched && Date.now() - fetched < upLink.maxage) {
          return cb();
        }
        _options.etag = upLinkMeta.etag;
      }
      upLink.getRemoteMetadata(name, _options, (err, upLinkResponse, eTag) => {
        if (err && err.remoteStatus === 304) {
          upLinkMeta.fetched = Date.now();
        }
        if (err || !upLinkResponse) {
          return cb(null, [err || _utils.ErrorCode.getInternalError('no data')]);
        }
        try {
          upLinkResponse = _core.validatioUtils.normalizeMetadata(upLinkResponse, name);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json validating error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }
        packageInfo._uplinks[upLink.upname] = {
          etag: eTag,
          fetched: Date.now()
        };
        packageInfo = (0, _storageUtils.mergeUplinkTimeIntoLocal)(packageInfo, upLinkResponse);
        (0, _uplinkUtil.updateVersionsHiddenUpLink)(upLinkResponse.versions, upLink);
        try {
          (0, _metadataUtils.mergeVersions)(packageInfo, upLinkResponse);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json parsing error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }

        // if we got to this point, assume that the correct package exists
        // on the uplink
        found = true;
        cb();
      });
    },
    // @ts-ignore
    (err, upLinksErrors) => {
      (0, _assert.default)(!err && Array.isArray(upLinksErrors));

      // Check for connection timeout or reset errors with uplink(s)
      // (these should be handled differently from the package not being found)
      if (!found) {
        let uplinkTimeoutError;
        for (let i = 0; i < upLinksErrors.length; i++) {
          if (upLinksErrors[i]) {
            for (let j = 0; j < upLinksErrors[i].length; j++) {
              if (upLinksErrors[i][j]) {
                const code = upLinksErrors[i][j].code;
                if (code === 'ETIMEDOUT' || code === 'ESOCKETTIMEDOUT' || code === 'ECONNRESET') {
                  uplinkTimeoutError = true;
                  break;
                }
              }
            }
          }
        }
        if (uplinkTimeoutError) {
          return callback(_utils.ErrorCode.getServiceUnavailable(), null, upLinksErrors);
        }
        return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NO_PACKAGE), null, upLinksErrors);
      }
      if (upLinks.length === 0) {
        return callback(null, packageInfo);
      }
      self.localStorage.updateVersions(name, packageInfo, async (err, packageJsonLocal) => {
        if (err) {
          return callback(err);
        }
        // Any error here will cause a 404, like an uplink error. This is likely the right thing to do
        // as a broken filter is a security risk.
        const filterErrors = [];
        // This MUST be done serially and not in parallel as they modify packageJsonLocal
        for (const filter of self.filters) {
          try {
            // These filters can assume it's save to modify packageJsonLocal and return it directly for
            // performance (i.e. need not be pure)
            packageJsonLocal = await filter.filter_metadata(packageJsonLocal);
          } catch (err) {
            filterErrors.push(err);
          }
        }
        callback(null, packageJsonLocal, _lodash.default.concat(upLinksErrors, filterErrors));
      });
    });
  }

  /**
   * Set a hidden value for each version.
   * @param {Array} versions list of version
   * @param {String} upLink uplink name
   * @private
   */
  _updateVersionsHiddenUpLink(versions, upLink) {
    for (const i in versions) {
      if (Object.prototype.hasOwnProperty.call(versions, i)) {
        const version = versions[i];

        // holds a "hidden" value to be used by the package storage.
        version[Symbol.for('__verdaccio_uplink')] = upLink.upname;
      }
    }
  }
}
var _default = Storage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYXNzZXJ0IiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsInJlcXVpcmUiLCJfYXN5bmMiLCJfbG9kYXNoIiwiX3N0cmVhbSIsIl9jb3JlIiwiX3NlYXJjaCIsIl9zdHJlYW1zIiwiX2xvZ2dlciIsIl9jb25maWdVdGlscyIsIl9jb25zdGFudHMiLCJfbG9jYWxTdG9yYWdlIiwiX21ldGFkYXRhVXRpbHMiLCJfc3RvcmFnZVV0aWxzIiwiX3VwU3RvcmFnZSIsIl91cGxpbmtVdGlsIiwiX3V0aWxzIiwib2JqIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJ1cGxpbmtzIiwic2V0dXBVcExpbmtzIiwibG9nZ2VyIiwiZmlsdGVycyIsImxvY2FsU3RvcmFnZSIsImluaXQiLCJMb2NhbFN0b3JhZ2UiLCJnZXRTZWNyZXQiLCJhZGRQYWNrYWdlIiwibmFtZSIsIm1ldGFkYXRhIiwiY2FsbGJhY2siLCJjaGVja1BhY2thZ2VMb2NhbCIsImNoZWNrUGFja2FnZVJlbW90ZSIsIl9pc0FsbG93UHVibGlzaE9mZmxpbmUiLCJfc3luY1VwbGlua3NNZXRhZGF0YSIsImJpbmQiLCJwdWJsaXNoUGFja2FnZSIsImVyciIsInB1Ymxpc2giLCJfIiwiaXNCb29sZWFuIiwiYWxsb3dfb2ZmbGluZSIsInJlYWRUb2tlbnMiLCJmaWx0ZXIiLCJzYXZlVG9rZW4iLCJ0b2tlbiIsImRlbGV0ZVRva2VuIiwidXNlciIsInRva2VuS2V5IiwiYWRkVmVyc2lvbiIsInZlcnNpb24iLCJ0YWciLCJtZXJnZVRhZ3MiLCJ0YWdIYXNoIiwiY2hhbmdlUGFja2FnZSIsInJldmlzaW9uIiwicmVtb3ZlUGFja2FnZSIsIlNlYXJjaE1lbW9yeUluZGV4ZXIiLCJyZW1vdmUiLCJjYXRjaCIsInJlYXNvbiIsImVycm9yIiwicmVtb3ZlVGFyYmFsbCIsImZpbGVuYW1lIiwiYWRkVGFyYmFsbCIsImhhc0xvY2FsVGFyYmFsbCIsInNlbGYiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImxvY2FsU3RyZWFtIiwiZ2V0VGFyYmFsbCIsImlzT3BlbiIsIm9uIiwic3RhdHVzIiwiSFRUUF9TVEFUVVMiLCJOT1RfRk9VTkQiLCJhYm9ydCIsInJlYWRTdHJlYW0iLCJSZWFkVGFyYmFsbCIsImVtaXQiLCJlcnI0MDQiLCJnZXRQYWNrYWdlTWV0YWRhdGEiLCJpbmZvIiwiaXNOaWwiLCJfZGlzdGZpbGVzIiwic2VydmVGaWxlIiwidiIsInBpcGUiLCJmaWxlIiwidXBsaW5rIiwidXBsaW5rSWQiLCJoYXNQcm94eVRvIiwicGFja2FnZXMiLCJQcm94eVN0b3JhZ2UiLCJ1cmwiLCJjYWNoZSIsIl9hdXRvZ2VuZXJhdGVkIiwic2F2ZXN0cmVhbSIsIm9uX29wZW4iLCJyc3RyZWFtMiIsImZldGNoVGFyYmFsbCIsImRvbmUiLCJ3YXJuIiwiZmlsZU5hbWUiLCJnZXRQYWNrYWdlIiwib3B0aW9ucyIsImRhdGEiLCJJTlRFUk5BTF9FUlJPUiIsInJlcSIsInVwbGlua3NMb29rIiwiZ2V0UGFja2FnZVN5blVwTGlua3NDYWxsYmFjayIsInJlc3VsdCIsInVwbGlua0Vycm9ycyIsIm5vcm1hbGl6ZURpc3RUYWdzIiwiY2xlYW5VcExpbmtzUmVmIiwia2VlcFVwTGlua0RhdGEiLCJfYXR0YWNobWVudHMiLCJhYmJyZXZpYXRlZCIsImNvbnZlcnRBYmJyZXZpYXRlZE1hbmlmZXN0Iiwic2VhcmNoIiwic3RhcnRrZXkiLCJzZWFyY2hTdHJlYW0iLCJTdHJlYW0iLCJQYXNzVGhyb3VnaCIsIm9iamVjdE1vZGUiLCJhc3luYyIsImVhY2hTZXJpZXMiLCJPYmplY3QiLCJrZXlzIiwidXBfbmFtZSIsImNiIiwiX29wdGlvbnMkcmVxIiwiX29wdGlvbnMkcmVxJHF1ZXJ5IiwicXVlcnkiLCJsb2NhbCIsInVuZGVmaW5lZCIsInVwbGlua1N0cmVhbSIsImVuZCIsImxvY2FsU2VhcmNoU3RyZWFtIiwiZ2V0TG9jYWxEYXRhYmFzZSIsInN0b3JhZ2VQbHVnaW4iLCJnZXQiLCJsb2NhbHMiLCJpdGVtUGtnIiwicGtnTWV0YWRhdGEiLCJsYXRlc3QiLCJESVNUX1RBR1MiLCJ2ZXJzaW9ucyIsInRpbWVMaXN0IiwidGltZSIsInVzZXJzIiwicHVzaCIsInBhY2thZ2UiLCJsZW5ndGgiLCJwYWNrYWdlSW5mbyIsImZvdW5kIiwidXBMaW5rcyIsImhhc1RvTG9va0ludG9VcGxpbmtzIiwiZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUiLCJtYXAiLCJ1cExpbmsiLCJfb3B0aW9ucyIsImFzc2lnbiIsInVwTGlua01ldGEiLCJfdXBsaW5rcyIsInVwbmFtZSIsImlzT2JqZWN0IiwiZmV0Y2hlZCIsIkRhdGUiLCJub3ciLCJtYXhhZ2UiLCJldGFnIiwiZ2V0UmVtb3RlTWV0YWRhdGEiLCJ1cExpbmtSZXNwb25zZSIsImVUYWciLCJyZW1vdGVTdGF0dXMiLCJFcnJvckNvZGUiLCJnZXRJbnRlcm5hbEVycm9yIiwidmFsaWRhdGlvVXRpbHMiLCJub3JtYWxpemVNZXRhZGF0YSIsInN1YiIsIm1lcmdlVXBsaW5rVGltZUludG9Mb2NhbCIsInVwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rIiwibWVyZ2VWZXJzaW9ucyIsInVwTGlua3NFcnJvcnMiLCJhc3NlcnQiLCJBcnJheSIsImlzQXJyYXkiLCJ1cGxpbmtUaW1lb3V0RXJyb3IiLCJpIiwiaiIsImNvZGUiLCJnZXRTZXJ2aWNlVW5hdmFpbGFibGUiLCJnZXROb3RGb3VuZCIsIkFQSV9FUlJPUiIsIk5PX1BBQ0tBR0UiLCJ1cGRhdGVWZXJzaW9ucyIsInBhY2thZ2VKc29uTG9jYWwiLCJmaWx0ZXJFcnJvcnMiLCJmaWx0ZXJfbWV0YWRhdGEiLCJjb25jYXQiLCJfdXBkYXRlVmVyc2lvbnNIaWRkZW5VcExpbmsiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJTeW1ib2wiLCJmb3IiLCJfZGVmYXVsdCIsImV4cG9ydHMiXSwic291cmNlcyI6WyIuLi8uLi9zcmMvbGliL3N0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IGFzeW5jLCB7IEFzeW5jUmVzdWx0QXJyYXlDYWxsYmFjayB9IGZyb20gJ2FzeW5jJztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5cbmltcG9ydCB7IHZhbGlkYXRpb1V0aWxzIH0gZnJvbSAnQHZlcmRhY2Npby9jb3JlJztcbmltcG9ydCB7IFNlYXJjaE1lbW9yeUluZGV4ZXIgfSBmcm9tICdAdmVyZGFjY2lvL3NlYXJjaCc7XG5pbXBvcnQgeyBSZWFkVGFyYmFsbCB9IGZyb20gJ0B2ZXJkYWNjaW8vc3RyZWFtcyc7XG5pbXBvcnQge1xuICBDYWxsYmFjayxcbiAgQ29uZmlnLFxuICBEaXN0RmlsZSxcbiAgTG9nZ2VyLFxuICBNYW5pZmVzdCxcbiAgTWVyZ2VUYWdzLFxuICBQYWNrYWdlLFxuICBWZXJzaW9uLFxuICBWZXJzaW9ucyxcbn0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBHZW5lcmljQm9keSwgVG9rZW4sIFRva2VuRmlsdGVyIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5cbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgSVBsdWdpbkZpbHRlcnMsIElTeW5jVXBsaW5rcywgU3RyaW5nVmFsdWUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBoYXNQcm94eVRvIH0gZnJvbSAnLi9jb25maWctdXRpbHMnO1xuaW1wb3J0IHsgQVBJX0VSUk9SLCBESVNUX1RBR1MsIEhUVFBfU1RBVFVTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IExvY2FsU3RvcmFnZSBmcm9tICcuL2xvY2FsLXN0b3JhZ2UnO1xuaW1wb3J0IHsgbWVyZ2VWZXJzaW9ucyB9IGZyb20gJy4vbWV0YWRhdGEtdXRpbHMnO1xuaW1wb3J0IHtcbiAgY2hlY2tQYWNrYWdlTG9jYWwsXG4gIGNoZWNrUGFja2FnZVJlbW90ZSxcbiAgY2xlYW5VcExpbmtzUmVmLFxuICBjb252ZXJ0QWJicmV2aWF0ZWRNYW5pZmVzdCxcbiAgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUsXG4gIG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbCxcbiAgcHVibGlzaFBhY2thZ2UsXG59IGZyb20gJy4vc3RvcmFnZS11dGlscyc7XG5pbXBvcnQgUHJveHlTdG9yYWdlIGZyb20gJy4vdXAtc3RvcmFnZSc7XG5pbXBvcnQgeyBzZXR1cFVwTGlua3MsIHVwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rIH0gZnJvbSAnLi91cGxpbmstdXRpbCc7XG5pbXBvcnQgeyBFcnJvckNvZGUsIGlzT2JqZWN0LCBub3JtYWxpemVEaXN0VGFncyB9IGZyb20gJy4vdXRpbHMnO1xuXG5jbGFzcyBTdG9yYWdlIHtcbiAgcHVibGljIGxvY2FsU3RvcmFnZTogTG9jYWxTdG9yYWdlO1xuICBwdWJsaWMgY29uZmlnOiBDb25maWc7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcbiAgcHVibGljIHVwbGlua3M6IFJlY29yZDxzdHJpbmcsIFByb3h5U3RvcmFnZT47XG4gIHB1YmxpYyBmaWx0ZXJzOiBJUGx1Z2luRmlsdGVycztcblxuICBwdWJsaWMgY29uc3RydWN0b3IoY29uZmlnOiBDb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnVwbGlua3MgPSBzZXR1cFVwTGlua3MoY29uZmlnKTtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBudWxsO1xuICB9XG5cbiAgcHVibGljIGluaXQoY29uZmlnOiBDb25maWcsIGZpbHRlcnM6IElQbHVnaW5GaWx0ZXJzID0gW10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UgPSBuZXcgTG9jYWxTdG9yYWdlKHRoaXMuY29uZmlnLCBsb2dnZXIpO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLmdldFNlY3JldChjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqICBBZGQgYSB7bmFtZX0gcGFja2FnZSB0byBhIHN5c3RlbVxuICAgRnVuY3Rpb24gY2hlY2tzIGlmIHBhY2thZ2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGF2YWlsYWJsZSBmcm9tIHVwbGlua3MuXG4gICBJZiBpdCBpc24ndCwgd2UgY3JlYXRlIHBhY2thZ2UgbG9jYWxseVxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKSAmJiB1cGxpbmtzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShuYW1lOiBzdHJpbmcsIG1ldGFkYXRhOiBhbnksIGNhbGxiYWNrOiBGdW5jdGlvbik6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjaGVja1BhY2thZ2VMb2NhbChuYW1lLCB0aGlzLmxvY2FsU3RvcmFnZSk7XG4gICAgICBhd2FpdCBjaGVja1BhY2thZ2VSZW1vdGUoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHRoaXMuX2lzQWxsb3dQdWJsaXNoT2ZmbGluZSgpLFxuICAgICAgICB0aGlzLl9zeW5jVXBsaW5rc01ldGFkYXRhLmJpbmQodGhpcylcbiAgICAgICk7XG4gICAgICBhd2FpdCBwdWJsaXNoUGFja2FnZShuYW1lLCBtZXRhZGF0YSwgdGhpcy5sb2NhbFN0b3JhZ2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pc0FsbG93UHVibGlzaE9mZmxpbmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiB0aGlzLmNvbmZpZy5wdWJsaXNoICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgXy5pc0Jvb2xlYW4odGhpcy5jb25maWcucHVibGlzaC5hbGxvd19vZmZsaW5lKSAmJlxuICAgICAgdGhpcy5jb25maWcucHVibGlzaC5hbGxvd19vZmZsaW5lXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkVG9rZW5zKGZpbHRlcjogVG9rZW5GaWx0ZXIpOiBQcm9taXNlPFRva2VuW10+IHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UucmVhZFRva2VucyhmaWx0ZXIpO1xuICB9XG5cbiAgcHVibGljIHNhdmVUb2tlbih0b2tlbjogVG9rZW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2Uuc2F2ZVRva2VuKHRva2VuKTtcbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVUb2tlbih1c2VyOiBzdHJpbmcsIHRva2VuS2V5OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmFnZS5kZWxldGVUb2tlbih1c2VyLCB0b2tlbktleSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgbmV3IHZlcnNpb24gb2YgcGFja2FnZSB7bmFtZX0gdG8gYSBzeXN0ZW1cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSlcbiAgICovXG4gIHB1YmxpYyBhZGRWZXJzaW9uKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgbWV0YWRhdGE6IFZlcnNpb24sXG4gICAgdGFnOiBTdHJpbmdWYWx1ZSxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UuYWRkVmVyc2lvbihuYW1lLCB2ZXJzaW9uLCBtZXRhZGF0YSwgdGFnLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVGFncyBhIHBhY2thZ2UgdmVyc2lvbiB3aXRoIGEgcHJvdmlkZWQgdGFnXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgbWVyZ2VUYWdzKG5hbWU6IHN0cmluZywgdGFnSGFzaDogTWVyZ2VUYWdzLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5tZXJnZVRhZ3MobmFtZSwgdGFnSGFzaCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSBhbiBleGlzdGluZyBwYWNrYWdlIChpLmUuIHVucHVibGlzaCBvbmUgdmVyc2lvbilcbiAgIEZ1bmN0aW9uIGNoYW5nZXMgYSBwYWNrYWdlIGluZm8gZnJvbSBsb2NhbCBzdG9yYWdlIGFuZCBhbGwgdXBsaW5rcyB3aXRoIHdyaXRlIGFjY2Vzcy4vXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgY2hhbmdlUGFja2FnZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgbWV0YWRhdGE6IFBhY2thZ2UsXG4gICAgcmV2aXNpb246IHN0cmluZyxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UuY2hhbmdlUGFja2FnZShuYW1lLCBtZXRhZGF0YSwgcmV2aXNpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwYWNrYWdlIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSBwYWNrYWdlIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIHJlbW92ZVBhY2thZ2UobmFtZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVQYWNrYWdlKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAvLyB1cGRhdGUgdGhlIGluZGV4ZXJcbiAgICBTZWFyY2hNZW1vcnlJbmRleGVyLnJlbW92ZShuYW1lKS5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ2luZGV4ZXIgaGFzIGZhaWxlZCBvbiByZW1vdmUgaXRlbScpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICBSZW1vdmUgYSB0YXJiYWxsIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSB0YXJiYWxsIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgIFRhcmJhbGwgaW4gcXVlc3Rpb24gc2hvdWxkIG5vdCBiZSBsaW5rZWQgdG8gaW4gYW55IGV4aXN0aW5nXG4gICB2ZXJzaW9ucywgaS5lLiBwYWNrYWdlIHZlcnNpb24gc2hvdWxkIGJlIHVucHVibGlzaGVkIGZpcnN0LlxuICAgVXNlZCBzdG9yYWdlOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlVGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIHJldmlzaW9uOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZVRhcmJhbGwobmFtZSwgZmlsZW5hbWUsIHJldmlzaW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgdGFyYmFsbCBmb3Ige25hbWV9IHBhY2thZ2VcbiAgIEZ1bmN0aW9uIGlzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5zIGEgV3JpdGFibGVTdHJlYW1cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSlcbiAgICovXG4gIHB1YmxpYyBhZGRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmFnZS5hZGRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyBoYXNMb2NhbFRhcmJhbGwobmFtZTogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcbiAgICAgIGxldCBsb2NhbFN0cmVhbTogYW55ID0gc2VsZi5sb2NhbFN0b3JhZ2UuZ2V0VGFyYmFsbChuYW1lLCBmaWxlbmFtZSk7XG4gICAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG4gICAgICBsb2NhbFN0cmVhbS5vbignZXJyb3InLCAoZXJyKTogYW55ID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiB8fCBlcnIuc3RhdHVzICE9PSBIVFRQX1NUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2NhbCByZXBvcnRlZCA0MDQgb3IgcmVxdWVzdCB3YXMgYWJvcnRlZCBhbHJlYWR5XG4gICAgICAgIGlmIChsb2NhbFN0cmVhbSkge1xuICAgICAgICAgIGxvY2FsU3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgbG9jYWxTdHJlYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBsb2NhbFN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgbG9jYWxTdHJlYW0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgIEdldCBhIHRhcmJhbGwgZnJvbSBhIHN0b3JhZ2UgZm9yIHtuYW1lfSBwYWNrYWdlXG4gICBGdW5jdGlvbiBpcyBzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIFJlYWRhYmxlU3RyZWFtXG4gICBGdW5jdGlvbiB0cmllcyB0byByZWFkIHRhcmJhbGwgbG9jYWxseSwgaWYgaXQgZmFpbHMgdGhlbiBpdCByZWFkcyBwYWNrYWdlXG4gICBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBmaWd1cmUgb3V0IHdoZXJlIHdlIGNhbiBnZXQgdGhpcyB0YXJiYWxsIGZyb21cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsIHx8IHVwbGluayAoanVzdCBvbmUpXG4gICAqL1xuICBwdWJsaWMgZ2V0VGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWFkU3RyZWFtID0gbmV3IFJlYWRUYXJiYWxsKHt9KTtcbiAgICByZWFkU3RyZWFtLmFib3J0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGlmIHNvbWVvbmUgcmVxdWVzdGluZyB0YXJiYWxsLCBpdCBtZWFucyB0aGF0IHdlIHNob3VsZCBhbHJlYWR5IGhhdmUgc29tZVxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IGl0LCBzbyBmZXRjaGluZyBwYWNrYWdlIGluZm8gaXMgdW5uZWNlc3NhcnlcblxuICAgIC8vIHRyeWluZyBsb2NhbCBmaXJzdFxuICAgIC8vIGZsb3c6IHNob3VsZCBiZSBJUmVhZFRhcmJhbGxcbiAgICBsZXQgbG9jYWxTdHJlYW06IGFueSA9IHNlbGYubG9jYWxTdG9yYWdlLmdldFRhcmJhbGwobmFtZSwgZmlsZW5hbWUpO1xuICAgIGxldCBpc09wZW4gPSBmYWxzZTtcbiAgICBsb2NhbFN0cmVhbS5vbignZXJyb3InLCAoZXJyKTogYW55ID0+IHtcbiAgICAgIGlmIChpc09wZW4gfHwgZXJyLnN0YXR1cyAhPT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gbG9jYWwgcmVwb3J0ZWQgNDA0XG4gICAgICBjb25zdCBlcnI0MDQgPSBlcnI7XG4gICAgICBsb2NhbFN0cmVhbS5hYm9ydCgpO1xuICAgICAgbG9jYWxTdHJlYW0gPSBudWxsOyAvLyB3ZSBmb3JjZSBmb3IgZ2FyYmFnZSBjb2xsZWN0b3JcbiAgICAgIHNlbGYubG9jYWxTdG9yYWdlLmdldFBhY2thZ2VNZXRhZGF0YShuYW1lLCAoZXJyLCBpbmZvOiBQYWNrYWdlKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChfLmlzTmlsKGVycikgJiYgaW5mby5fZGlzdGZpbGVzICYmIF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBmaWxlIGV4aXN0cyBsb2NhbGx5XG4gICAgICAgICAgc2VydmVGaWxlKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIGtub3cgbm90aGluZyBhYm91dCB0aGlzIGZpbGUsIHRyeWluZyB0byBnZXQgaW5mb3JtYXRpb24gZWxzZXdoZXJlXG4gICAgICAgICAgc2VsZi5fc3luY1VwbGlua3NNZXRhZGF0YShuYW1lLCBpbmZvLCB7fSwgKGVyciwgaW5mbzogUGFja2FnZSk6IGFueSA9PiB7XG4gICAgICAgICAgICBpZiAoXy5pc05pbChlcnIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5pc05pbChpbmZvLl9kaXN0ZmlsZXMpIHx8IF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzW2ZpbGVuYW1lXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnI0MDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VydmVGaWxlKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBsb2NhbFN0cmVhbS5vbignY29udGVudC1sZW5ndGgnLCBmdW5jdGlvbiAodik6IHZvaWQge1xuICAgICAgcmVhZFN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgIH0pO1xuICAgIGxvY2FsU3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgaXNPcGVuID0gdHJ1ZTtcbiAgICAgIGxvY2FsU3RyZWFtLnBpcGUocmVhZFN0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlYWRTdHJlYW07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbmQgY2FjaGUgbG9jYWwvcmVtb3RlIHBhY2thZ2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlIGRlZmluZSB0aGUgcGFja2FnZSBzaGFwZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlcnZlRmlsZShmaWxlOiBEaXN0RmlsZSk6IHZvaWQge1xuICAgICAgbGV0IHVwbGluazogYW55ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCB1cGxpbmtJZCBpbiBzZWxmLnVwbGlua3MpIHtcbiAgICAgICAgaWYgKGhhc1Byb3h5VG8obmFtZSwgdXBsaW5rSWQsIHNlbGYuY29uZmlnLnBhY2thZ2VzKSkge1xuICAgICAgICAgIHVwbGluayA9IHNlbGYudXBsaW5rc1t1cGxpbmtJZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVwbGluayA9PSBudWxsKSB7XG4gICAgICAgIHVwbGluayA9IG5ldyBQcm94eVN0b3JhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBmaWxlLnVybCxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgX2F1dG9nZW5lcmF0ZWQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxmLmNvbmZpZ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2F2ZXN0cmVhbTogYW55ID0gbnVsbDtcbiAgICAgIGlmICh1cGxpbmsuY29uZmlnLmNhY2hlKSB7XG4gICAgICAgIHNhdmVzdHJlYW0gPSBzZWxmLmxvY2FsU3RvcmFnZS5hZGRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG9uX29wZW4gPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIC8vIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjYWxsZWQgdHdpY2VcbiAgICAgICAgb25fb3BlbiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBjb25zdCByc3RyZWFtMiA9IHVwbGluay5mZXRjaFRhcmJhbGwoZmlsZS51cmwpO1xuICAgICAgICByc3RyZWFtMi5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F2ZXN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByc3RyZWFtMi5vbignZW5kJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJzdHJlYW0yLm9uKCdjb250ZW50LWxlbmd0aCcsIGZ1bmN0aW9uICh2KTogdm9pZCB7XG4gICAgICAgICAgcmVhZFN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgICBzYXZlc3RyZWFtLmVtaXQoJ2NvbnRlbnQtbGVuZ3RoJywgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnN0cmVhbTIucGlwZShyZWFkU3RyZWFtKTtcbiAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICByc3RyZWFtMi5waXBlKHNhdmVzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICBzYXZlc3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAgIG9uX29wZW4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2F2ZXN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIud2FybihcbiAgICAgICAgICAgIHsgZXJyOiBlcnIsIGZpbGVOYW1lOiBmaWxlIH0sXG4gICAgICAgICAgICAnZXJyb3Igc2F2aW5nIGZpbGUgQHtmaWxlTmFtZX06IEB7ZXJyLm1lc3NhZ2V9XFxuQHtlcnIuc3RhY2t9J1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F2ZXN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgb25fb3BlbigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uX29wZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgIFJldHJpZXZlIGEgcGFja2FnZSBtZXRhZGF0YSBmb3Ige25hbWV9IHBhY2thZ2VcbiAgIEZ1bmN0aW9uIGludm9rZXMgbG9jYWxTdG9yYWdlLmdldFBhY2thZ2UgYW5kIHVwbGluay5nZXRfcGFja2FnZSBmb3IgZXZlcnlcbiAgIHVwbGluayB3aXRoIHByb3h5X2FjY2VzcyByaWdodHMgYWdhaW5zdCB7bmFtZX0gYW5kIGNvbWJpbmVzIHJlc3VsdHNcbiAgIGludG8gb25lIGpzb24gb2JqZWN0XG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAmJiB1cGxpbmsgKHByb3h5X2FjY2VzcylcblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gb3B0aW9ucy5uYW1lIFBhY2thZ2UgTmFtZVxuICAgKiBAcHJvcGVydHkge29iamVjdH0gIG9wdGlvbnMucmVxIEV4cHJlc3MgYHJlcWAgb2JqZWN0XG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb3B0aW9ucy5rZWVwVXBMaW5rRGF0YSBrZWVwIHVwIGxpbmsgaW5mbyBpbiBwYWNrYWdlIG1ldGEsIGxhc3QgdXBkYXRlLCBldGMuXG4gICAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9wdGlvbnMuY2FsbGJhY2sgQ2FsbGJhY2sgZm9yIHJlY2VpdmUgZGF0YVxuICAgKi9cbiAgcHVibGljIGdldFBhY2thZ2Uob3B0aW9ucyk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLmdldFBhY2thZ2VNZXRhZGF0YShvcHRpb25zLm5hbWUsIChlcnIsIGRhdGEpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIgJiYgKCFlcnIuc3RhdHVzIHx8IGVyci5zdGF0dXMgPj0gSFRUUF9TVEFUVVMuSU5URVJOQUxfRVJST1IpKSB7XG4gICAgICAgIC8vIHJlcG9ydCBpbnRlcm5hbCBlcnJvcnMgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zeW5jVXBsaW5rc01ldGFkYXRhKFxuICAgICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHsgcmVxOiBvcHRpb25zLnJlcSwgdXBsaW5rc0xvb2s6IG9wdGlvbnMudXBsaW5rc0xvb2sgfSxcbiAgICAgICAgZnVuY3Rpb24gZ2V0UGFja2FnZVN5blVwTGlua3NDYWxsYmFjayhlcnIsIHJlc3VsdDogUGFja2FnZSwgdXBsaW5rRXJyb3JzKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3JtYWxpemVEaXN0VGFncyhjbGVhblVwTGlua3NSZWYob3B0aW9ucy5rZWVwVXBMaW5rRGF0YSwgcmVzdWx0KSk7XG5cbiAgICAgICAgICAvLyBucG0gY2FuIHRocm93IGlmIHRoaXMgZmllbGQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHJlc3VsdC5fYXR0YWNobWVudHMgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hYmJyZXZpYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCBjb252ZXJ0QWJicmV2aWF0ZWRNYW5pZmVzdChyZXN1bHQpLCB1cGxpbmtFcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIHJlc3VsdCwgdXBsaW5rRXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgIFJldHJpZXZlIHJlbW90ZSBhbmQgbG9jYWwgcGFja2FnZXMgbW9yZSByZWNlbnQgdGhhbiB7c3RhcnRrZXl9XG4gICBGdW5jdGlvbiBzdHJlYW1zIGFsbCBwYWNrYWdlcyBmcm9tIGFsbCB1cGxpbmtzIGZpcnN0LCBhbmQgdGhlblxuICAgbG9jYWwgcGFja2FnZXMuXG4gICBOb3RlIHRoYXQgbG9jYWwgcGFja2FnZXMgY291bGQgb3ZlcnJpZGUgcmVnaXN0cnkgb25lcyBqdXN0IGJlY2F1c2VcbiAgIHRoZXkgYXBwZWFyIGluIEpTT04gbGFzdC4gVGhhdCdzIGEgdHJhZGUtb2ZmIHdlIG1ha2UgdG8gYXZvaWRcbiAgIG1lbW9yeSBpc3N1ZXMuXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAmJiB1cGxpbmsgKHByb3h5X2FjY2VzcylcbiAgICogQHBhcmFtIHsqfSBzdGFydGtleVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnNcbiAgICogQHJldHVybiB7U3RyZWFtfVxuICAgKi9cbiAgcHVibGljIHNlYXJjaChzdGFydGtleTogc3RyaW5nLCBvcHRpb25zOiBhbnkpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBzZWFyY2hTdHJlYW06IGFueSA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgIGFzeW5jLmVhY2hTZXJpZXMoXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnVwbGlua3MpLFxuICAgICAgZnVuY3Rpb24gKHVwX25hbWUsIGNiKTogdm9pZCB7XG4gICAgICAgIC8vIHNob3J0Y3V0OiBpZiBgbG9jYWw9MWAgaXMgc3VwcGxpZWQsIGRvbid0IGNhbGwgdXBsaW5rc1xuICAgICAgICBpZiAob3B0aW9ucy5yZXE/LnF1ZXJ5Py5sb2NhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmluZm8oYHNlYXJjaCBmb3IgdXBsaW5rICR7dXBfbmFtZX1gKTtcbiAgICAgICAgLy8gc2VhcmNoIGJ5IGtleXdvcmQgZm9yIGVhY2ggdXBsaW5rXG4gICAgICAgIGNvbnN0IHVwbGlua1N0cmVhbSA9IHNlbGYudXBsaW5rc1t1cF9uYW1lXS5zZWFyY2gob3B0aW9ucyk7XG4gICAgICAgIC8vIGpvaW4gdXBsaW5rIHN0cmVhbSB3aXRoIHN0cmVhbXMgUGFzc1Rocm91Z2hcbiAgICAgICAgdXBsaW5rU3RyZWFtLnBpcGUoc2VhcmNoU3RyZWFtLCB7IGVuZDogZmFsc2UgfSk7XG4gICAgICAgIHVwbGlua1N0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKTogdm9pZCB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoeyBlcnI6IGVyciB9LCAndXBsaW5rIGVycm9yOiBAe2Vyci5tZXNzYWdlfScpO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgY2FsbCBjYWxsYmFjayBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGNiID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgICAgIH0pO1xuICAgICAgICB1cGxpbmtTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIC8vIHRvIGF2b2lkIGNhbGwgY2FsbGJhY2sgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgICB9KTtcblxuICAgICAgICBzZWFyY2hTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHVwbGlua1N0cmVhbS5hYm9ydCkge1xuICAgICAgICAgICAgdXBsaW5rU3RyZWFtLmFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgLy8gdG8gYXZvaWQgY2FsbCBjYWxsYmFjayBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgIGNiID0gZnVuY3Rpb24gKCk6IHZvaWQge307XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gZXhlY3V0ZWQgYWZ0ZXIgYWxsIHNlcmllc1xuICAgICAgZnVuY3Rpb24gKCk6IHZvaWQge1xuICAgICAgICAvLyBhdHRhY2ggYSBsb2NhbCBzZWFyY2ggcmVzdWx0c1xuICAgICAgICBjb25zdCBsb2NhbFNlYXJjaFN0cmVhbSA9IHNlbGYubG9jYWxTdG9yYWdlLnNlYXJjaChzdGFydGtleSwgb3B0aW9ucyk7XG4gICAgICAgIHNlYXJjaFN0cmVhbS5hYm9ydCA9IGZ1bmN0aW9uICgpOiB2b2lkIHtcbiAgICAgICAgICBsb2NhbFNlYXJjaFN0cmVhbS5hYm9ydCgpO1xuICAgICAgICB9O1xuICAgICAgICBsb2NhbFNlYXJjaFN0cmVhbS5waXBlKHNlYXJjaFN0cmVhbSwgeyBlbmQ6IHRydWUgfSk7XG4gICAgICAgIGxvY2FsU2VhcmNoU3RyZWFtLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnI6IGFueSk6IHZvaWQge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKHsgZXJyOiBlcnIgfSwgJ3NlYXJjaCBlcnJvcjogQHtlcnIubWVzc2FnZX0nKTtcbiAgICAgICAgICBzZWFyY2hTdHJlYW0uZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gc2VhcmNoU3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIG9ubHkgcHJpdmF0ZSBsb2NhbCBwYWNrYWdlc1xuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9jYWxEYXRhYmFzZShjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zdG9yYWdlUGx1Z2luLmdldCgoZXJyLCBsb2NhbHMpOiB2b2lkID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFja2FnZXM6IFZlcnNpb25bXSA9IFtdO1xuICAgICAgY29uc3QgZ2V0UGFja2FnZSA9IGZ1bmN0aW9uIChpdGVtUGtnKTogdm9pZCB7XG4gICAgICAgIHNlbGYubG9jYWxTdG9yYWdlLmdldFBhY2thZ2VNZXRhZGF0YShcbiAgICAgICAgICBsb2NhbHNbaXRlbVBrZ10sXG4gICAgICAgICAgZnVuY3Rpb24gKGVyciwgcGtnTWV0YWRhdGE6IFBhY2thZ2UpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChfLmlzTmlsKGVycikpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0ID0gcGtnTWV0YWRhdGFbRElTVF9UQUdTXS5sYXRlc3Q7XG4gICAgICAgICAgICAgIGlmIChsYXRlc3QgJiYgcGtnTWV0YWRhdGEudmVyc2lvbnNbbGF0ZXN0XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb246IFZlcnNpb24gPSBwa2dNZXRhZGF0YS52ZXJzaW9uc1tsYXRlc3RdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVMaXN0ID0gcGtnTWV0YWRhdGEudGltZSBhcyBHZW5lcmljQm9keTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGltZUxpc3RbbGF0ZXN0XTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmVyc2lvbi50aW1lID0gdGltZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBmb3Igc3RhcnMgYXBpXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZlcnNpb24udXNlcnMgPSBwa2dNZXRhZGF0YS51c2VycztcblxuICAgICAgICAgICAgICAgIHBhY2thZ2VzLnB1c2godmVyc2lvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sb2dnZXIud2FybihcbiAgICAgICAgICAgICAgICAgIHsgcGFja2FnZTogbG9jYWxzW2l0ZW1Qa2ddIH0sXG4gICAgICAgICAgICAgICAgICAncGFja2FnZSBAe3BhY2thZ2V9IGRvZXMgbm90IGhhdmUgYSBcImxhdGVzdFwiIHRhZz8nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbVBrZyA+PSBsb2NhbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwYWNrYWdlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBnZXRQYWNrYWdlKGl0ZW1Qa2cgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBpZiAobG9jYWxzLmxlbmd0aCkge1xuICAgICAgICBnZXRQYWNrYWdlKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgW10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZldGNoZXMgcGFja2FnZSBtZXRhZGF0YSBmcm9tIHVwbGlua3MgYW5kIHN5bmNocm9uaXplcyBpdCB3aXRoIGxvY2FsIGRhdGFcbiAgIGlmIHBhY2thZ2UgaXMgYXZhaWxhYmxlIGxvY2FsbHksIGl0IE1VU1QgYmUgcHJvdmlkZWQgaW4gcGtnaW5mb1xuICAgcmV0dXJucyBjYWxsYmFjayhlcnIsIHJlc3VsdCwgdXBsaW5rX2Vycm9ycylcbiAgICovXG4gIHB1YmxpYyBfc3luY1VwbGlua3NNZXRhZGF0YShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZUluZm86IE1hbmlmZXN0LFxuICAgIG9wdGlvbnM6IElTeW5jVXBsaW5rcyxcbiAgICBjYWxsYmFjazogQ2FsbGJhY2tcbiAgKTogdm9pZCB7XG4gICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB1cExpbmtzOiBQcm94eVN0b3JhZ2VbXSA9IFtdO1xuICAgIGNvbnN0IGhhc1RvTG9va0ludG9VcGxpbmtzID0gXy5pc05pbChvcHRpb25zLnVwbGlua3NMb29rKSB8fCBvcHRpb25zLnVwbGlua3NMb29rO1xuXG4gICAgaWYgKCFwYWNrYWdlSW5mbykge1xuICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgIHBhY2thZ2VJbmZvID0gZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUobmFtZSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1cGxpbmsgaW4gdGhpcy51cGxpbmtzKSB7XG4gICAgICBpZiAoaGFzUHJveHlUbyhuYW1lLCB1cGxpbmssIHRoaXMuY29uZmlnLnBhY2thZ2VzKSAmJiBoYXNUb0xvb2tJbnRvVXBsaW5rcykge1xuICAgICAgICB1cExpbmtzLnB1c2godGhpcy51cGxpbmtzW3VwbGlua10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLm1hcChcbiAgICAgIHVwTGlua3MsXG4gICAgICAodXBMaW5rOiBQcm94eVN0b3JhZ2UsIGNiKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IF9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHVwTGlua01ldGEgPSBwYWNrYWdlSW5mby5fdXBsaW5rc1t1cExpbmsudXBuYW1lXTtcblxuICAgICAgICBpZiAoaXNPYmplY3QodXBMaW5rTWV0YSkpIHtcbiAgICAgICAgICBjb25zdCBmZXRjaGVkID0gdXBMaW5rTWV0YS5mZXRjaGVkO1xuXG4gICAgICAgICAgaWYgKGZldGNoZWQgJiYgRGF0ZS5ub3coKSAtIGZldGNoZWQgPCB1cExpbmsubWF4YWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfb3B0aW9ucy5ldGFnID0gdXBMaW5rTWV0YS5ldGFnO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBMaW5rLmdldFJlbW90ZU1ldGFkYXRhKG5hbWUsIF9vcHRpb25zLCAoZXJyLCB1cExpbmtSZXNwb25zZSwgZVRhZyk6IHZvaWQgPT4ge1xuICAgICAgICAgIGlmIChlcnIgJiYgZXJyLnJlbW90ZVN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICAgICAgICB1cExpbmtNZXRhLmZldGNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlcnIgfHwgIXVwTGlua1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW2VyciB8fCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcignbm8gZGF0YScpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwTGlua1Jlc3BvbnNlID0gdmFsaWRhdGlvVXRpbHMubm9ybWFsaXplTWV0YWRhdGEodXBMaW5rUmVzcG9uc2UsIG5hbWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIuZXJyb3IoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWI6ICdvdXQnLFxuICAgICAgICAgICAgICAgIGVycjogZXJyLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAncGFja2FnZS5qc29uIHZhbGlkYXRpbmcgZXJyb3IgQHshZXJyLm1lc3NhZ2V9XFxuQHtlcnIuc3RhY2t9J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBbZXJyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFja2FnZUluZm8uX3VwbGlua3NbdXBMaW5rLnVwbmFtZV0gPSB7XG4gICAgICAgICAgICBldGFnOiBlVGFnLFxuICAgICAgICAgICAgZmV0Y2hlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcGFja2FnZUluZm8gPSBtZXJnZVVwbGlua1RpbWVJbnRvTG9jYWwocGFja2FnZUluZm8sIHVwTGlua1Jlc3BvbnNlKTtcblxuICAgICAgICAgIHVwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rKHVwTGlua1Jlc3BvbnNlLnZlcnNpb25zLCB1cExpbmspO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1lcmdlVmVyc2lvbnMocGFja2FnZUluZm8sIHVwTGlua1Jlc3BvbnNlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViOiAnb3V0JyxcbiAgICAgICAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ3BhY2thZ2UuanNvbiBwYXJzaW5nIGVycm9yIEB7IWVyci5tZXNzYWdlfVxcbkB7ZXJyLnN0YWNrfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW2Vycl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIGdvdCB0byB0aGlzIHBvaW50LCBhc3N1bWUgdGhhdCB0aGUgY29ycmVjdCBwYWNrYWdlIGV4aXN0c1xuICAgICAgICAgIC8vIG9uIHRoZSB1cGxpbmtcbiAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgKGVycjogRXJyb3IsIHVwTGlua3NFcnJvcnM6IGFueSk6IEFzeW5jUmVzdWx0QXJyYXlDYWxsYmFjazx1bmtub3duLCBFcnJvcj4gPT4ge1xuICAgICAgICBhc3NlcnQoIWVyciAmJiBBcnJheS5pc0FycmF5KHVwTGlua3NFcnJvcnMpKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgY29ubmVjdGlvbiB0aW1lb3V0IG9yIHJlc2V0IGVycm9ycyB3aXRoIHVwbGluayhzKVxuICAgICAgICAvLyAodGhlc2Ugc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZnJvbSB0aGUgcGFja2FnZSBub3QgYmVpbmcgZm91bmQpXG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICBsZXQgdXBsaW5rVGltZW91dEVycm9yO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBMaW5rc0Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1cExpbmtzRXJyb3JzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB1cExpbmtzRXJyb3JzW2ldW2pdLmNvZGU7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gJ0VUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VTT0NLRVRUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VDT05OUkVTRVQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbGlua1RpbWVvdXRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cGxpbmtUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0U2VydmljZVVuYXZhaWxhYmxlKCksIG51bGwsIHVwTGlua3NFcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5OT19QQUNLQUdFKSwgbnVsbCwgdXBMaW5rc0Vycm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBMaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcGFja2FnZUluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sb2NhbFN0b3JhZ2UudXBkYXRlVmVyc2lvbnMoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwYWNrYWdlSW5mbyxcbiAgICAgICAgICBhc3luYyAoZXJyLCBwYWNrYWdlSnNvbkxvY2FsOiBQYWNrYWdlKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbnkgZXJyb3IgaGVyZSB3aWxsIGNhdXNlIGEgNDA0LCBsaWtlIGFuIHVwbGluayBlcnJvci4gVGhpcyBpcyBsaWtlbHkgdGhlIHJpZ2h0IHRoaW5nIHRvIGRvXG4gICAgICAgICAgICAvLyBhcyBhIGJyb2tlbiBmaWx0ZXIgaXMgYSBzZWN1cml0eSByaXNrLlxuICAgICAgICAgICAgY29uc3QgZmlsdGVyRXJyb3JzOiBFcnJvcltdID0gW107XG4gICAgICAgICAgICAvLyBUaGlzIE1VU1QgYmUgZG9uZSBzZXJpYWxseSBhbmQgbm90IGluIHBhcmFsbGVsIGFzIHRoZXkgbW9kaWZ5IHBhY2thZ2VKc29uTG9jYWxcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIHNlbGYuZmlsdGVycykge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGZpbHRlcnMgY2FuIGFzc3VtZSBpdCdzIHNhdmUgdG8gbW9kaWZ5IHBhY2thZ2VKc29uTG9jYWwgYW5kIHJldHVybiBpdCBkaXJlY3RseSBmb3JcbiAgICAgICAgICAgICAgICAvLyBwZXJmb3JtYW5jZSAoaS5lLiBuZWVkIG5vdCBiZSBwdXJlKVxuICAgICAgICAgICAgICAgIHBhY2thZ2VKc29uTG9jYWwgPSBhd2FpdCBmaWx0ZXIuZmlsdGVyX21ldGFkYXRhKHBhY2thZ2VKc29uTG9jYWwpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgICAgIGZpbHRlckVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBhY2thZ2VKc29uTG9jYWwsIF8uY29uY2F0KHVwTGlua3NFcnJvcnMsIGZpbHRlckVycm9ycykpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIGhpZGRlbiB2YWx1ZSBmb3IgZWFjaCB2ZXJzaW9uLlxuICAgKiBAcGFyYW0ge0FycmF5fSB2ZXJzaW9ucyBsaXN0IG9mIHZlcnNpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHVwTGluayB1cGxpbmsgbmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHVibGljIF91cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayh2ZXJzaW9uczogVmVyc2lvbnMsIHVwTGluazogUHJveHlTdG9yYWdlKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBpIGluIHZlcnNpb25zKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZlcnNpb25zLCBpKSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG5cbiAgICAgICAgLy8gaG9sZHMgYSBcImhpZGRlblwiIHZhbHVlIHRvIGJlIHVzZWQgYnkgdGhlIHBhY2thZ2Ugc3RvcmFnZS5cbiAgICAgICAgdmVyc2lvbltTeW1ib2wuZm9yKCdfX3ZlcmRhY2Npb191cGxpbmsnKV0gPSB1cExpbmsudXBuYW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdG9yYWdlO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxJQUFBQSxPQUFBLEdBQUFDLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBQyxNQUFBLEdBQUFGLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRSxPQUFBLEdBQUFILHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBRyxPQUFBLEdBQUFKLHNCQUFBLENBQUFDLE9BQUE7QUFFQSxJQUFBSSxLQUFBLEdBQUFKLE9BQUE7QUFDQSxJQUFBSyxPQUFBLEdBQUFMLE9BQUE7QUFDQSxJQUFBTSxRQUFBLEdBQUFOLE9BQUE7QUFjQSxJQUFBTyxPQUFBLEdBQUFQLE9BQUE7QUFFQSxJQUFBUSxZQUFBLEdBQUFSLE9BQUE7QUFDQSxJQUFBUyxVQUFBLEdBQUFULE9BQUE7QUFDQSxJQUFBVSxhQUFBLEdBQUFYLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBVyxjQUFBLEdBQUFYLE9BQUE7QUFDQSxJQUFBWSxhQUFBLEdBQUFaLE9BQUE7QUFTQSxJQUFBYSxVQUFBLEdBQUFkLHNCQUFBLENBQUFDLE9BQUE7QUFDQSxJQUFBYyxXQUFBLEdBQUFkLE9BQUE7QUFDQSxJQUFBZSxNQUFBLEdBQUFmLE9BQUE7QUFBaUUsU0FBQUQsdUJBQUFpQixHQUFBLFdBQUFBLEdBQUEsSUFBQUEsR0FBQSxDQUFBQyxVQUFBLEdBQUFELEdBQUEsS0FBQUUsT0FBQSxFQUFBRixHQUFBO0FBRWpFLE1BQU1HLE9BQU8sQ0FBQztFQU9MQyxXQUFXQSxDQUFD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