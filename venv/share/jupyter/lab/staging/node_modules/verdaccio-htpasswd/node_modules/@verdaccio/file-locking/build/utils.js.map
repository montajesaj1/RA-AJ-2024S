{"version":3,"file":"utils.js","names":["fsP","fs","promises","require","readFile","statPromise","stat","lfLock","promisify","locker","lock","lfUnlock","unlock","statDir","name","dirPath","path","dirname","stats","isDirectory","Error","statFile","isFile","lockFileWithOptions","options","lockOpts","wait","pollPeriod","stale","retries","retryWait","unlockFileNext","lockFileName"],"sources":["../src/utils.ts"],"sourcesContent":["import fs from 'fs';\nimport locker from 'lockfile';\nimport path from 'path';\nimport { promisify } from 'util';\n\nconst fsP = fs.promises ? fs.promises : require('fs/promises');\n\nexport const readFile = fsP.readFile;\nconst statPromise = fsP.stat;\n// https://github.com/npm/lockfile/issues/33\nconst lfLock = promisify(locker.lock);\nconst lfUnlock = promisify(locker.unlock);\n\n/**\n * Test to see if the directory exists\n * @param name\n * @returns\n */\nexport async function statDir(name: string): Promise<void> {\n  const dirPath = path.dirname(name);\n  const stats = await statPromise(dirPath);\n  if (!stats.isDirectory()) {\n    throw new Error(`${path.dirname(name)} is not a directory`);\n  }\n  return;\n}\n\n/**\n *  test to see if the directory exists\n * @param name\n * @returns\n */\nexport async function statFile(name: string): Promise<void> {\n  const stats = await statPromise(name);\n  if (!stats.isFile()) {\n    throw new Error(`${path.dirname(name)} is not a file`);\n  }\n  return;\n}\n\n/**\n * Lock a file\n * @param name name of the file to lock\n */\nexport async function lockFileWithOptions(name: string, options?: any): Promise<void> {\n  const lockOpts = {\n    // time (ms) to wait when checking for stale locks\n    wait: 1000,\n    // how often (ms) to re-check stale locks\n    pollPeriod: 100,\n    // locks are considered stale after 5 minutes\n    stale: 5 * 60 * 1000,\n    // number of times to attempt to create a lock\n    retries: 100,\n    // time (ms) between tries\n    retryWait: 100,\n    ...options,\n  };\n  await lfLock(`${name}.lock`, lockOpts);\n}\n\n// unlocks file by removing existing lock file\nexport async function unlockFileNext(name: string): Promise<void> {\n  const lockFileName = `${name}.lock`;\n  return lfUnlock(lockFileName);\n}\n"],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AAAiC;AAEjC,MAAMA,GAAG,GAAGC,WAAE,CAACC,QAAQ,GAAGD,WAAE,CAACC,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;AAEvD,MAAMC,QAAQ,GAAGJ,GAAG,CAACI,QAAQ;AAAC;AACrC,MAAMC,WAAW,GAAGL,GAAG,CAACM,IAAI;AAC5B;AACA,MAAMC,MAAM,GAAG,IAAAC,eAAS,EAACC,iBAAM,CAACC,IAAI,CAAC;AACrC,MAAMC,QAAQ,GAAG,IAAAH,eAAS,EAACC,iBAAM,CAACG,MAAM,CAAC;;AAEzC;AACA;AACA;AACA;AACA;AACO,eAAeC,OAAO,CAACC,IAAY,EAAiB;EACzD,MAAMC,OAAO,GAAGC,aAAI,CAACC,OAAO,CAACH,IAAI,CAAC;EAClC,MAAMI,KAAK,GAAG,MAAMb,WAAW,CAACU,OAAO,CAAC;EACxC,IAAI,CAACG,KAAK,CAACC,WAAW,EAAE,EAAE;IACxB,MAAM,IAAIC,KAAK,CAAE,GAAEJ,aAAI,CAACC,OAAO,CAACH,IAAI,CAAE,qBAAoB,CAAC;EAC7D;EACA;AACF;;AAEA;AACA;AACA;AACA;AACA;AACO,eAAeO,QAAQ,CAACP,IAAY,EAAiB;EAC1D,MAAMI,KAAK,GAAG,MAAMb,WAAW,CAACS,IAAI,CAAC;EACrC,IAAI,CAACI,KAAK,CAACI,MAAM,EAAE,EAAE;IACnB,MAAM,IAAIF,KAAK,CAAE,GAAEJ,aAAI,CAACC,OAAO,CAACH,IAAI,CAAE,gBAAe,CAAC;EACxD;EACA;AACF;;AAEA;AACA;AACA;AACA;AACO,eAAeS,mBAAmB,CAACT,IAAY,EAAEU,OAAa,EAAiB;EACpF,MAAMC,QAAQ,GAAG;IACf;IACAC,IAAI,EAAE,IAAI;IACV;IACAC,UAAU,EAAE,GAAG;IACf;IACAC,KAAK,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI;IACpB;IACAC,OAAO,EAAE,GAAG;IACZ;IACAC,SAAS,EAAE,GAAG;IACd,GAAGN;EACL,CAAC;EACD,MAAMjB,MAAM,CAAE,GAAEO,IAAK,OAAM,EAAEW,QAAQ,CAAC;AACxC;;AAEA;AACO,eAAeM,cAAc,CAACjB,IAAY,EAAiB;EAChE,MAAMkB,YAAY,GAAI,GAAElB,IAAK,OAAM;EACnC,OAAOH,QAAQ,CAACqB,YAAY,CAAC;AAC/B"}