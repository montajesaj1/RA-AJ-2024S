var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// ../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save3;
    exports.load = load3;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save3(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load3() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/.pnpm/supports-color@6.1.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/.pnpm/supports-color@6.1.0/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === true || env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === false || env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save3;
    exports.load = load3;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save3(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load3() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts);
    };
  }
});

// ../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/.pnpm/debug@4.3.4_supports-color@6.1.0/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  SearchMemoryIndexer: () => indexer_default
});

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/languages.js
var STEMMERS = {
  arabic: "ar",
  armenian: "am",
  bulgarian: "bg",
  danish: "dk",
  dutch: "nl",
  english: "en",
  finnish: "fi",
  french: "fr",
  german: "de",
  greek: "gr",
  hungarian: "hu",
  indian: "in",
  indonesian: "id",
  irish: "ie",
  italian: "it",
  lithuanian: "lt",
  nepali: "np",
  norwegian: "no",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "rs",
  slovenian: "ru",
  spanish: "es",
  swedish: "se",
  turkish: "tr",
  ukrainian: "uk"
};
var SPLITTERS = {
  dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,
  italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
  norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,
  portuguese: /[^a-z0-9à-úÀ-Ú]/gim,
  russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,
  spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,
  swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,
  german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,
  finnish: /[^a-z0-9äöÄÖ]+/gim,
  danish: /[^a-z0-9æøåÆØÅ]+/gim,
  hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,
  romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,
  serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,
  turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,
  lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,
  arabic: /[^a-z0-9أ-ي]+/gim,
  nepali: /[^a-z0-9अ-ह]+/gim,
  irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,
  indian: /[^a-z0-9अ-ह]+/gim,
  armenian: /[^a-z0-9ա-ֆ]+/gim,
  greek: /[^a-z0-9α-ωά-ώ]+/gim,
  indonesian: /[^a-z0-9]+/gim,
  ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,
  slovenian: /[^a-z0-9čžšČŽŠ]+/gim,
  bulgarian: /[^a-z0-9а-яА-Я]+/gim
};
var SUPPORTED_LANGUAGES = Object.keys(STEMMERS);

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/utils.js
var baseId = Date.now().toString().slice(5);
var lastId = 0;
var nano = BigInt(1e3);
var milli = BigInt(1e6);
var second = BigInt(1e9);
function sprintf(template, ...args) {
  return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function(...replaceArgs) {
    const groups = replaceArgs[replaceArgs.length - 1];
    const { width: rawWidth, type, position } = groups;
    const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();
    const width = rawWidth === "" ? 0 : Number.parseInt(rawWidth);
    switch (type) {
      case "d":
        return replacement.toString().padStart(width, "0");
      case "f": {
        let value = replacement;
        const [padding, precision] = rawWidth.split(".").map((w) => Number.parseFloat(w));
        if (typeof precision === "number" && precision >= 0) {
          value = value.toFixed(precision);
        }
        return typeof padding === "number" && padding >= 0 ? value.toString().padStart(width, "0") : value.toString();
      }
      case "s":
        return width < 0 ? replacement.toString().padEnd(-width, " ") : replacement.toString().padStart(width, " ");
      default:
        return replacement;
    }
  });
}
async function formatNanoseconds(value) {
  if (typeof value === "number") {
    value = BigInt(value);
  }
  if (value < nano) {
    return `${value}ns`;
  } else if (value < milli) {
    return `${value / nano}\u03BCs`;
  } else if (value < second) {
    return `${value / milli}ms`;
  }
  return `${value / second}s`;
}
async function getNanosecondsTime() {
  if (typeof process !== "undefined" && process.hrtime !== void 0) {
    return process.hrtime.bigint();
  }
  if (typeof performance !== "undefined") {
    return BigInt(Math.floor(performance.now() * 1e6));
  }
  return BigInt(0);
}
async function uniqueId() {
  return `${baseId}-${lastId++}`;
}
function syncUniqueId() {
  return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
  if (Object.hasOwn === void 0) {
    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
  }
  return Object.hasOwn(object, property) ? object[property] : void 0;
}
function sortTokenScorePredicate(a, b) {
  if (b[1] === a[1]) {
    return a[0].localeCompare(b[0]);
  }
  return b[1] - a[1];
}
function intersect(arrays) {
  if (arrays.length === 0) {
    return [];
  } else if (arrays.length === 1) {
    return arrays[0];
  }
  for (let i = 1; i < arrays.length; i++) {
    if (arrays[i].length < arrays[0].length) {
      const tmp = arrays[0];
      arrays[0] = arrays[i];
      arrays[i] = tmp;
    }
  }
  const set = /* @__PURE__ */ new Map();
  for (const elem of arrays[0]) {
    set.set(elem, 1);
  }
  for (let i = 1; i < arrays.length; i++) {
    let found = 0;
    for (const elem of arrays[i]) {
      const count2 = set.get(elem);
      if (count2 === i) {
        set.set(elem, count2 + 1);
        found++;
      }
    }
    if (found === 0)
      return [];
  }
  return arrays[0].filter((e) => {
    const count2 = set.get(e);
    if (count2 !== void 0)
      set.set(e, 0);
    return count2 === arrays.length;
  });
}
async function getDocumentProperties(doc, paths) {
  const properties = {};
  const pathsLength = paths.length;
  for (let i = 0; i < pathsLength; i++) {
    const path = paths[i];
    const pathTokens = path.split(".");
    let current = doc;
    const pathTokensLength = pathTokens.length;
    for (let j = 0; j < pathTokensLength; j++) {
      current = current[pathTokens[j]];
      if (typeof current === "object" && current !== null && j === pathTokensLength - 1) {
        current = void 0;
        break;
      } else if ((current === null || typeof current !== "object") && j < pathTokensLength - 1) {
        current = void 0;
        break;
      }
    }
    if (typeof current !== "undefined") {
      properties[path] = current;
    }
  }
  return properties;
}
async function getNested(obj, path) {
  const props = await getDocumentProperties(obj, [
    path
  ]);
  return props[path];
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/errors.js
var allLanguages = SUPPORTED_LANGUAGES.join("\n - ");
var errors = {
  NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: "Do not pass the language option to create when using a custom tokenizer.",
  LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.
Supported languages are:
 - ${allLanguages}`,
  INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
  MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.oramasearch.com/text-analysis/stemming for more information.`,
  CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: "Custom stop words array must only contain strings.",
  UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
  COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
  COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
  INVALID_SCHEMA_TYPE: `Unsupported schema type "%s". Expected "string", "boolean" or "number".`,
  DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
  DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
  DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
  MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
  INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
  UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
  INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
  INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`
};
function createError(code, ...args) {
  var _a2;
  const error = new Error(sprintf((_a2 = errors[code]) != null ? _a2 : `Unsupported Orama Error code: ${code}`, ...args));
  error.code = code;
  if ("captureStackTrace" in Error.prototype) {
    Error.captureStackTrace(error);
  }
  return error;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/defaults.js
async function formatElapsedTime(n) {
  return {
    raw: Number(n),
    formatted: await formatNanoseconds(n)
  };
}
async function getDocumentIndexId(doc) {
  if (doc.id) {
    if (typeof doc.id !== "string") {
      throw createError("DOCUMENT_ID_MUST_BE_STRING", typeof doc.id);
    }
    return doc.id;
  }
  return await uniqueId();
}
async function validateSchema(doc, schema) {
  for (const [prop, type] of Object.entries(schema)) {
    if (typeof type === "object") {
      if (!doc[prop] || typeof doc[prop] !== "object" && Array.isArray(doc[prop])) {
        return false;
      }
      if (!validateSchema(doc[prop], type)) {
        return false;
      }
    }
    if (typeof doc[prop] !== type) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/documents-store.js
async function create() {
  return {
    docs: {},
    count: 0
  };
}
async function get(store2, id) {
  return store2.docs[id];
}
async function getMultiple(store2, ids) {
  const found = Array.from({
    length: ids.length
  });
  for (let i = 0; i < ids.length; i++) {
    found[i] = store2.docs[ids[i]];
  }
  return found;
}
async function getAll(store2) {
  return store2.docs;
}
async function store(store2, id, doc) {
  if (typeof store2.docs[id] !== "undefined") {
    return false;
  }
  store2.docs[id] = doc;
  store2.count++;
  return true;
}
async function remove(store2, id) {
  if (typeof store2.docs[id] === "undefined") {
    return false;
  }
  store2.docs[id] = void 0;
  store2.count--;
  return true;
}
async function count(store2) {
  return store2.count;
}
async function load(raw) {
  const rawDocument = raw;
  return {
    docs: rawDocument.docs,
    count: rawDocument.count
  };
}
async function save(docs) {
  return {
    docs: docs.docs,
    count: docs.count
  };
}
async function createDocumentsStore() {
  return {
    create,
    get,
    getMultiple,
    getAll,
    store,
    remove,
    count,
    load,
    save
  };
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/hooks.js
var OBJECT_COMPONENTS = [
  "tokenizer",
  "index",
  "documentsStore"
];
var FUNCTION_COMPONENTS = [
  "validateSchema",
  "getDocumentIndexId",
  "getDocumentProperties",
  "formatElapsedTime"
];
var SINGLE_OR_ARRAY_COMPONENTS = [
  "beforeInsert",
  "afterInsert",
  "beforeRemove",
  "afterRemove",
  "beforeUpdate",
  "afterUpdate",
  "beforeMultipleInsert",
  "afterMultipleInsert",
  "beforeMultipleRemove",
  "afterMultipleRemove",
  "beforeMultipleUpdate",
  "afterMultipleUpdate"
];
async function runSingleHook(hooks, orama, id, doc) {
  for (let i = 0; i < hooks.length; i++) {
    await hooks[i](orama, id, doc);
  }
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/trees/avl.js
var BALANCE_STATE = {
  UNBALANCED_RIGHT: 1,
  SLIGHTLY_UNBALANCED_RIGHT: 2,
  BALANCED: 3,
  SLIGHTLY_UNBALANCED_LEFT: 4,
  UNBALANCED_LEFT: 5
};
function getBalanceFactor(node) {
  const heightDifference = getHeight(node.left) - getHeight(node.right);
  switch (heightDifference) {
    case -2:
      return BALANCE_STATE.UNBALANCED_RIGHT;
    case -1:
      return BALANCE_STATE.SLIGHTLY_UNBALANCED_RIGHT;
    case 1:
      return BALANCE_STATE.SLIGHTLY_UNBALANCED_LEFT;
    case 2:
      return BALANCE_STATE.UNBALANCED_LEFT;
    default:
      return BALANCE_STATE.BALANCED;
  }
}
function getHeight(node) {
  return node ? node.height : -1;
}
function rotateLeft(node) {
  const right = node.right;
  node.right = right.left;
  right.left = node;
  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
  right.height = Math.max(getHeight(right.left), getHeight(right.right)) + 1;
  return right;
}
function rotateRight(node) {
  const left = node.left;
  node.left = left.right;
  left.right = node;
  node.height = Math.max(getHeight(node.left), getHeight(node.right)) + 1;
  left.height = Math.max(getHeight(left.left), getHeight(left.right)) + 1;
  return left;
}
function findMin(node) {
  return node.left ? findMin(node.left) : node;
}
function rangeSearch(node, min, max) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (node2.key > min) {
      traverse(node2.left);
    }
    if (node2.key >= min && node2.key <= max) {
      result.push(...node2.value);
    }
    if (node2.key < max) {
      traverse(node2.right);
    }
  }
  traverse(node);
  return result;
}
function greaterThan(node, key, inclusive = false) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (inclusive && node2.key >= key) {
      result.push(...node2.value);
    }
    if (!inclusive && node2.key > key) {
      result.push(...node2.value);
    }
    traverse(node2.left);
    traverse(node2.right);
  }
  traverse(node);
  return result;
}
function lessThan(node, key, inclusive = false) {
  if (!node) {
    return [];
  }
  const result = [];
  function traverse(node2) {
    if (!node2) {
      return;
    }
    if (inclusive && node2.key <= key) {
      result.push(...node2.value);
    }
    if (!inclusive && node2.key < key) {
      result.push(...node2.value);
    }
    traverse(node2.left);
    traverse(node2.right);
  }
  traverse(node);
  return result;
}
function getNodeByKey(node, key) {
  if (!node) {
    return null;
  }
  if (node.key === key) {
    return node;
  }
  if (key < node.key) {
    return node.left ? getNodeByKey(node.left, key) : null;
  }
  return node.right ? getNodeByKey(node.right, key) : null;
}
function create2(key, value) {
  return {
    key,
    value,
    left: null,
    right: null,
    height: 0
  };
}
function insert(node, key, value) {
  if (!node) {
    return create2(key, value);
  }
  if (key < node.key) {
    node.left = insert(node.left, key, value);
  } else if (key > node.key) {
    node.right = insert(node.right, key, value);
  } else {
    node.value = node.value.concat(value);
    return node;
  }
  const balanceFactor = getBalanceFactor(node);
  if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {
    if (key < node.left.key) {
      node = rotateRight(node);
    } else {
      node.left = rotateLeft(node.left);
      node = rotateRight(node);
    }
  }
  if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {
    if (key > node.right.key) {
      node = rotateLeft(node);
    } else {
      node.right = rotateRight(node.right);
      node = rotateLeft(node);
    }
  }
  return node;
}
function find(node, key) {
  if (!node) {
    return null;
  }
  if (node.key === key) {
    return node.value;
  }
  if (key < node.key) {
    return node.left ? find(node.left, key) : null;
  }
  return node.right ? find(node.right, key) : null;
}
function remove2(node, key) {
  if (!node) {
    return null;
  }
  if (key < node.key) {
    node.left = remove2(node.left, key);
  } else if (key > node.key) {
    node.right = remove2(node.right, key);
  } else {
    if (!node.left && !node.right) {
      return null;
    }
    if (!node.left) {
      return node.right;
    }
    if (!node.right) {
      return node.left;
    }
    const temp = findMin(node.right);
    node.key = temp.key;
    node.right = remove2(node.right, temp.key);
  }
  const balanceFactor = getBalanceFactor(node);
  const leftNode = node.left;
  const rightNode = node.right;
  if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {
    if (getBalanceFactor(leftNode) === BALANCE_STATE.BALANCED || getBalanceFactor(leftNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_LEFT) {
      return rotateRight(node);
    }
    if (getBalanceFactor(leftNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_RIGHT) {
      node.left = rotateLeft(leftNode);
      return rotateRight(node);
    }
  }
  if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {
    if (getBalanceFactor(rightNode) === BALANCE_STATE.BALANCED || getBalanceFactor(rightNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_RIGHT) {
      return rotateLeft(node);
    }
    if (getBalanceFactor(rightNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_LEFT) {
      node.right = rotateRight(rightNode);
      return rotateLeft(node);
    }
  }
  return node;
}
function removeDocument(root, id, key) {
  const node = getNodeByKey(root, key);
  if (node.value.length === 1) {
    remove2(root, key);
    return;
  }
  node.value.splice(node.value.indexOf(id), 1);
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/levenshtein.js
function _boundedLevenshtein(a, b, tolerance) {
  if (a === b) {
    return 0;
  }
  const swap = a;
  if (a.length > b.length) {
    a = b;
    b = swap;
  }
  let lenA = a.length;
  let lenB = b.length;
  while (lenA > 0 && a.charCodeAt(~-lenA) === b.charCodeAt(~-lenB)) {
    lenA--;
    lenB--;
  }
  if (!lenA) {
    return lenB > tolerance ? -1 : lenB;
  }
  let startIdx = 0;
  while (startIdx < lenA && a.charCodeAt(startIdx) === b.charCodeAt(startIdx)) {
    startIdx++;
  }
  lenA -= startIdx;
  lenB -= startIdx;
  if (lenA === 0) {
    return lenB > tolerance ? -1 : lenB;
  }
  const delta = lenB - lenA;
  if (tolerance > lenB) {
    tolerance = lenB;
  } else if (delta > tolerance) {
    return -1;
  }
  let i = 0;
  const row = [];
  const characterCodeCache = [];
  while (i < tolerance) {
    characterCodeCache[i] = b.charCodeAt(startIdx + i);
    row[i] = ++i;
  }
  while (i < lenB) {
    characterCodeCache[i] = b.charCodeAt(startIdx + i);
    row[i++] = tolerance + 1;
  }
  const offset = tolerance - delta;
  const haveMax = tolerance < lenB;
  let jStart = 0;
  let jEnd = tolerance;
  let current = 0;
  let left = 0;
  let above = 0;
  let charA = 0;
  let j = 0;
  for (i = 0; i < lenA; i++) {
    left = i;
    current = i + 1;
    charA = a.charCodeAt(startIdx + i);
    jStart += i > offset ? 1 : 0;
    jEnd += jEnd < lenB ? 1 : 0;
    for (j = jStart; j < jEnd; j++) {
      above = current;
      current = left;
      left = row[j];
      if (charA !== characterCodeCache[j]) {
        if (left < current) {
          current = left;
        }
        if (above < current) {
          current = above;
        }
        current++;
      }
      row[j] = current;
    }
    if (haveMax && row[i + delta] > tolerance) {
      return -1;
    }
  }
  return current <= tolerance ? current : -1;
}
function syncBoundedLevenshtein(a, b, tolerance) {
  const distance = _boundedLevenshtein(a, b, tolerance);
  return {
    distance,
    isBounded: distance >= 0
  };
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/trees/radix.js
function serialize() {
  const { word, subWord, children, docs, end } = this;
  return {
    word,
    subWord,
    children,
    docs,
    end
  };
}
function updateParent(node, parent) {
  node.parent = parent.id;
  node.word = parent.word + node.subWord;
}
function addDocument(node, docID) {
  node.docs.push(docID);
}
function removeDocument2(node, docID) {
  const index = node.docs.indexOf(docID);
  if (index === -1) {
    return false;
  }
  node.docs.splice(index, 1);
  return true;
}
function findAllWords(node, output, term, exact, tolerance) {
  if (node.end) {
    const { word, docs: docIDs } = node;
    if (exact && word !== term) {
      return {};
    }
    if (!getOwnProperty(output, word)) {
      if (tolerance) {
        const difference = Math.abs(term.length - word.length);
        if (difference <= tolerance && syncBoundedLevenshtein(term, word, tolerance).isBounded) {
          output[word] = [];
        }
      } else {
        output[word] = [];
      }
    }
    if (getOwnProperty(output, word) && docIDs.length) {
      const docs = new Set(output[word]);
      const docIDsLength = docIDs.length;
      for (let i = 0; i < docIDsLength; i++) {
        docs.add(docIDs[i]);
      }
      output[word] = Array.from(docs);
    }
  }
  for (const character of Object.keys(node.children)) {
    findAllWords(node.children[character], output, term, exact, tolerance);
  }
  return output;
}
function getCommonPrefix(a, b) {
  let commonPrefix = "";
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i] !== b[i]) {
      return commonPrefix;
    }
    commonPrefix += a[i];
  }
  return commonPrefix;
}
function create3(end = false, subWord = "", key = "") {
  const node = {
    id: syncUniqueId(),
    key,
    subWord,
    parent: null,
    children: {},
    docs: [],
    end,
    word: ""
  };
  Object.defineProperty(node, "toJSON", {
    value: serialize
  });
  return node;
}
function insert2(root, word, docId) {
  for (let i = 0; i < word.length; i++) {
    const currentCharacter = word[i];
    const wordAtIndex = word.substring(i);
    const rootChildCurrentChar = root.children[currentCharacter];
    if (rootChildCurrentChar) {
      const edgeLabel = rootChildCurrentChar.subWord;
      const edgeLabelLength = edgeLabel.length;
      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);
      const commonPrefixLength = commonPrefix.length;
      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];
      if (edgeLabel === wordAtIndex) {
        addDocument(rootChildCurrentChar, docId);
        rootChildCurrentChar.end = true;
        return;
      }
      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {
        const newNode = create3(true, wordAtIndex, currentCharacter);
        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix];
        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength);
        newNodeChild.key = edgeLabelAtCommonPrefix;
        root.children[currentCharacter] = newNode;
        updateParent(newNode, root);
        updateParent(newNodeChild, newNode);
        addDocument(newNode, docId);
        return;
      }
      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {
        const inbetweenNode = create3(false, commonPrefix, currentCharacter);
        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;
        root.children[currentCharacter] = inbetweenNode;
        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix];
        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength);
        inbetweenNodeChild.key = edgeLabelAtCommonPrefix;
        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];
        const newNode = create3(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);
        addDocument(newNode, docId);
        inbetweenNode.children[wordAtCommonPrefix] = newNode;
        updateParent(inbetweenNode, root);
        updateParent(newNode, inbetweenNode);
        updateParent(inbetweenNodeChild, inbetweenNode);
        return;
      }
      i += edgeLabelLength - 1;
      root = rootChildCurrentChar;
    } else {
      const newNode = create3(true, wordAtIndex, currentCharacter);
      addDocument(newNode, docId);
      root.children[currentCharacter] = newNode;
      updateParent(newNode, root);
      return;
    }
  }
}
function find2(root, { term, exact, tolerance }) {
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    if (character in root.children) {
      const rootChildCurrentChar = root.children[character];
      const edgeLabel = rootChildCurrentChar.subWord;
      const termSubstring = term.substring(i);
      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);
      const commonPrefixLength = commonPrefix.length;
      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {
        if (tolerance)
          break;
        return {};
      }
      i += rootChildCurrentChar.subWord.length - 1;
      root = rootChildCurrentChar;
    } else {
      return {};
    }
  }
  const output = {};
  findAllWords(root, output, term, exact, tolerance);
  return output;
}
function removeDocumentByWord(root, term, docID, exact = true) {
  if (!term) {
    return true;
  }
  for (let i = 0; i < term.length; i++) {
    const character = term[i];
    if (character in root.children) {
      const rootChildCurrentChar = root.children[character];
      i += rootChildCurrentChar.subWord.length - 1;
      root = rootChildCurrentChar;
      if (exact && root.word !== term) {
      } else {
        removeDocument2(root, docID);
      }
    } else {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/algorithms.js
function prioritizeTokenScores(arrays, boost, threshold = 1) {
  if (boost === 0) {
    throw createError("INVALID_BOOST_VALUE");
  }
  const tokenMap = {};
  const mapsLength = arrays.length;
  for (let i = 0; i < mapsLength; i++) {
    const arr = arrays[i];
    const entriesLength = arr.length;
    for (let j = 0; j < entriesLength; j++) {
      const [token, score] = arr[j];
      const boostScore = score * boost;
      if (token in tokenMap) {
        tokenMap[token] *= 1.5 + boostScore;
      } else {
        tokenMap[token] = boostScore;
      }
    }
  }
  const results = Object.entries(tokenMap).sort((a, b) => b[1] - a[1]);
  if (threshold === 1) {
    return results;
  }
  if (threshold === 0) {
    const shortestArrayLength = Math.min(...arrays.map((arr) => arr.length));
    return results.slice(0, shortestArrayLength);
  }
  const thresholdLength = Math.ceil(threshold * 100 * results.length / 100);
  return results.slice(0, results.length + thresholdLength);
}
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, BM25Params) {
  const { k, b, d } = BM25Params;
  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
  return idf * (d + tf * (k + 1)) / (tf + k * (1 - b + b * fieldLength / averageFieldLength));
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/index.js
async function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {
  var _a2;
  index.avgFieldLength[prop] = (((_a2 = index.avgFieldLength[prop]) != null ? _a2 : 0) * (docsCount - 1) + tokens.length) / docsCount;
  index.fieldLengths[prop][id] = tokens.length;
  index.frequencies[prop][id] = {};
}
async function insertTokenScoreParameters(index, prop, id, tokens, token) {
  var _a2;
  let tokenFrequency = 0;
  for (const t of tokens) {
    if (t === token) {
      tokenFrequency++;
    }
  }
  const tf = tokenFrequency / tokens.length;
  index.frequencies[prop][id][token] = tf;
  if (!(token in index.tokenOccurrencies[prop])) {
    index.tokenOccurrencies[prop][token] = 0;
  }
  index.tokenOccurrencies[prop][token] = ((_a2 = index.tokenOccurrencies[prop][token]) != null ? _a2 : 0) + 1;
}
async function removeDocumentScoreParameters(index, prop, id, docsCount) {
  index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][id]) / (docsCount - 1);
  index.fieldLengths[prop][id] = void 0;
  index.frequencies[prop][id] = void 0;
}
async function removeTokenScoreParameters(index, prop, token) {
  index.tokenOccurrencies[prop][token]--;
}
async function calculateResultScores(context, index, prop, term, ids) {
  var _a2, _b;
  const documentIDs = Array.from(ids);
  const avgFieldLength = index.avgFieldLength[prop];
  const fieldLengths = index.fieldLengths[prop];
  const oramaOccurrencies = index.tokenOccurrencies[prop];
  const oramaFrequencies = index.frequencies[prop];
  const termOccurrencies = typeof oramaOccurrencies[term] === "number" ? (_a2 = oramaOccurrencies[term]) != null ? _a2 : 0 : 0;
  const scoreList = [];
  const documentIDsLength = documentIDs.length;
  for (let k = 0; k < documentIDsLength; k++) {
    var _oramaFrequencies_id;
    const id = documentIDs[k];
    const tf = (_b = oramaFrequencies === null || oramaFrequencies === void 0 ? void 0 : (_oramaFrequencies_id = oramaFrequencies[id]) === null || _oramaFrequencies_id === void 0 ? void 0 : _oramaFrequencies_id[term]) != null ? _b : 0;
    const bm25 = BM25(tf, termOccurrencies, context.docsCount, fieldLengths[id], avgFieldLength, context.params.relevance);
    scoreList.push([
      id,
      bm25
    ]);
  }
  return scoreList;
}
async function create4(orama, schema, index, prefix = "") {
  if (!index) {
    index = {
      indexes: {},
      searchableProperties: [],
      searchablePropertiesWithTypes: {},
      frequencies: {},
      tokenOccurrencies: {},
      avgFieldLength: {},
      fieldLengths: {}
    };
  }
  for (const [prop, type] of Object.entries(schema)) {
    const typeActualType = typeof type;
    const path = `${prefix}${prefix ? "." : ""}${prop}`;
    if (typeActualType === "object" && !Array.isArray(type)) {
      create4(orama, type, index, path);
      continue;
    }
    switch (type) {
      case "boolean":
        index.indexes[path] = {
          true: [],
          false: []
        };
        break;
      case "number":
        index.indexes[path] = create2(0, []);
        break;
      case "string":
        index.indexes[path] = create3();
        index.avgFieldLength[path] = 0;
        index.frequencies[path] = {};
        index.tokenOccurrencies[path] = {};
        index.fieldLengths[path] = {};
        break;
      default:
        throw createError("INVALID_SCHEMA_TYPE", Array.isArray(type) ? "array" : typeActualType);
    }
    index.searchableProperties.push(path);
    index.searchablePropertiesWithTypes[path] = type;
  }
  return index;
}
async function insert3(implementation, index, prop, id, value, language, tokenizer, docsCount) {
  if (typeof value === "number") {
    insert(index.indexes[prop], value, [
      id
    ]);
    return;
  } else if (typeof value === "boolean") {
    index.indexes[prop][value ? "true" : "false"].push(id);
    return;
  }
  const tokens = await tokenizer.tokenize(value, language, prop);
  await implementation.insertDocumentScoreParameters(index, prop, id, tokens, docsCount);
  for (const token of tokens) {
    await implementation.insertTokenScoreParameters(index, prop, id, tokens, token);
    insert2(index.indexes[prop], token, id);
  }
}
async function remove3(implementation, index, prop, id, value, language, tokenizer, docsCount) {
  if (typeof value === "number") {
    removeDocument(index.indexes[prop], id, value);
    return true;
  } else if (typeof value === "boolean") {
    const booleanKey = value ? "true" : "false";
    const position = index.indexes[prop][booleanKey].indexOf(id);
    index.indexes[prop][value ? "true" : "false"].splice(position, 1);
    return true;
  }
  const tokens = await tokenizer.tokenize(value, language, prop);
  await implementation.removeDocumentScoreParameters(index, prop, id, docsCount);
  for (const token of tokens) {
    await implementation.removeTokenScoreParameters(index, prop, token);
    removeDocumentByWord(index.indexes[prop], token, id);
  }
  return true;
}
async function search(context, index, prop, term) {
  if (!(prop in index.tokenOccurrencies)) {
    return [];
  }
  const rootNode = index.indexes[prop];
  const { exact, tolerance } = context.params;
  const searchResult = find2(rootNode, {
    term,
    exact,
    tolerance
  });
  const ids = /* @__PURE__ */ new Set();
  for (const key in searchResult) {
    for (const id of searchResult[key]) {
      ids.add(id);
    }
  }
  return context.index.calculateResultScores(context, index, prop, term, Array.from(ids));
}
async function searchByWhereClause(context, index, filters) {
  var _a2;
  const filterKeys = Object.keys(filters);
  const filtersMap = filterKeys.reduce((acc, key) => __spreadValues({
    [key]: []
  }, acc), {});
  for (const param of filterKeys) {
    const operation = filters[param];
    if (typeof operation === "boolean") {
      const idx = index.indexes[param];
      const filteredIDs = idx[operation.toString()];
      filtersMap[param].push(...filteredIDs);
      continue;
    }
    if (typeof operation === "string" || Array.isArray(operation)) {
      const idx = index.indexes[param];
      for (const raw of [
        operation
      ].flat()) {
        const term = await context.tokenizer.tokenize(raw, context.language, param);
        const filteredIDsResults = find2(idx, {
          term: term[0],
          exact: true
        });
        filtersMap[param].push(...Object.values(filteredIDsResults).flat());
      }
      continue;
    }
    const operationKeys = Object.keys(operation);
    if (operationKeys.length > 1) {
      throw createError("INVALID_FILTER_OPERATION", operationKeys.length);
    }
    const operationOpt = operationKeys[0];
    const operationValue = operation[operationOpt];
    const AVLNode = index.indexes[param];
    switch (operationOpt) {
      case "gt": {
        const filteredIDs = greaterThan(AVLNode, operationValue, false);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "gte": {
        const filteredIDs = greaterThan(AVLNode, operationValue, true);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "lt": {
        const filteredIDs = lessThan(AVLNode, operationValue, false);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "lte": {
        const filteredIDs = lessThan(AVLNode, operationValue, true);
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "eq": {
        const filteredIDs = (_a2 = find(AVLNode, operationValue)) != null ? _a2 : [];
        filtersMap[param].push(...filteredIDs);
        break;
      }
      case "between": {
        const [min, max] = operationValue;
        const filteredIDs = rangeSearch(AVLNode, min, max);
        filtersMap[param].push(...filteredIDs);
      }
    }
  }
  const result = intersect(Object.values(filtersMap));
  return result;
}
async function getSearchableProperties(index) {
  return index.searchableProperties;
}
async function getSearchablePropertiesWithTypes(index) {
  return index.searchablePropertiesWithTypes;
}
async function load2(raw) {
  const { indexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrencies, avgFieldLength, fieldLengths } = raw;
  return {
    indexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrencies,
    avgFieldLength,
    fieldLengths
  };
}
async function save2(index) {
  const { indexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrencies, avgFieldLength, fieldLengths } = index;
  return {
    indexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrencies,
    avgFieldLength,
    fieldLengths
  };
}
async function createIndex() {
  return {
    create: create4,
    insert: insert3,
    remove: remove3,
    insertDocumentScoreParameters,
    insertTokenScoreParameters,
    removeDocumentScoreParameters,
    removeTokenScoreParameters,
    calculateResultScores,
    search,
    searchByWhereClause,
    getSearchableProperties,
    getSearchablePropertiesWithTypes,
    load: load2,
    save: save2
  };
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/diacritics.js
var DIACRITICS_CHARCODE_START = 192;
var DIACRITICS_CHARCODE_END = 383;
var CHARCODE_REPLACE_MAPPING = [
  65,
  65,
  65,
  65,
  65,
  65,
  65,
  67,
  69,
  69,
  69,
  69,
  73,
  73,
  73,
  73,
  69,
  78,
  79,
  79,
  79,
  79,
  79,
  null,
  79,
  85,
  85,
  85,
  85,
  89,
  80,
  115,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  99,
  101,
  101,
  101,
  101,
  105,
  105,
  105,
  105,
  101,
  110,
  111,
  111,
  111,
  111,
  111,
  null,
  111,
  117,
  117,
  117,
  117,
  121,
  112,
  121,
  65,
  97,
  65,
  97,
  65,
  97,
  67,
  99,
  67,
  99,
  67,
  99,
  67,
  99,
  68,
  100,
  68,
  100,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  71,
  103,
  71,
  103,
  71,
  103,
  71,
  103,
  72,
  104,
  72,
  104,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  74,
  106,
  75,
  107,
  107,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  78,
  110,
  78,
  110,
  78,
  110,
  110,
  78,
  110,
  79,
  111,
  79,
  111,
  79,
  111,
  79,
  111,
  82,
  114,
  82,
  114,
  82,
  114,
  83,
  115,
  83,
  115,
  83,
  115,
  83,
  115,
  84,
  116,
  84,
  116,
  84,
  116,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  87,
  119,
  89,
  121,
  89,
  90,
  122,
  90,
  122,
  90,
  122,
  115
];
function replaceChar(charCode) {
  if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END)
    return charCode;
  return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
  const stringCharCode = [];
  for (let idx = 0; idx < str.length; idx++) {
    stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
  }
  return String.fromCharCode(...stringCharCode);
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/en.js
var en = [
  "i",
  "me",
  "my",
  "myself",
  "we",
  "us",
  "our",
  "ours",
  "ourselves",
  "you",
  "your",
  "yours",
  "yourself",
  "yourselves",
  "he",
  "him",
  "his",
  "himself",
  "she",
  "her",
  "hers",
  "herself",
  "it",
  "its",
  "itself",
  "they",
  "them",
  "their",
  "theirs",
  "themselves",
  "what",
  "which",
  "who",
  "whom",
  "this",
  "that",
  "these",
  "those",
  "am",
  "is",
  "are",
  "was",
  "were",
  "be",
  "been",
  "being",
  "have",
  "has",
  "had",
  "having",
  "do",
  "does",
  "did",
  "doing",
  "will",
  "would",
  "shall",
  "should",
  "can",
  "could",
  "may",
  "might",
  "must",
  "ought",
  "i'm",
  "you're",
  "he's",
  "she's",
  "it's",
  "we're",
  "they're",
  "i've",
  "you've",
  "we've",
  "they've",
  "i'd",
  "you'd",
  "he'd",
  "she'd",
  "we'd",
  "they'd",
  "i'll",
  "you'll",
  "he'll",
  "she'll",
  "we'll",
  "they'll",
  "isn't",
  "aren't",
  "wasn't",
  "weren't",
  "hasn't",
  "haven't",
  "hadn't",
  "doesn't",
  "don't",
  "didn't",
  "won't",
  "wouldn't",
  "shan't",
  "shouldn't",
  "can't",
  "cannot",
  "couldn't",
  "mustn't",
  "let's",
  "that's",
  "who's",
  "what's",
  "here's",
  "there's",
  "when's",
  "where's",
  "why's",
  "how's",
  "an",
  "the",
  "and",
  "but",
  "if",
  "or",
  "because",
  "as",
  "until",
  "while",
  "of",
  "at",
  "by",
  "for",
  "with",
  "about",
  "against",
  "between",
  "into",
  "through",
  "during",
  "before",
  "after",
  "above",
  "below",
  "to",
  "from",
  "up",
  "down",
  "in",
  "out",
  "on",
  "off",
  "over",
  "under",
  "again",
  "further",
  "then",
  "once",
  "here",
  "there",
  "when",
  "where",
  "why",
  "how",
  "all",
  "any",
  "both",
  "each",
  "few",
  "more",
  "most",
  "other",
  "some",
  "such",
  "no",
  "nor",
  "not",
  "only",
  "own",
  "same",
  "so",
  "than",
  "too",
  "very"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/it.js
var it = [
  "ad",
  "al",
  "allo",
  "ai",
  "agli",
  "all",
  "agl",
  "alla",
  "alle",
  "con",
  "col",
  "coi",
  "da",
  "dal",
  "dallo",
  "dai",
  "dagli",
  "dall",
  "dagl",
  "dalla",
  "dalle",
  "di",
  "del",
  "dello",
  "dei",
  "degli",
  "dell",
  "degl",
  "della",
  "delle",
  "in",
  "nel",
  "nello",
  "nei",
  "negli",
  "nell",
  "negl",
  "nella",
  "nelle",
  "su",
  "sul",
  "sullo",
  "sui",
  "sugli",
  "sull",
  "sugl",
  "sulla",
  "sulle",
  "per",
  "tra",
  "contro",
  "io",
  "tu",
  "lui",
  "lei",
  "noi",
  "voi",
  "loro",
  "mio",
  "mia",
  "miei",
  "mie",
  "tuo",
  "tua",
  "tuoi",
  "tue",
  "suo",
  "sua",
  "suoi",
  "sue",
  "nostro",
  "nostra",
  "nostri",
  "nostre",
  "vostro",
  "vostra",
  "vostri",
  "vostre",
  "mi",
  "ti",
  "ci",
  "vi",
  "lo",
  "la",
  "li",
  "le",
  "gli",
  "ne",
  "il",
  "un",
  "uno",
  "una",
  "ma",
  "ed",
  "se",
  "perch\xE9",
  "anche",
  "come",
  "dov",
  "dove",
  "che",
  "chi",
  "cui",
  "non",
  "pi\xF9",
  "quale",
  "quanto",
  "quanti",
  "quanta",
  "quante",
  "quello",
  "quelli",
  "quella",
  "quelle",
  "questo",
  "questi",
  "questa",
  "queste",
  "si",
  "tutto",
  "tutti",
  "a",
  "c",
  "e",
  "i",
  "l",
  "o",
  "ho",
  "hai",
  "ha",
  "abbiamo",
  "avete",
  "hanno",
  "abbia",
  "abbiate",
  "abbiano",
  "avr\xF2",
  "avrai",
  "avr\xE0",
  "avremo",
  "avrete",
  "avranno",
  "avrei",
  "avresti",
  "avrebbe",
  "avremmo",
  "avreste",
  "avrebbero",
  "avevo",
  "avevi",
  "aveva",
  "avevamo",
  "avevate",
  "avevano",
  "ebbi",
  "avesti",
  "ebbe",
  "avemmo",
  "aveste",
  "ebbero",
  "avessi",
  "avesse",
  "avessimo",
  "avessero",
  "avendo",
  "avuto",
  "avuta",
  "avuti",
  "avute",
  "sono",
  "sei",
  "\xE8",
  "siamo",
  "siete",
  "sia",
  "siate",
  "siano",
  "sar\xF2",
  "sarai",
  "sar\xE0",
  "saremo",
  "sarete",
  "saranno",
  "sarei",
  "saresti",
  "sarebbe",
  "saremmo",
  "sareste",
  "sarebbero",
  "ero",
  "eri",
  "era",
  "eravamo",
  "eravate",
  "erano",
  "fui",
  "fosti",
  "fu",
  "fummo",
  "foste",
  "furono",
  "fossi",
  "fosse",
  "fossimo",
  "fossero",
  "essendo",
  "faccio",
  "fai",
  "facciamo",
  "fanno",
  "faccia",
  "facciate",
  "facciano",
  "far\xF2",
  "farai",
  "far\xE0",
  "faremo",
  "farete",
  "faranno",
  "farei",
  "faresti",
  "farebbe",
  "faremmo",
  "fareste",
  "farebbero",
  "facevo",
  "facevi",
  "faceva",
  "facevamo",
  "facevate",
  "facevano",
  "feci",
  "facesti",
  "fece",
  "facemmo",
  "faceste",
  "fecero",
  "facessi",
  "facesse",
  "facessimo",
  "facessero",
  "facendo",
  "sto",
  "stai",
  "sta",
  "stiamo",
  "stanno",
  "stia",
  "stiate",
  "stiano",
  "star\xF2",
  "starai",
  "star\xE0",
  "staremo",
  "starete",
  "staranno",
  "starei",
  "staresti",
  "starebbe",
  "staremmo",
  "stareste",
  "starebbero",
  "stavo",
  "stavi",
  "stava",
  "stavamo",
  "stavate",
  "stavano",
  "stetti",
  "stesti",
  "stette",
  "stemmo",
  "steste",
  "stettero",
  "stessi",
  "stesse",
  "stessimo",
  "stessero",
  "stando"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/fr.js
var fr = [
  "au",
  "aux",
  "avec",
  "ce",
  "ces",
  "dans",
  "de",
  "des",
  "du",
  "elle",
  "en",
  "et",
  "eux",
  "il",
  "je",
  "la",
  "le",
  "leur",
  "lui",
  "ma",
  "mais",
  "me",
  "m\xEAme",
  "mes",
  "moi",
  "mon",
  "ne",
  "nos",
  "notre",
  "nous",
  "on",
  "ou",
  "par",
  "pas",
  "pour",
  "qu",
  "que",
  "qui",
  "sa",
  "se",
  "ses",
  "son",
  "sur",
  "ta",
  "te",
  "tes",
  "toi",
  "ton",
  "tu",
  "un",
  "une",
  "vos",
  "votre",
  "vous",
  "c",
  "d",
  "j",
  "l",
  "\xE0",
  "m",
  "n",
  "s",
  "t",
  "y",
  "",
  "\xE9t\xE9",
  "\xE9t\xE9e",
  "\xE9t\xE9es",
  "\xE9t\xE9s",
  "\xE9tant",
  "suis",
  "es",
  "est",
  "sommes",
  "\xEAtes",
  "sont",
  "serai",
  "seras",
  "sera",
  "serons",
  "serez",
  "seront",
  "serais",
  "serait",
  "serions",
  "seriez",
  "seraient",
  "\xE9tais",
  "\xE9tait",
  "\xE9tions",
  "\xE9tiez",
  "\xE9taient",
  "fus",
  "fut",
  "f\xFBmes",
  "f\xFBtes",
  "furent",
  "sois",
  "soit",
  "soyons",
  "soyez",
  "soient",
  "fusse",
  "fusses",
  "f\xFBt",
  "fussions",
  "fussiez",
  "fussent",
  "ayant",
  "eu",
  "eue",
  "eues",
  "eus",
  "ai",
  "as",
  "avons",
  "avez",
  "ont",
  "aurai",
  "auras",
  "aura",
  "aurons",
  "aurez",
  "auront",
  "aurais",
  "aurait",
  "aurions",
  "auriez",
  "auraient",
  "avais",
  "avait",
  "avions",
  "aviez",
  "avaient",
  "eut",
  "e\xFBmes",
  "e\xFBtes",
  "eurent",
  "aie",
  "aies",
  "ait",
  "ayons",
  "ayez",
  "aient",
  "eusse",
  "eusses",
  "e\xFBt",
  "eussions",
  "eussiez",
  "eussent",
  "ceci",
  "cela",
  "cel\xE0",
  "cet",
  "cette",
  "ici",
  "ils",
  "les",
  "leurs",
  "quel",
  "quels",
  "quelle",
  "quelles",
  "sans",
  "soi"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/es.js
var es = [
  "de",
  "la",
  "que",
  "el",
  "en",
  "y",
  "a",
  "los",
  "del",
  "se",
  "las",
  "por",
  "un",
  "para",
  "con",
  "no",
  "una",
  "su",
  "al",
  "lo",
  "como",
  "m\xE1s",
  "pero",
  "sus",
  "le",
  "ya",
  "o",
  "este",
  "s\xED",
  "porque",
  "esta",
  "entre",
  "cuando",
  "muy",
  "sin",
  "sobre",
  "tambi\xE9n",
  "me",
  "hasta",
  "hay",
  "donde",
  "quien",
  "desde",
  "todo",
  "nos",
  "durante",
  "todos",
  "uno",
  "les",
  "ni",
  "contra",
  "otros",
  "ese",
  "eso",
  "ante",
  "ellos",
  "e",
  "esto",
  "m\xED",
  "antes",
  "algunos",
  "qu\xE9",
  "unos",
  "yo",
  "otro",
  "otras",
  "otra",
  "\xE9l",
  "tanto",
  "esa",
  "estos",
  "mucho",
  "quienes",
  "nada",
  "muchos",
  "cual",
  "poco",
  "ella",
  "estar",
  "estas",
  "algunas",
  "algo",
  "nosotros",
  "mi",
  "mis",
  "t\xFA",
  "te",
  "ti",
  "tu",
  "tus",
  "ellas",
  "nosotras",
  "vosotros",
  "vosotras",
  "os",
  "m\xEDo",
  "m\xEDa",
  "m\xEDos",
  "m\xEDas",
  "tuyo",
  "tuya",
  "tuyos",
  "tuyas",
  "suyo",
  "suya",
  "suyos",
  "suyas",
  "nuestro",
  "nuestra",
  "nuestros",
  "nuestras",
  "vuestro",
  "vuestra",
  "vuestros",
  "vuestras",
  "esos",
  "esas",
  "estoy",
  "est\xE1s",
  "est\xE1",
  "estamos",
  "est\xE1is",
  "est\xE1n",
  "est\xE9",
  "est\xE9s",
  "estemos",
  "est\xE9is",
  "est\xE9n",
  "estar\xE9",
  "estar\xE1s",
  "estar\xE1",
  "estaremos",
  "estar\xE9is",
  "estar\xE1n",
  "estar\xEDa",
  "estar\xEDas",
  "estar\xEDamos",
  "estar\xEDais",
  "estar\xEDan",
  "estaba",
  "estabas",
  "est\xE1bamos",
  "estabais",
  "estaban",
  "estuve",
  "estuviste",
  "estuvo",
  "estuvimos",
  "estuvisteis",
  "estuvieron",
  "estuviera",
  "estuvieras",
  "estuvi\xE9ramos",
  "estuvierais",
  "estuvieran",
  "estuviese",
  "estuvieses",
  "estuvi\xE9semos",
  "estuvieseis",
  "estuviesen",
  "estando",
  "estado",
  "estada",
  "estados",
  "estadas",
  "estad",
  "he",
  "has",
  "ha",
  "hemos",
  "hab\xE9is",
  "han",
  "haya",
  "hayas",
  "hayamos",
  "hay\xE1is",
  "hayan",
  "habr\xE9",
  "habr\xE1s",
  "habr\xE1",
  "habremos",
  "habr\xE9is",
  "habr\xE1n",
  "habr\xEDa",
  "habr\xEDas",
  "habr\xEDamos",
  "habr\xEDais",
  "habr\xEDan",
  "hab\xEDa",
  "hab\xEDas",
  "hab\xEDamos",
  "hab\xEDais",
  "hab\xEDan",
  "hube",
  "hubiste",
  "hubo",
  "hubimos",
  "hubisteis",
  "hubieron",
  "hubiera",
  "hubieras",
  "hubi\xE9ramos",
  "hubierais",
  "hubieran",
  "hubiese",
  "hubieses",
  "hubi\xE9semos",
  "hubieseis",
  "hubiesen",
  "habiendo",
  "habido",
  "habida",
  "habidos",
  "habidas",
  "soy",
  "eres",
  "es",
  "somos",
  "sois",
  "son",
  "sea",
  "seas",
  "seamos",
  "se\xE1is",
  "sean",
  "ser\xE9",
  "ser\xE1s",
  "ser\xE1",
  "seremos",
  "ser\xE9is",
  "ser\xE1n",
  "ser\xEDa",
  "ser\xEDas",
  "ser\xEDamos",
  "ser\xEDais",
  "ser\xEDan",
  "era",
  "eras",
  "\xE9ramos",
  "erais",
  "eran",
  "fui",
  "fuiste",
  "fue",
  "fuimos",
  "fuisteis",
  "fueron",
  "fuera",
  "fueras",
  "fu\xE9ramos",
  "fuerais",
  "fueran",
  "fuese",
  "fueses",
  "fu\xE9semos",
  "fueseis",
  "fuesen",
  "siendo",
  "sido",
  "tengo",
  "tienes",
  "tiene",
  "tenemos",
  "ten\xE9is",
  "tienen",
  "tenga",
  "tengas",
  "tengamos",
  "teng\xE1is",
  "tengan",
  "tendr\xE9",
  "tendr\xE1s",
  "tendr\xE1",
  "tendremos",
  "tendr\xE9is",
  "tendr\xE1n",
  "tendr\xEDa",
  "tendr\xEDas",
  "tendr\xEDamos",
  "tendr\xEDais",
  "tendr\xEDan",
  "ten\xEDa",
  "ten\xEDas",
  "ten\xEDamos",
  "ten\xEDais",
  "ten\xEDan",
  "tuve",
  "tuviste",
  "tuvo",
  "tuvimos",
  "tuvisteis",
  "tuvieron",
  "tuviera",
  "tuvieras",
  "tuvi\xE9ramos",
  "tuvierais",
  "tuvieran",
  "tuviese",
  "tuvieses",
  "tuvi\xE9semos",
  "tuvieseis",
  "tuviesen",
  "teniendo",
  "tenido",
  "tenida",
  "tenidos",
  "tenidas",
  "tened"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/pt.js
var pt = [
  "de",
  "a",
  "o",
  "que",
  "e",
  "do",
  "da",
  "em",
  "um",
  "para",
  "com",
  "n\xE3o",
  "uma",
  "os",
  "no",
  "se",
  "na",
  "por",
  "mais",
  "as",
  "dos",
  "como",
  "mas",
  "ao",
  "ele",
  "das",
  "\xE0",
  "seu",
  "sua",
  "ou",
  "quando",
  "muito",
  "nos",
  "j\xE1",
  "eu",
  "tamb\xE9m",
  "s\xF3",
  "pelo",
  "pela",
  "at\xE9",
  "isso",
  "ela",
  "entre",
  "depois",
  "sem",
  "mesmo",
  "aos",
  "seus",
  "quem",
  "nas",
  "me",
  "esse",
  "eles",
  "voc\xEA",
  "essa",
  "num",
  "nem",
  "suas",
  "meu",
  "\xE0s",
  "minha",
  "numa",
  "pelos",
  "elas",
  "qual",
  "n\xF3s",
  "lhe",
  "deles",
  "essas",
  "esses",
  "pelas",
  "este",
  "dele",
  "tu",
  "te",
  "voc\xEAs",
  "vos",
  "lhes",
  "meus",
  "minhas",
  "teu",
  "tua",
  "teus",
  "tuas",
  "nosso",
  "nossa",
  "nossos",
  "nossas",
  "dela",
  "delas",
  "esta",
  "estes",
  "estas",
  "aquele",
  "aquela",
  "aqueles",
  "aquelas",
  "isto",
  "aquilo",
  "estou",
  "est\xE1",
  "estamos",
  "est\xE3o",
  "estive",
  "esteve",
  "estivemos",
  "estiveram",
  "estava",
  "est\xE1vamos",
  "estavam",
  "estivera",
  "estiv\xE9ramos",
  "esteja",
  "estejamos",
  "estejam",
  "estivesse",
  "estiv\xE9ssemos",
  "estivessem",
  "estiver",
  "estivermos",
  "estiverem",
  "hei",
  "h\xE1",
  "havemos",
  "h\xE3o",
  "houve",
  "houvemos",
  "houveram",
  "houvera",
  "houv\xE9ramos",
  "haja",
  "hajamos",
  "hajam",
  "houvesse",
  "houv\xE9ssemos",
  "houvessem",
  "houver",
  "houvermos",
  "houverem",
  "houverei",
  "houver\xE1",
  "houveremos",
  "houver\xE3o",
  "houveria",
  "houver\xEDamos",
  "houveriam",
  "sou",
  "somos",
  "s\xE3o",
  "era",
  "\xE9ramos",
  "eram",
  "fui",
  "foi",
  "fomos",
  "foram",
  "fora",
  "f\xF4ramos",
  "seja",
  "sejamos",
  "sejam",
  "fosse",
  "f\xF4ssemos",
  "fossem",
  "for",
  "formos",
  "forem",
  "serei",
  "ser\xE1",
  "seremos",
  "ser\xE3o",
  "seria",
  "ser\xEDamos",
  "seriam",
  "tenho",
  "tem",
  "temos",
  "t\xE9m",
  "tinha",
  "t\xEDnhamos",
  "tinham",
  "tive",
  "teve",
  "tivemos",
  "tiveram",
  "tivera",
  "tiv\xE9ramos",
  "tenha",
  "tenhamos",
  "tenham",
  "tivesse",
  "tiv\xE9ssemos",
  "tivessem",
  "tiver",
  "tivermos",
  "tiverem",
  "terei",
  "ter\xE1",
  "teremos",
  "ter\xE3o",
  "teria",
  "ter\xEDamos",
  "teriam"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/nl.js
var nl = [
  "de",
  "en",
  "van",
  "ik",
  "te",
  "dat",
  "die",
  "in",
  "een",
  "hij",
  "het",
  "niet",
  "zijn",
  "is",
  "was",
  "op",
  "aan",
  "met",
  "als",
  "voor",
  "had",
  "er",
  "maar",
  "om",
  "hem",
  "dan",
  "zou",
  "of",
  "wat",
  "mijn",
  "men",
  "dit",
  "zo",
  "door",
  "over",
  "ze",
  "zich",
  "bij",
  "ook",
  "tot",
  "je",
  "mij",
  "uit",
  "der",
  "daar",
  "haar",
  "naar",
  "heb",
  "hoe",
  "heeft",
  "hebben",
  "deze",
  "u",
  "want",
  "nog",
  "zal",
  "me",
  "zij",
  "nu",
  "ge",
  "geen",
  "omdat",
  "iets",
  "worden",
  "toch",
  "al",
  "waren",
  "veel",
  "meer",
  "doen",
  "toen",
  "moet",
  "ben",
  "zonder",
  "kan",
  "hun",
  "dus",
  "alles",
  "onder",
  "ja",
  "eens",
  "hier",
  "wie",
  "werd",
  "altijd",
  "doch",
  "wordt",
  "wezen",
  "kunnen",
  "ons",
  "zelf",
  "tegen",
  "na",
  "reeds",
  "wil",
  "kon",
  "niets",
  "uw",
  "iemand",
  "geweest",
  "andere"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/se.js
var se = [
  "och",
  "det",
  "att",
  "i",
  "en",
  "jag",
  "hon",
  "som",
  "han",
  "p\xE5",
  "den",
  "med",
  "var",
  "sig",
  "f\xF6r",
  "s\xE5",
  "till",
  "\xE4r",
  "men",
  "ett",
  "om",
  "hade",
  "de",
  "av",
  "icke",
  "mig",
  "du",
  "henne",
  "d\xE5",
  "sin",
  "nu",
  "har",
  "inte",
  "hans",
  "honom",
  "skulle",
  "hennes",
  "d\xE4r",
  "min",
  "man",
  "ej",
  "vid",
  "kunde",
  "n\xE5got",
  "fr\xE5n",
  "ut",
  "n\xE4r",
  "efter",
  "upp",
  "vi",
  "dem",
  "vara",
  "vad",
  "\xF6ver",
  "\xE4n",
  "dig",
  "kan",
  "sina",
  "h\xE4r",
  "ha",
  "mot",
  "alla",
  "under",
  "n\xE5gon",
  "eller",
  "allt",
  "mycket",
  "sedan",
  "ju",
  "denna",
  "sj\xE4lv",
  "detta",
  "\xE5t",
  "utan",
  "varit",
  "hur",
  "ingen",
  "mitt",
  "ni",
  "bli",
  "blev",
  "oss",
  "din",
  "dessa",
  "n\xE5gra",
  "deras",
  "blir",
  "mina",
  "samma",
  "vilken",
  "er",
  "s\xE5dan",
  "v\xE5r",
  "blivit",
  "dess",
  "inom",
  "mellan",
  "s\xE5dant",
  "varf\xF6r",
  "varje",
  "vilka",
  "ditt",
  "vem",
  "vilket",
  "sitta",
  "s\xE5dana",
  "vart",
  "dina",
  "vars",
  "v\xE5rt",
  "v\xE5ra",
  "ert",
  "era",
  "vilkas"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/ru.js
var ru = [
  "\u0438",
  "\u0432",
  "\u0432\u043E",
  "\u043D\u0435",
  "\u0447\u0442\u043E",
  "\u043E\u043D",
  "\u043D\u0430",
  "\u044F",
  "\u0441",
  "\u0441\u043E",
  "\u043A\u0430\u043A",
  "\u0430",
  "\u0442\u043E",
  "\u0432\u0441\u0435",
  "\u043E\u043D\u0430",
  "\u0442\u0430\u043A",
  "\u0435\u0433\u043E",
  "\u043D\u043E",
  "\u0434\u0430",
  "\u0442\u044B",
  "\u043A",
  "\u0443",
  "\u0436\u0435",
  "\u0432\u044B",
  "\u0437\u0430",
  "\u0431\u044B",
  "\u043F\u043E",
  "\u0442\u043E\u043B\u044C\u043A\u043E",
  "\u0435\u0435",
  "\u043C\u043D\u0435",
  "\u0431\u044B\u043B\u043E",
  "\u0432\u043E\u0442",
  "\u043E\u0442",
  "\u043C\u0435\u043D\u044F",
  "\u0435\u0449\u0435",
  "\u043D\u0435\u0442",
  "\u043E",
  "\u0438\u0437",
  "\u0435\u043C\u0443",
  "\u0442\u0435\u043F\u0435\u0440\u044C",
  "\u043A\u043E\u0433\u0434\u0430",
  "\u0434\u0430\u0436\u0435",
  "\u043D\u0443",
  "\u0432\u0434\u0440\u0443\u0433",
  "\u043B\u0438",
  "\u0435\u0441\u043B\u0438",
  "\u0443\u0436\u0435",
  "\u0438\u043B\u0438",
  "\u043D\u0438",
  "\u0431\u044B\u0442\u044C",
  "\u0431\u044B\u043B",
  "\u043D\u0435\u0433\u043E",
  "\u0434\u043E",
  "\u0432\u0430\u0441",
  "\u043D\u0438\u0431\u0443\u0434\u044C",
  "\u043E\u043F\u044F\u0442\u044C",
  "\u0443\u0436",
  "\u0432\u0430\u043C",
  "\u0441\u043A\u0430\u0437\u0430\u043B",
  "\u0432\u0435\u0434\u044C",
  "\u0442\u0430\u043C",
  "\u043F\u043E\u0442\u043E\u043C",
  "\u0441\u0435\u0431\u044F",
  "\u043D\u0438\u0447\u0435\u0433\u043E",
  "\u0435\u0439",
  "\u043C\u043E\u0436\u0435\u0442",
  "\u043E\u043D\u0438",
  "\u0442\u0443\u0442",
  "\u0433\u0434\u0435",
  "\u0435\u0441\u0442\u044C",
  "\u043D\u0430\u0434\u043E",
  "\u043D\u0435\u0439",
  "\u0434\u043B\u044F",
  "\u043C\u044B",
  "\u0442\u0435\u0431\u044F",
  "\u0438\u0445",
  "\u0447\u0435\u043C",
  "\u0431\u044B\u043B\u0430",
  "\u0441\u0430\u043C",
  "\u0447\u0442\u043E\u0431",
  "\u0431\u0435\u0437",
  "\u0431\u0443\u0434\u0442\u043E",
  "\u0447\u0435\u043B\u043E\u0432\u0435\u043A",
  "\u0447\u0435\u0433\u043E",
  "\u0440\u0430\u0437",
  "\u0442\u043E\u0436\u0435",
  "\u0441\u0435\u0431\u0435",
  "\u043F\u043E\u0434",
  "\u0436\u0438\u0437\u043D\u044C",
  "\u0431\u0443\u0434\u0435\u0442",
  "\u0436",
  "\u0442\u043E\u0433\u0434\u0430",
  "\u043A\u0442\u043E",
  "\u044D\u0442\u043E\u0442",
  "\u0433\u043E\u0432\u043E\u0440\u0438\u043B",
  "\u0442\u043E\u0433\u043E",
  "\u043F\u043E\u0442\u043E\u043C\u0443",
  "\u044D\u0442\u043E\u0433\u043E",
  "\u043A\u0430\u043A\u043E\u0439",
  "\u0441\u043E\u0432\u0441\u0435\u043C",
  "\u043D\u0438\u043C",
  "\u0437\u0434\u0435\u0441\u044C",
  "\u044D\u0442\u043E\u043C",
  "\u043E\u0434\u0438\u043D",
  "\u043F\u043E\u0447\u0442\u0438",
  "\u043C\u043E\u0439",
  "\u0442\u0435\u043C",
  "\u0447\u0442\u043E\u0431\u044B",
  "\u043D\u0435\u0435",
  "\u043A\u0430\u0436\u0435\u0442\u0441\u044F",
  "\u0441\u0435\u0439\u0447\u0430\u0441",
  "\u0431\u044B\u043B\u0438",
  "\u043A\u0443\u0434\u0430",
  "\u0437\u0430\u0447\u0435\u043C",
  "\u0441\u043A\u0430\u0437\u0430\u0442\u044C",
  "\u0432\u0441\u0435\u0445",
  "\u043D\u0438\u043A\u043E\u0433\u0434\u0430",
  "\u0441\u0435\u0433\u043E\u0434\u043D\u044F",
  "\u043C\u043E\u0436\u043D\u043E",
  "\u043F\u0440\u0438",
  "\u043D\u0430\u043A\u043E\u043D\u0435\u0446",
  "\u0434\u0432\u0430",
  "\u043E\u0431",
  "\u0434\u0440\u0443\u0433\u043E\u0439",
  "\u0445\u043E\u0442\u044C",
  "\u043F\u043E\u0441\u043B\u0435",
  "\u043D\u0430\u0434",
  "\u0431\u043E\u043B\u044C\u0448\u0435",
  "\u0442\u043E\u0442",
  "\u0447\u0435\u0440\u0435\u0437",
  "\u044D\u0442\u0438",
  "\u043D\u0430\u0441",
  "\u043F\u0440\u043E",
  "\u0432\u0441\u0435\u0433\u043E",
  "\u043D\u0438\u0445",
  "\u043A\u0430\u043A\u0430\u044F",
  "\u043C\u043D\u043E\u0433\u043E",
  "\u0440\u0430\u0437\u0432\u0435",
  "\u0441\u043A\u0430\u0437\u0430\u043B\u0430",
  "\u0442\u0440\u0438",
  "\u044D\u0442\u0443",
  "\u043C\u043E\u044F",
  "\u0432\u043F\u0440\u043E\u0447\u0435\u043C",
  "\u0445\u043E\u0440\u043E\u0448\u043E",
  "\u0441\u0432\u043E\u044E",
  "\u044D\u0442\u043E\u0439",
  "\u043F\u0435\u0440\u0435\u0434",
  "\u0438\u043D\u043E\u0433\u0434\u0430",
  "\u043B\u0443\u0447\u0448\u0435",
  "\u0447\u0443\u0442\u044C",
  "\u0442\u043E\u043C",
  "\u043D\u0435\u043B\u044C\u0437\u044F",
  "\u0442\u0430\u043A\u043E\u0439",
  "\u0438\u043C",
  "\u0431\u043E\u043B\u0435\u0435",
  "\u0432\u0441\u0435\u0433\u0434\u0430",
  "\u043A\u043E\u043D\u0435\u0447\u043D\u043E",
  "\u0432\u0441\u044E",
  "\u043C\u0435\u0436\u0434\u0443"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/no.js
var no = [
  "og",
  "i",
  "jeg",
  "det",
  "at",
  "en",
  "et",
  "den",
  "til",
  "er",
  "som",
  "p\xE5",
  "de",
  "med",
  "han",
  "av",
  "ikke",
  "ikkje",
  "der",
  "s\xE5",
  "var",
  "meg",
  "seg",
  "men",
  "ett",
  "har",
  "om",
  "vi",
  "min",
  "mitt",
  "ha",
  "hadde",
  "hun",
  "n\xE5",
  "over",
  "da",
  "ved",
  "fra",
  "du",
  "ut",
  "sin",
  "dem",
  "oss",
  "opp",
  "man",
  "kan",
  "hans",
  "hvor",
  "eller",
  "hva",
  "skal",
  "selv",
  "sj\xF8l",
  "her",
  "alle",
  "vil",
  "bli",
  "ble",
  "blei",
  "blitt",
  "kunne",
  "inn",
  "n\xE5r",
  "v\xE6re",
  "kom",
  "noen",
  "noe",
  "ville",
  "dere",
  "som",
  "deres",
  "kun",
  "ja",
  "etter",
  "ned",
  "skulle",
  "denne",
  "for",
  "deg",
  "si",
  "sine",
  "sitt",
  "mot",
  "\xE5",
  "meget",
  "hvorfor",
  "dette",
  "disse",
  "uten",
  "hvordan",
  "ingen",
  "din",
  "ditt",
  "blir",
  "samme",
  "hvilken",
  "hvilke",
  "s\xE5nn",
  "inni",
  "mellom",
  "v\xE5r",
  "hver",
  "hvem",
  "vors",
  "hvis",
  "b\xE5de",
  "bare",
  "enn",
  "fordi",
  "f\xF8r",
  "mange",
  "ogs\xE5",
  "slik",
  "v\xE6rt",
  "v\xE6re",
  "b\xE5e",
  "begge",
  "siden",
  "dykk",
  "dykkar",
  "dei",
  "deira",
  "deires",
  "deim",
  "di",
  "d\xE5",
  "eg",
  "ein",
  "eit",
  "eitt",
  "elles",
  "honom",
  "hj\xE5",
  "ho",
  "hoe",
  "henne",
  "hennar",
  "hennes",
  "hoss",
  "hossen",
  "ikkje",
  "ingi",
  "inkje",
  "korleis",
  "korso",
  "kva",
  "kvar",
  "kvarhelst",
  "kven",
  "kvi",
  "kvifor",
  "me",
  "medan",
  "mi",
  "mine",
  "mykje",
  "no",
  "nokon",
  "noka",
  "nokor",
  "noko",
  "nokre",
  "si",
  "sia",
  "sidan",
  "so",
  "somt",
  "somme",
  "um",
  "upp",
  "vere",
  "vore",
  "verte",
  "vort",
  "varte",
  "vart"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/de.js
var de = [
  "aber",
  "alle",
  "allem",
  "allen",
  "aller",
  "alles",
  "als",
  "also",
  "am",
  "an",
  "ander",
  "andere",
  "anderem",
  "anderen",
  "anderer",
  "anderes",
  "anderm",
  "andern",
  "anderr",
  "anders",
  "auch",
  "auf",
  "aus",
  "bei",
  "bin",
  "bis",
  "bist",
  "da",
  "damit",
  "dann",
  "der",
  "den",
  "des",
  "dem",
  "die",
  "das",
  "da\xDF",
  "derselbe",
  "derselben",
  "denselben",
  "desselben",
  "demselben",
  "dieselbe",
  "dieselben",
  "dasselbe",
  "dazu",
  "dein",
  "deine",
  "deinem",
  "deinen",
  "deiner",
  "deines",
  "denn",
  "derer",
  "dessen",
  "dich",
  "dir",
  "du",
  "dies",
  "diese",
  "diesem",
  "diesen",
  "dieser",
  "dieses",
  "doch",
  "dort",
  "durch",
  "ein",
  "eine",
  "einem",
  "einen",
  "einer",
  "eines",
  "einig",
  "einige",
  "einigem",
  "einigen",
  "einiger",
  "einiges",
  "einmal",
  "er",
  "ihn",
  "ihm",
  "es",
  "etwas",
  "euer",
  "eure",
  "eurem",
  "euren",
  "eurer",
  "eures",
  "f\xFCr",
  "gegen",
  "gewesen",
  "hab",
  "habe",
  "haben",
  "hat",
  "hatte",
  "hatten",
  "hier",
  "hin",
  "hinter",
  "ich",
  "mich",
  "mir",
  "ihr",
  "ihre",
  "ihrem",
  "ihren",
  "ihrer",
  "ihres",
  "euch",
  "im",
  "in",
  "indem",
  "ins",
  "ist",
  "jede",
  "jedem",
  "jeden",
  "jeder",
  "jedes",
  "jene",
  "jenem",
  "jenen",
  "jener",
  "jenes",
  "jetzt",
  "kann",
  "kein",
  "keine",
  "keinem",
  "keinen",
  "keiner",
  "keines",
  "k\xF6nnen",
  "k\xF6nnte",
  "machen",
  "man",
  "manche",
  "manchem",
  "manchen",
  "mancher",
  "manches",
  "mein",
  "meine",
  "meinem",
  "meinen",
  "meiner",
  "meines",
  "mit",
  "muss",
  "musste",
  "nach",
  "nicht",
  "nichts",
  "noch",
  "nun",
  "nur",
  "ob",
  "oder",
  "ohne",
  "sehr",
  "sein",
  "seine",
  "seinem",
  "seinen",
  "seiner",
  "seines",
  "selbst",
  "sich",
  "sie",
  "ihnen",
  "sind",
  "so",
  "solche",
  "solchem",
  "solchen",
  "solcher",
  "solches",
  "soll",
  "sollte",
  "sondern",
  "sonst",
  "\xFCber",
  "um",
  "und",
  "uns",
  "unse",
  "unsem",
  "unsen",
  "unser",
  "unses",
  "unter",
  "viel",
  "vom",
  "von",
  "vor",
  "w\xE4hrend",
  "war",
  "waren",
  "warst",
  "was",
  "weg",
  "weil",
  "weiter",
  "welche",
  "welchem",
  "welchen",
  "welcher",
  "welches",
  "wenn",
  "werde",
  "werden",
  "wie",
  "wieder",
  "will",
  "wir",
  "wird",
  "wirst",
  "wo",
  "wollen",
  "wollte",
  "w\xFCrde",
  "w\xFCrden",
  "zu",
  "zum",
  "zur",
  "zwar",
  "zwischen"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/dk.js
var dk = [
  "og",
  "i",
  "jeg",
  "det",
  "at",
  "en",
  "den",
  "til",
  "er",
  "som",
  "p\xE5",
  "de",
  "med",
  "han",
  "af",
  "for",
  "ikke",
  "der",
  "var",
  "mig",
  "sig",
  "men",
  "et",
  "har",
  "om",
  "vi",
  "min",
  "havde",
  "ham",
  "hun",
  "nu",
  "over",
  "da",
  "fra",
  "du",
  "ud",
  "sin",
  "dem",
  "os",
  "op",
  "man",
  "hans",
  "hvor",
  "eller",
  "hvad",
  "skal",
  "selv",
  "her",
  "alle",
  "vil",
  "blev",
  "kunne",
  "ind",
  "n\xE5r",
  "v\xE6re",
  "dog",
  "noget",
  "ville",
  "jo",
  "deres",
  "efter",
  "ned",
  "skulle",
  "denne",
  "end",
  "dette",
  "mit",
  "ogs\xE5",
  "under",
  "have",
  "dig",
  "anden",
  "hende",
  "mine",
  "alt",
  "meget",
  "sit",
  "sine",
  "vor",
  "mod",
  "disse",
  "hvis",
  "din",
  "nogle",
  "hos",
  "blive",
  "mange",
  "ad",
  "bliver",
  "hendes",
  "v\xE6ret",
  "thi",
  "jer",
  "s\xE5dan"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/fi.js
var fi = [
  "olla",
  "olen",
  "olet",
  "on",
  "olemme",
  "olette",
  "ovat",
  "ole",
  "oli",
  "olisi",
  "olisit",
  "olisin",
  "olisimme",
  "olisitte",
  "olisivat",
  "olit",
  "olin",
  "olimme",
  "olitte",
  "olivat",
  "ollut",
  "olleet",
  "en",
  "et",
  "ei",
  "emme",
  "ette",
  "eiv\xE4t",
  "min\xE4",
  "minun",
  "minut",
  "minua",
  "minussa",
  "minusta",
  "minuun",
  "minulla",
  "minulta",
  "minulle",
  "sin\xE4",
  "sinun",
  "sinut",
  "sinua",
  "sinussa",
  "sinusta",
  "sinuun",
  "sinulla",
  "sinulta",
  "sinulle",
  "h\xE4n",
  "h\xE4nen",
  "h\xE4net",
  "h\xE4nt\xE4",
  "h\xE4ness\xE4",
  "h\xE4nest\xE4",
  "h\xE4neen",
  "h\xE4nell\xE4",
  "h\xE4nelt\xE4",
  "h\xE4nelle",
  "me",
  "meid\xE4n",
  "meid\xE4t",
  "meit\xE4",
  "meiss\xE4",
  "meist\xE4",
  "meihin",
  "meill\xE4",
  "meilt\xE4",
  "meille",
  "te",
  "teid\xE4n",
  "teid\xE4t",
  "teit\xE4",
  "teiss\xE4",
  "teist\xE4",
  "teihin",
  "teill\xE4",
  "teilt\xE4",
  "teille",
  "he",
  "heid\xE4n",
  "heid\xE4t",
  "heit\xE4",
  "heiss\xE4",
  "heist\xE4",
  "heihin",
  "heill\xE4",
  "heilt\xE4",
  "heille",
  "t\xE4m\xE4",
  "t\xE4m\xE4n",
  "t\xE4t\xE4",
  "t\xE4ss\xE4",
  "t\xE4st\xE4",
  "t\xE4h\xE4n",
  "t\xE4ll\xE4",
  "t\xE4lt\xE4",
  "t\xE4lle",
  "t\xE4n\xE4",
  "t\xE4ksi",
  "tuo",
  "tuon",
  "tuota",
  "tuossa",
  "tuosta",
  "tuohon",
  "tuolla",
  "tuolta",
  "tuolle",
  "tuona",
  "tuoksi",
  "se",
  "sen",
  "sit\xE4",
  "siin\xE4",
  "siit\xE4",
  "siihen",
  "sill\xE4",
  "silt\xE4",
  "sille",
  "sin\xE4",
  "siksi",
  "n\xE4m\xE4",
  "n\xE4iden",
  "n\xE4it\xE4",
  "n\xE4iss\xE4",
  "n\xE4ist\xE4",
  "n\xE4ihin",
  "n\xE4ill\xE4",
  "n\xE4ilt\xE4",
  "n\xE4ille",
  "n\xE4in\xE4",
  "n\xE4iksi",
  "nuo",
  "noiden",
  "noita",
  "noissa",
  "noista",
  "noihin",
  "noilla",
  "noilta",
  "noille",
  "noina",
  "noiksi",
  "ne",
  "niiden",
  "niit\xE4",
  "niiss\xE4",
  "niist\xE4",
  "niihin",
  "niill\xE4",
  "niilt\xE4",
  "niille",
  "niin\xE4",
  "niiksi",
  "kuka",
  "kenen",
  "kenet",
  "ket\xE4",
  "keness\xE4",
  "kenest\xE4",
  "keneen",
  "kenell\xE4",
  "kenelt\xE4",
  "kenelle",
  "kenen\xE4",
  "keneksi",
  "ketk\xE4",
  "keiden",
  "ketk\xE4",
  "keit\xE4",
  "keiss\xE4",
  "keist\xE4",
  "keihin",
  "keill\xE4",
  "keilt\xE4",
  "keille",
  "kein\xE4",
  "keiksi",
  "mik\xE4",
  "mink\xE4",
  "mink\xE4",
  "mit\xE4",
  "miss\xE4",
  "mist\xE4",
  "mihin",
  "mill\xE4",
  "milt\xE4",
  "mille",
  "min\xE4",
  "miksi",
  "mitk\xE4",
  "joka",
  "jonka",
  "jota",
  "jossa",
  "josta",
  "johon",
  "jolla",
  "jolta",
  "jolle",
  "jona",
  "joksi",
  "jotka",
  "joiden",
  "joita",
  "joissa",
  "joista",
  "joihin",
  "joilla",
  "joilta",
  "joille",
  "joina",
  "joiksi",
  "ett\xE4",
  "ja",
  "jos",
  "koska",
  "kuin",
  "mutta",
  "niin",
  "sek\xE4",
  "sill\xE4",
  "tai",
  "vaan",
  "vai",
  "vaikka",
  "kanssa",
  "mukaan",
  "noin",
  "poikki",
  "yli",
  "kun",
  "niin",
  "nyt",
  "itse"
];

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/stop-words/index.js
var stopWords = {
  english: en,
  italian: it,
  french: fr,
  spanish: es,
  portuguese: pt,
  dutch: nl,
  swedish: se,
  russian: ru,
  norwegian: no,
  german: de,
  danish: dk,
  finnish: fi
};
var availableStopWords = Object.keys(stopWords);

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/english-stemmer.js
var step2List = {
  ational: "ate",
  tional: "tion",
  enci: "ence",
  anci: "ance",
  izer: "ize",
  bli: "ble",
  alli: "al",
  entli: "ent",
  eli: "e",
  ousli: "ous",
  ization: "ize",
  ation: "ate",
  ator: "ate",
  alism: "al",
  iveness: "ive",
  fulness: "ful",
  ousness: "ous",
  aliti: "al",
  iviti: "ive",
  biliti: "ble",
  logi: "log"
};
var step3List = {
  icate: "ic",
  ative: "",
  alize: "al",
  iciti: "ic",
  ical: "ic",
  ful: "",
  ness: ""
};
var c = "[^aeiou]";
var v = "[aeiouy]";
var C = c + "[^aeiouy]*";
var V = v + "[aeiou]*";
var mgr0 = "^(" + C + ")?" + V + C;
var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";
var mgr1 = "^(" + C + ")?" + V + C + V + C;
var s_v = "^(" + C + ")?" + v;
function stemmer(w) {
  var _a2, _b;
  let stem;
  let suffix;
  let re;
  let re2;
  let re3;
  let re4;
  if (w.length < 3) {
    return w;
  }
  const firstch = w.substring(0, 1);
  if (firstch == "y") {
    w = firstch.toUpperCase() + w.substring(1);
  }
  re = /^(.+?)(ss|i)es$/;
  re2 = /^(.+?)([^s])s$/;
  if (re.test(w)) {
    w = w.replace(re, "$1$2");
  } else if (re2.test(w)) {
    w = w.replace(re2, "$1$2");
  }
  re = /^(.+?)eed$/;
  re2 = /^(.+?)(ed|ing)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    re = new RegExp(mgr0);
    if (re.test(fp[1])) {
      re = /.$/;
      w = w.replace(re, "");
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = fp[1];
    re2 = new RegExp(s_v);
    if (re2.test(stem)) {
      w = stem;
      re2 = /(at|bl|iz)$/;
      re3 = new RegExp("([^aeiouylsz])\\1$");
      re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
      if (re2.test(w)) {
        w = w + "e";
      } else if (re3.test(w)) {
        re = /.$/;
        w = w.replace(re, "");
      } else if (re4.test(w)) {
        w = w + "e";
      }
    }
  }
  re = /^(.+?)y$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(s_v);
    if (stem && re.test(stem)) {
      w = stem + "i";
    }
  }
  re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    suffix = fp === null || fp === void 0 ? void 0 : fp[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step2List[suffix];
    }
  }
  re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    suffix = fp === null || fp === void 0 ? void 0 : fp[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step3List[suffix];
    }
  }
  re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
  re2 = /^(.+?)(s|t)(ion)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(mgr1);
    if (stem && re.test(stem)) {
      w = stem;
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = (_b = (_a2 = fp === null || fp === void 0 ? void 0 : fp[1]) != null ? _a2 : "" + (fp === null || fp === void 0 ? void 0 : fp[2])) != null ? _b : "";
    re2 = new RegExp(mgr1);
    if (re2.test(stem)) {
      w = stem;
    }
  }
  re = /^(.+?)e$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp === null || fp === void 0 ? void 0 : fp[1];
    re = new RegExp(mgr1);
    re2 = new RegExp(meq1);
    re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
    if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {
      w = stem;
    }
  }
  re = /ll$/;
  re2 = new RegExp(mgr1);
  if (re.test(w) && re2.test(w)) {
    re = /.$/;
    w = w.replace(re, "");
  }
  if (firstch == "y") {
    w = firstch.toLowerCase() + w.substring(1);
  }
  return w;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/tokenizer/index.js
function normalizeToken(prop, token) {
  var _this_stopWords;
  const key = `${this.language}:${prop}:${token}`;
  if (this.normalizationCache.has(key)) {
    return this.normalizationCache.get(key);
  }
  if ((_this_stopWords = this.stopWords) === null || _this_stopWords === void 0 ? void 0 : _this_stopWords.includes(token)) {
    this.normalizationCache.set(key, "");
    return "";
  }
  if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
    token = this.stemmer(token);
  }
  token = replaceDiacritics(token);
  this.normalizationCache.set(key, token);
  return token;
}
function trim(text) {
  while (text[text.length - 1] === "") {
    text.pop();
  }
  while (text[0] === "") {
    text.shift();
  }
  return text;
}
function tokenize(input, language, prop) {
  if (language && language !== this.language) {
    throw createError("LANGUAGE_NOT_SUPPORTED", language);
  }
  if (typeof input !== "string") {
    return [
      input
    ];
  }
  const splitRule = SPLITTERS[this.language];
  const tokens = input.toLowerCase().split(splitRule).map(this.normalizeToken.bind(this, prop != null ? prop : "")).filter(Boolean);
  const trimTokens = trim(tokens);
  if (!this.allowDuplicates) {
    return Array.from(new Set(trimTokens));
  }
  return trimTokens;
}
async function createTokenizer(config = {}) {
  var _a2;
  if (!config.language) {
    config.language = "english";
  } else if (!SUPPORTED_LANGUAGES.includes(config.language)) {
    throw createError("LANGUAGE_NOT_SUPPORTED", config.language);
  }
  let stemmer2;
  if (config.stemming || config.stemmer && !("stemming" in config)) {
    if (config.stemmer) {
      if (typeof config.stemmer !== "function") {
        throw createError("INVALID_STEMMER_FUNCTION_TYPE");
      }
      stemmer2 = config.stemmer;
    } else {
      if (config.language === "english") {
        stemmer2 = stemmer;
      } else {
        throw createError("MISSING_STEMMER", config.language);
      }
    }
  }
  let stopWords2;
  if (config.stopWords !== false) {
    stopWords2 = (_a2 = stopWords[config.language]) != null ? _a2 : [];
    if (Array.isArray(config.stopWords)) {
      stopWords2 = config.stopWords;
    } else if (typeof config.stopWords === "function") {
      stopWords2 = await config.stopWords(stopWords2);
    } else if (config.stopWords) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    if (!Array.isArray(stopWords2)) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    for (const s of stopWords2) {
      if (typeof s !== "string") {
        throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
      }
    }
  }
  const tokenizer = {
    tokenize,
    language: config.language,
    stemmer: stemmer2,
    stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [
      config.stemmerSkipProperties
    ].flat() : []),
    stopWords: stopWords2,
    allowDuplicates: Boolean(config.allowDuplicates),
    normalizeToken,
    normalizationCache: /* @__PURE__ */ new Map()
  };
  tokenizer.tokenize = tokenize.bind(tokenizer);
  tokenizer.normalizeToken = normalizeToken;
  return tokenizer;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/methods/create.js
function validateComponents(components) {
  const defaultComponents = {
    formatElapsedTime,
    getDocumentIndexId,
    getDocumentProperties,
    validateSchema
  };
  for (const rawKey of FUNCTION_COMPONENTS) {
    const key = rawKey;
    if (components[key]) {
      if (typeof components[key] !== "function") {
        throw createError("COMPONENT_MUST_BE_FUNCTION", key);
      }
    } else {
      components[key] = defaultComponents[key];
    }
  }
  for (const rawKey of SINGLE_OR_ARRAY_COMPONENTS) {
    const key = rawKey;
    if (!components[key]) {
      components[key] = [];
    } else if (!Array.isArray(components[key])) {
      components[key] = [
        components[key]
      ];
    }
    for (const fn of components[key]) {
      if (typeof fn !== "function") {
        throw createError("COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS", key);
      }
    }
  }
  for (const rawKey of Object.keys(components)) {
    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey) && !SINGLE_OR_ARRAY_COMPONENTS.includes(rawKey)) {
      throw createError("UNSUPPORTED_COMPONENT", rawKey);
    }
  }
}
async function create5({ schema, language, components, id }) {
  if (!components) {
    components = {};
  }
  if (!id) {
    id = await uniqueId();
  }
  let tokenizer = components.tokenizer;
  let index = components.index;
  let documentsStore = components.documentsStore;
  if (!tokenizer) {
    tokenizer = await createTokenizer({
      language: language != null ? language : "english"
    });
  } else if (!tokenizer.tokenize) {
    tokenizer = await createTokenizer(tokenizer);
  }
  if (components.tokenizer && language) {
    throw createError("NO_LANGUAGE_WITH_CUSTOM_TOKENIZER");
  }
  if (!index) {
    index = await createIndex();
  }
  if (!documentsStore) {
    documentsStore = await createDocumentsStore();
  }
  validateComponents(components);
  const { getDocumentProperties: getDocumentProperties2, getDocumentIndexId: getDocumentIndexId2, validateSchema: validateSchema2, beforeInsert, afterInsert, beforeRemove, afterRemove, beforeMultipleInsert, afterMultipleInsert, beforeMultipleRemove, afterMultipleRemove, formatElapsedTime: formatElapsedTime2 } = components;
  const orama = {
    data: {},
    caches: {},
    schema,
    tokenizer,
    index,
    documentsStore,
    getDocumentProperties: getDocumentProperties2,
    getDocumentIndexId: getDocumentIndexId2,
    validateSchema: validateSchema2,
    beforeInsert,
    afterInsert,
    beforeRemove,
    afterRemove,
    beforeMultipleInsert,
    afterMultipleInsert,
    beforeMultipleRemove,
    afterMultipleRemove,
    formatElapsedTime: formatElapsedTime2,
    id
  };
  orama.data = {
    index: await orama.index.create(orama, schema),
    docs: await orama.documentsStore.create(orama)
  };
  return orama;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/types.js
var kInsertions = Symbol("orama.insertions");
var kRemovals = Symbol("orama.removals");

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/sync-blocking-checker.js
var _globalThis_process;
var _a;
var warn = (_a = (_globalThis_process = globalThis.process) === null || _globalThis_process === void 0 ? void 0 : _globalThis_process.emitWarning) != null ? _a : function emitWarning(message, options) {
  console.warn(`[WARNING] [${options.code}] ${message}`);
};
function trackInsertion(orama) {
  if (typeof orama[kInsertions] !== "number") {
    queueMicrotask(() => {
      orama[kInsertions] = void 0;
    });
    orama[kInsertions] = 0;
  }
  if (orama[kInsertions] > 1e3) {
    warn("Orama's insert operation is synchronous. Please avoid inserting a large number of document in a single operation in order not to block the main thread or, in alternative, please use insertMultiple.", {
      code: "ORAMA0001"
    });
    orama[kInsertions] = -1;
  } else if (orama[kInsertions] >= 0) {
    orama[kInsertions]++;
  }
}
function trackRemoval(orama) {
  if (typeof orama[kRemovals] !== "number") {
    queueMicrotask(() => {
      orama[kRemovals] = void 0;
    });
    orama[kRemovals] = 0;
  }
  if (orama[kRemovals] > 1e3) {
    warn("Orama's remove operation is synchronous. Please avoid removing a large number of document in a single operation in order not to block the main thread, in alternative, please use updateMultiple.", {
      code: "ORAMA0002"
    });
    orama[kRemovals] = -1;
  } else if (orama[kRemovals] >= 0) {
    orama[kRemovals]++;
  }
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/methods/insert.js
async function insert4(orama, doc, language, skipHooks) {
  await orama.validateSchema(doc, orama.schema);
  const { index, docs } = orama.data;
  const id = await orama.getDocumentIndexId(doc);
  if (typeof id !== "string") {
    throw createError("DOCUMENT_ID_MUST_BE_STRING", typeof id);
  }
  if (!await orama.documentsStore.store(docs, id, doc)) {
    throw createError("DOCUMENT_ALREADY_EXISTS", id);
  }
  const docsCount = await orama.documentsStore.count(docs);
  if (!skipHooks) {
    await runSingleHook(orama.beforeInsert, orama, id, doc);
  }
  const indexableProperties = await orama.index.getSearchableProperties(index);
  const indexablePropertiesWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
  const values = await orama.getDocumentProperties(doc, indexableProperties);
  for (const [key, value] of Object.entries(values)) {
    if (typeof value === "undefined") {
      continue;
    }
    const actualType = typeof value;
    const expectedType = indexablePropertiesWithTypes[key];
    if (actualType !== expectedType) {
      throw createError("INVALID_DOCUMENT_PROPERTY", key, expectedType, actualType);
    }
  }
  for (const prop of indexableProperties) {
    var _orama_index, _orama_index_beforeInsert, _orama_index1, _orama_index_afterInsert;
    const value = values[prop];
    if (typeof value === "undefined") {
      continue;
    }
    await ((_orama_index_beforeInsert = (_orama_index = orama.index).beforeInsert) === null || _orama_index_beforeInsert === void 0 ? void 0 : _orama_index_beforeInsert.call(_orama_index, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount));
    await orama.index.insert(orama.index, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount);
    await ((_orama_index_afterInsert = (_orama_index1 = orama.index).afterInsert) === null || _orama_index_afterInsert === void 0 ? void 0 : _orama_index_afterInsert.call(_orama_index1, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount));
  }
  if (!skipHooks) {
    await runSingleHook(orama.afterInsert, orama, id, doc);
  }
  trackInsertion(orama);
  return id;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/methods/remove.js
async function remove4(orama, id, language, skipHooks) {
  let result = true;
  const { index, docs } = orama.data;
  const doc = await orama.documentsStore.get(docs, id);
  if (!doc) {
    throw createError("DOCUMENT_DOES_NOT_EXIST", id);
  }
  const docsCount = await orama.documentsStore.count(docs);
  if (!skipHooks) {
    await runSingleHook(orama.beforeRemove, orama, id);
  }
  const indexableProperties = await orama.index.getSearchableProperties(index);
  const values = await orama.getDocumentProperties(doc, indexableProperties);
  for (const prop of indexableProperties) {
    var _orama_index, _orama_index_beforeRemove, _orama_index1, _orama_index_afterRemove;
    const value = values[prop];
    await ((_orama_index_beforeRemove = (_orama_index = orama.index).beforeRemove) === null || _orama_index_beforeRemove === void 0 ? void 0 : _orama_index_beforeRemove.call(_orama_index, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount));
    if (!await orama.index.remove(orama.index, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount)) {
      result = false;
    }
    await ((_orama_index_afterRemove = (_orama_index1 = orama.index).afterRemove) === null || _orama_index_afterRemove === void 0 ? void 0 : _orama_index_afterRemove.call(_orama_index1, orama.data.index, prop, id, value, language, orama.tokenizer, docsCount));
  }
  if (!skipHooks) {
    await runSingleHook(orama.afterRemove, orama, id);
  }
  trackRemoval(orama);
  return result;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/facets.js
function sortingPredicate(order = "desc", a, b) {
  if (order.toLowerCase() === "asc") {
    return a[1] - b[1];
  } else {
    return b[1] - a[1];
  }
}
async function getFacets(orama, results, facetsConfig) {
  var _a2, _b, _c, _d;
  const facets = {};
  const allIDs = results.map(([id]) => id);
  const allDocs = await orama.documentsStore.getMultiple(orama.data.docs, allIDs);
  const facetKeys = Object.keys(facetsConfig);
  const properties = await orama.index.getSearchablePropertiesWithTypes(orama.data.index);
  for (const facet of facetKeys) {
    let values = {};
    if (properties[facet] === "number") {
      const { ranges } = facetsConfig[facet];
      const tmp = [];
      for (const range of ranges) {
        tmp.push([
          `${range.from}-${range.to}`,
          0
        ]);
      }
      values = Object.fromEntries(tmp);
    }
    facets[facet] = {
      count: 0,
      values
    };
  }
  const allDocsLength = allDocs.length;
  for (let i = 0; i < allDocsLength; i++) {
    const doc = allDocs[i];
    for (const facet of facetKeys) {
      const facetValue = facet.includes(".") ? await getNested(doc, facet) : doc[facet];
      if (properties[facet] === "number") {
        for (const range of facetsConfig[facet].ranges) {
          if (facetValue >= range.from && facetValue <= range.to) {
            if (facets[facet].values[`${range.from}-${range.to}`] === void 0) {
              facets[facet].values[`${range.from}-${range.to}`] = 1;
            } else {
              facets[facet].values[`${range.from}-${range.to}`]++;
            }
          }
        }
      } else {
        const value = (_a2 = facetValue === null || facetValue === void 0 ? void 0 : facetValue.toString()) != null ? _a2 : properties[facet] === "boolean" ? "false" : "";
        facets[facet].values[value] = ((_b = facets[facet].values[value]) != null ? _b : 0) + 1;
      }
    }
  }
  for (const facet of facetKeys) {
    facets[facet].count = Object.keys(facets[facet].values).length;
    if (properties[facet] === "string") {
      const stringFacetDefinition = facetsConfig;
      facets[facet].values = Object.fromEntries(Object.entries(facets[facet].values).sort((a, b) => sortingPredicate(stringFacetDefinition.sort, a, b)).slice((_c = stringFacetDefinition.offset) != null ? _c : 0, (_d = stringFacetDefinition.limit) != null ? _d : 10));
    }
  }
  return facets;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/components/filters.js
function intersectFilteredIDs(filtered, lookedUp) {
  const map = /* @__PURE__ */ new Map();
  const result = [];
  for (const id of filtered) {
    map.set(id, true);
  }
  for (const [id, score] of lookedUp) {
    if (map.has(id)) {
      result.push([
        id,
        score
      ]);
      map.delete(id);
    }
  }
  return result;
}

// ../../node_modules/.pnpm/@orama+orama@1.0.0-beta.16/node_modules/@orama/orama/dist/methods/search.js
var defaultBM25Params = {
  k: 1.2,
  b: 0.75,
  d: 0.5
};
async function createSearchContext(tokenizer, index, documentsStore, language, params, properties, tokens, docsCount) {
  const indexMap = {};
  const docsIntersection = {};
  for (const prop of properties) {
    const tokensMap = {};
    for (const token of tokens) {
      tokensMap[token] = [];
    }
    indexMap[prop] = tokensMap;
    docsIntersection[prop] = [];
  }
  return {
    timeStart: await getNanosecondsTime(),
    tokenizer,
    index,
    documentsStore,
    language,
    params,
    docsCount,
    uniqueDocsIDs: {},
    indexMap,
    docsIntersection
  };
}
async function search2(orama, params, language) {
  var _a2, _b, _c;
  params.relevance = Object.assign((_a2 = params.relevance) != null ? _a2 : {}, defaultBM25Params);
  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
  const { limit = 10, offset = 0, term, properties, threshold = 1 } = params;
  const isPreflight = params.preflight === true;
  const { index, docs } = orama.data;
  const tokens = await orama.tokenizer.tokenize(term != null ? term : "", language);
  let propertiesToSearch = orama.caches["propertiesToSearch"];
  if (!propertiesToSearch) {
    const propertiesToSearchWithTypes = await orama.index.getSearchablePropertiesWithTypes(index);
    propertiesToSearch = await orama.index.getSearchableProperties(index);
    propertiesToSearch = propertiesToSearch.filter((prop) => propertiesToSearchWithTypes[prop] === "string");
    orama.caches["propertiesToSearch"] = propertiesToSearch;
  }
  if (properties && properties !== "*") {
    for (const prop of properties) {
      if (!propertiesToSearch.includes(prop)) {
        throw createError("UNKNOWN_INDEX", prop, propertiesToSearch.join(", "));
      }
    }
    propertiesToSearch = propertiesToSearch.filter((prop) => properties.includes(prop));
  }
  const context = await createSearchContext(orama.tokenizer, orama.index, orama.documentsStore, language, params, propertiesToSearch, tokens, await orama.documentsStore.count(docs));
  const results = Array.from({
    length: limit
  });
  const hasFilters = Object.keys((_b = params.where) != null ? _b : {}).length > 0;
  let whereFiltersIDs = [];
  if (hasFilters) {
    whereFiltersIDs = await orama.index.searchByWhereClause(context, index, params.where);
  }
  if (tokens.length) {
    const indexesLength = propertiesToSearch.length;
    for (let i = 0; i < indexesLength; i++) {
      var _params_boost;
      const prop = propertiesToSearch[i];
      const tokensLength = tokens.length;
      for (let j = 0; j < tokensLength; j++) {
        const term2 = tokens[j];
        const scoreList = await orama.index.search(context, index, prop, term2);
        context.indexMap[prop][term2].push(...scoreList);
      }
      const docIds = context.indexMap[prop];
      const vals = Object.values(docIds);
      context.docsIntersection[prop] = prioritizeTokenScores(vals, (_c = params === null || params === void 0 ? void 0 : (_params_boost = params.boost) === null || _params_boost === void 0 ? void 0 : _params_boost[prop]) != null ? _c : 1, threshold);
      const uniqueDocs = context.docsIntersection[prop];
      const uniqueDocsLength = uniqueDocs.length;
      for (let i2 = 0; i2 < uniqueDocsLength; i2++) {
        const [id, score] = uniqueDocs[i2];
        const prevScore = context.uniqueDocsIDs[id];
        if (prevScore) {
          context.uniqueDocsIDs[id] = prevScore + score + 0.5;
        } else {
          context.uniqueDocsIDs[id] = score;
        }
      }
    }
  } else {
    context.uniqueDocsIDs = Object.fromEntries(Object.keys(await orama.documentsStore.getAll(orama.data.docs)).map((k) => [
      k,
      0
    ]));
  }
  let uniqueDocsArray = Object.entries(context.uniqueDocsIDs).sort(sortTokenScorePredicate);
  if (hasFilters) {
    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray);
  }
  const resultIDs = /* @__PURE__ */ new Set();
  const facets = shouldCalculateFacets ? await getFacets(orama, uniqueDocsArray, params.facets) : {};
  if (!isPreflight) {
    for (let i = offset; i < limit + offset; i++) {
      const idAndScore = uniqueDocsArray[i];
      if (typeof idAndScore === "undefined") {
        break;
      }
      const [id, score] = idAndScore;
      if (!resultIDs.has(id)) {
        const fullDoc = await orama.documentsStore.get(docs, id);
        results[i] = {
          id,
          score,
          document: fullDoc
        };
        resultIDs.add(id);
      }
    }
  }
  const searchResult = {
    elapsed: await orama.formatElapsedTime(await getNanosecondsTime() - context.timeStart),
    hits: [],
    count: uniqueDocsArray.length
  };
  if (!isPreflight) {
    searchResult.hits = results.filter(Boolean);
  }
  if (shouldCalculateFacets) {
    searchResult.facets = facets;
  }
  return searchResult;
}

// src/indexer.ts
var import_debug = __toESM(require_src());
var debug = (0, import_debug.default)("verdaccio:search:indexer");
var SearchMemoryIndexer = class {
  database;
  storage;
  configureStorage(storage) {
    this.storage = storage;
  }
  async query(term) {
    if (this.database) {
      debug("searching %s at indexer", term);
      const searchResult = await search2(this.database, {
        term,
        properties: "*"
      });
      return searchResult;
    }
  }
  async add(pkg) {
    if (this.database) {
      const name = pkg.name;
      debug("adding item %s to the indexer", name);
      insert4(this.database, {
        id: name,
        name,
        description: pkg.description,
        version: `v${pkg.version}`,
        keywords: pkg.keywords,
        author: pkg._npmUser ? pkg._npmUser.name : "???"
      });
    }
  }
  async remove(name) {
    if (this.database) {
      debug("removing item %s to the indexer", name);
      await remove4(this.database, name);
    }
  }
  reindex() {
    var _a2;
    debug("reindexing search indexer");
    (_a2 = this.storage) == null ? void 0 : _a2.getLocalDatabase((error, packages) => {
      if (error) {
        throw error;
      }
      let i = packages.length;
      if (i === 0) {
        debug("no packages to index");
      }
      while (i--) {
        const pkg = packages[i];
        debug("indexing package %s", pkg == null ? void 0 : pkg.name);
        this.add(pkg);
      }
      debug("reindexed search indexer");
    });
  }
  async init() {
    this.database = await create5({
      schema: {
        id: "string",
        name: "string",
        description: "string",
        keywords: "string",
        version: "string",
        readme: "string"
      }
    });
    this.reindex();
  }
};
var indexer_default = new SearchMemoryIndexer();
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SearchMemoryIndexer
});
