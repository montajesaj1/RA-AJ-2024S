{"version":3,"names":["CellRenderer","resolveOption","option","config","TextRenderer","constructor","options","super","this","font","textColor","backgroundColor","verticalAlignment","horizontalAlignment","horizontalPadding","format","formatGeneric","elideDirection","wrapText","paint","gc","drawBackground","drawText","color","fillStyle","fillRect","x","y","width","height","getText","text","vAlign","hAlign","boxHeight","textX","textY","boxWidth","textHeight","measureFontHeight","beginPath","rect","clip","textAlign","textBaseline","fillText","textWidth","measureText","wordsInColumn","split","curY","textInCurrentLine","shift","length","curLineTextWidth","i","curSubString","substring","nextLineText","curWord","incrementedText","join","elide","textArr","slice","Math","floor","Private","missing","value","String","formatFixed","digits","Number","toFixed","formatPrecision","toPrecision","formatExponential","toExponential","formatIntlNumber","nft","Intl","NumberFormat","locales","formatDate","Date","toDateString","formatTime","toTimeString","formatISODateTime","toISOString","formatUTCDateTime","toUTCString","formatIntlDateTime","dtf","DateTimeFormat","fontHeightCache","undefined","fontMeasurementGC","normFont","fontMeasurementNode","style","document","body","appendChild","offsetHeight","removeChild","Object","create","node","createElement","position","top","left","visibility","textContent","canvas","getContext","HyperlinkRenderer","url","urlName","CellGroup","areCellGroupsIntersecting","group1","group2","r1","r2","c1","c2","getGroupIndex","dataModel","rgn","row","column","numGroups","groupCount","group","getCellGroupsAtRegion","groupsAtRegion","push","joinCellGroups","groups","startRow","MAX_VALUE","endRow","MIN_VALUE","startColumn","endColumn","min","max","areCellGroupsIntersectingAtAxis","axis","getGroup","groupIndex","joinCellGroupWithMergedCellGroups","region","joinedGroup","mergedCellGroups","g","mergedGroup","getCellGroupsAtRow","groupsAtRow","getCellGroupsAtColumn","groupsAtColumn","joinCellGroupsIntersectingAtAxis","regions","groupsAtAxis","r","concat","c","mergedGroupAtAxis","splice","createCellConfigObject","grid","hit","data","metadata","resizeHandleForHitTest","result","lw","lh","tw","th","autoselect","timeout","model","selectionModel","cs","currentSelection","lx","localX","ly","localY","cursorRow","cursorColumn","hw","headerWidth","hh","headerHeight","vpw","viewportWidth","vph","viewportHeight","mode","selectionMode","select","clear","scrollToRow","scrollToColumn","scrollToCell","setTimeout","computeTimeout","delta","abs","cursorMap","right","bottom","hyperlink","none","SelectionModel","_changed","Signal","_selectionMode","changed","connect","onDataModelChanged","isRowSelected","index","some","selections","s","containsRow","isColumnSelected","containsColumn","isCellSelected","containsCell","sender","args","emitChanged","emit","selection","AsyncCellRenderer","DEFAULT_INVALID_INPUT_MESSAGE","TextInputValidator","minLength","NaN","maxLength","pattern","validate","cell","valid","message","isNaN","test","IntegerInputValidator","NumberInputValidator","CellEditor","inputChanged","validityNotification","_disposed","_validInput","_gridWheelEventHandler","isDisposed","dispose","removeEventListener","_closeValidityNotification","viewportOccluder","edit","onCommit","onCancel","validator","createValidatorBasedOnType","updatePosition","addEventListener","_addContainer","startEditing","cancel","validInput","getInput","error","console","log","setValidity","editorContainer","classList","remove","add","Notification","target","placement","show","type","RegExp","constraint","minimum","maximum","getCellInfo","columnX","rowY","cellGroup","scrollX","columnOffset","scrollY","rowOffset","rowSize","columnSize","cellInfo","commit","cursorMovement","className","event","pointerEvents","close","InputCellEditor","handleEvent","_onKeyDown","_onBlur","_onInput","_unbindEvents","createWidget","input","deserialize","focus","bindEvents","toString","spellcheck","inputType","getKeyboardLayout","keyForKeydownEvent","shiftKey","stopPropagation","preventDefault","TextCellEditor","NumberCellEditor","step","trim","floatValue","parseFloat","Error","IntegerCellEditor","intValue","parseInt","DateCellEditor","_createWidget","_input","_deserialize","_bindEvents","BooleanCellEditor","checked","OptionCellEditor","_isMultiSelect","_select","multiple","values","item","selected","indexOf","selectedOptions","editorContainerRect","getBoundingClientRect","maxHeight","Array","isArray","items","enum","bind","DynamicOptionCellEditor","rowCount","listId","list","id","valueSet","Set","forEach","setAttribute","Widget","createNode","_message","addClass","setFlag","Flag","DisallowLayout","_target","_placement","attach","_evtMouseDown","update","messageNode","getElementsByClassName","onBeforeAttach","msg","onAfterDetach","onUpdateRequest","targetRect","alignItems","justifyContent","innerHTML","button","container","CellEditorController","_editor","_cell","_typeBasedOverrides","Map","_metadataBasedOverrides","setEditor","identifier","editor","set","key","_metadataIdentifierToKey","editable","_onCommit","_onCancel","_getEditor","response","setData","viewport","moveCursor","scrollToCursor","_getDataTypeKey","_objectToKey","object","str","_metadataMatchesIdentifier","hasOwnProperty","identifierValue","metadataValue","_getMetadataBasedEditor","editorMatched","dtKey","has","get","size","DataModel","emptyMetadata","MutableDataModel","freeze","GraphicsContext","context","_context","_state","State","next","restore","strokeStyle","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","imageSmoothingEnabled","globalAlpha","globalCompositeOperation","getLineDash","setLineDash","segments","rotate","angle","scale","transform","m11","m12","m21","m22","dx","dy","translate","setTransform","save","pop","closePath","isPointInPath","fillRule","arguments","arc","radius","startAngle","endAngle","anticlockwise","arcTo","x1","y1","x2","y2","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","ellipse","radiusX","radiusY","rotation","lineTo","moveTo","quadraticCurveTo","cpx","cpy","w","h","fill","stroke","clearRect","maxWidth","strokeRect","strokeText","createLinearGradient","x0","y0","createRadialGradient","r0","createPattern","image","repetition","createImageData","apply","getImageData","sx","sy","sw","sh","putImageData","drawImage","drawFocusIfNeeded","element","pi","pool","static","state","other","RendererMap","fallback","_values","_fallback","renderer","err","SectionList","_count","_length","_sections","_minimumSize","minimumSize","_defaultSize","defaultSize","count","n","prev","curr","offset","clampSize","ArrayExt","lowerBound","offsetCmp","section","span","offsetOf","indexCmp","extentOf","sizeOf","resize","insert","j","removed","k","move","destination","i1","k1","i2","k2","upperBound","pivot","count1","count2","span1","span2","k3","reset","DataGrid","_scrollX","_scrollY","_viewportWidth","_viewportHeight","_mousedown","_keyHandler","_mouseHandler","_vScrollBarMinWidth","_hScrollBarMinHeight","_dpiRatio","ceil","window","devicePixelRatio","_dataModel","_selectionModel","_editingEnabled","_style","defaultStyle","_stretchLastRow","stretchLastRow","_stretchLastColumn","stretchLastColumn","_headerVisibility","headerVisibility","_cellRenderers","cellRenderers","_copyConfig","copyConfig","defaultCopyConfig","_onRenderersChanged","defaultSizes","minimumSizes","_rowSections","rowHeight","_columnSections","columnWidth","_rowHeaderSections","rowHeaderWidth","_columnHeaderSections","columnHeaderHeight","_canvas","createCanvas","_buffer","_overlay","_canvasGC","_bufferGC","_overlayGC","_viewport","tabIndex","outline","_vScrollBar","ScrollBar","orientation","_hScrollBar","_scrollCorner","_editorController","MessageLoop","installMessageHook","hide","thumbMoved","_onThumbMoved","pageRequested","_onPageRequested","stepRequested","_onStepRequested","GridLayout","setCellConfig","layout","columnCount","rowSpacing","columnSpacing","fitPolicy","setRowStretch","setColumnStretch","addWidget","_releaseMouse","disconnect","_onDataModelChanged","_syncViewport","_onSelectionsChanged","repaintOverlay","keyHandler","mouseHandler","repaintContent","bodyWidth","bodyHeight","totalWidth","totalHeight","pageWidth","pageHeight","maxScrollX","maxScrollY","editorController","controller","editingEnabled","enabled","canvasGC","rowSections","columnSections","rowHeaderSections","columnHeaderSections","nr","vy1","vy2","scrollBy","nc","vx1","vx2","direction","isEmpty","iter","currentSel","dr","dc","newRow","newColumn","moveCursorWithinSelections","scrollTo","scrollByPage","dir","scrollByStep","rows","columns","postMessage","ScrollRequest","rowAt","bh","ph","columnAt","bw","pw","resizeRow","RowResizeRequest","resizeColumn","ColumnResizeRequest","resetRows","resetColumns","fitColumnNames","area","padding","numCols","colsRemaining","rowColumnCount","_fitRowColumnHeaders","bodyColumnCount","_fitBodyColumnHeaders","mapToLocal","clientX","clientY","mapToVirtual","vx","vy","hitTest","copyToClipboard","from","alert","br","bc","rhc","chr","separator","headers","warningThreshold","colCount","cellCount","confirm","cells","map","ClipboardExt","copyText","processMessage","vsbLimits","ElementExt","sizeLimits","hsbLimits","minWidth","minHeight","messageHook","handler","_processViewportMessage","activate","_evtKeyDown","_evtMouseMove","_evtMouseUp","_evtMouseDoubleClick","_evtMouseLeave","_evtContextMenu","_evtWheel","_refreshDPI","onActivateRequest","preventScroll","onBeforeShow","onResize","_syncScrollState","PaintRequest","repaintRegion","OverlayPaintRequest","_getMaxWidthInColumn","columnRegion","columnHeaderRegion","_getMaxWidthInArea","rowRegion","numRows","configs","_val","idx","_getConfig","sort","_getTextToRender","_getCellTextWidth","col","location","_getCellValue","_getCellMetadata","_resizeCanvasIfNeeded","maxW","maxH","curW","curH","expW","expH","needBlit","hasVScroll","isHidden","hasHScroll","vsw","hsh","apw","aph","needVScroll","needHScroll","setHidden","sendMessage","Msg","FitRequest","page","_scrollTo","_onViewportResize","_onViewportScrollRequest","_onViewportPaintRequest","_onViewportOverlayPaintRequest","_onViewportRowResizeRequest","_onViewportColumnResizeRequest","isVisible","offsetWidth","round","oldWidth","oldHeight","paintContent","_paintOverlay","bx","by","xMax","yMax","rs","rhs","chs","_resizeRow","_resizeColumnHeader","_resizeColumn","_resizeRowHeader","_onRowsInserted","_onColumnsInserted","_onRowsRemoved","_onColumnsRemoved","_onRowsMoved","_onColumnsMoved","_onCellsChanged","_onModelReset","Infinity","rowSpan","columnSpan","nrh","nch","drh","dch","onKeyDown","onMouseDown","onMouseMove","onMouseHover","onMouseUp","onMouseDoubleClick","onMouseLeave","onContextMenu","Platform","accelKey","onWheel","release","dpiRatio","oldSize","newSize","vw","vh","pos","_blitContent","cellGroups","paintRgn","xMin","yMin","headerBackgroundColor","_paintMergedCells","adjustedSize","contentX","contentY","contentWidth","contentHeight","dxArea","dyArea","cellgroups","source","rx","ry","rw","rh","_drawVoidRegion","_drawBodyRegion","_drawRowHeaderRegion","_drawColumnHeaderRegion","drawCornerHeaderRegion","_drawBodySelections","_drawRowHeaderSelections","_drawColumnHeaderSelections","_drawCursor","_drawShadows","voidColor","contentW","contentH","maxRow","maxColumn","rowSizes","columnSizes","dh","dw","_drawBackground","_drawRowBackground","rowBackgroundColor","_drawColumnBackground","columnBackgroundColor","_drawCells","_drawHorizontalGridLines","horizontalGridLineColor","gridLineColor","_drawVerticalGridLines","verticalGridLineColor","filter","cellGroupInteresectsRegion","headerHorizontalGridLineColor","headerGridLineColor","headerVerticalGridLineColor","colorFn","_getColumnSize","_getRowSize","isReady","paintPlaceholder","load","then","rgnR1","rgnR2","rgnC1","rgnC2","dm","selectionFillColor","selectionBorderColor","tmp","sr1","sc1","sr2","sc2","headerSelectionFillColor","headerSelectionBorderColor","maxCol","cursorFillColor","cursorBorderColor","shadow","scrollShadow","sxMax","syMax","grad","addColorStop","color1","color2","color3","copyFormatGeneric","ConflatableMessage","regionHasMergedCells","_region","_r1","_c1","_r2","_c2","conflate","_index","_size","splitFields","schema","primaryKeys","primaryKey","bodyFields","headerFields","field","fields","name","createMissingMap","missingValues","PERCENTAGE_REGEX","PIXEL_REGEX","ImageRenderer","placeholder","dataCache","async","loadedPromise","PromiseDelegate","img","Image","onload","resolve","src","promise","drawPlaceholder","widthPercentageMatch","widthPixelMatch","heightPercentageMatch","heightPixelMatch","requestedWidth","requestedHeight","match","fromCharCode","keyCode","onArrowLeft","onArrowRight","onArrowUp","onArrowDown","onPageUp","onPageDown","onEscape","onDelete","onKeyC","accel","cr","cc","_pressData","override","handle","cursor","cursorForHandle","open","Drag","overrideCursor","selectionGroup","msx","msy","colIndex","colRegion","deltaX","deltaY","deltaMode","ds","pressData","_cursorRow","_cursorColumn","_cursorRectIndex","_selections","firstSelection","cursorRect","moveToNextRect","moveToPreviousRect","alreadySelected","lr","lc","_data","_bodyFields","_headerFields","_missingValues","title"],"sources":["../src/cellrenderer.ts","../src/textrenderer.ts","../src/basicmousehandler.ts","../src/selectionmodel.ts","../src/hyperlinkrenderer.ts","../src/cellgroup.ts","../src/asynccellrenderer.ts","../src/celleditor.ts","../src/celleditorcontroller.ts","../src/datamodel.ts","../src/graphicscontext.ts","../src/sectionlist.ts","../src/datagrid.ts","../src/jsonmodel.ts","../src/renderermap.ts","../src/imagerenderer.ts","../src/basickeyhandler.ts","../src/basicselectionmodel.ts"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { DataModel } from './datamodel';\n\nimport { GraphicsContext } from './graphicscontext';\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nexport abstract class CellRenderer {\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * #### Notes\n   * The grid will save/restore the `gc` state before/after invoking\n   * the renderer.\n   *\n   * For performance, the cell content is efficiently clipped to the\n   * width of the column, but *the height is not clipped*. If height\n   * clipping is needed, the renderer must set up its own clip rect.\n   *\n   * The renderer **must not** draw outside the cell bounding height.\n   */\n  abstract paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void;\n}\n\n/**\n * The namespace for the `CellRenderer` class statics.\n */\nexport namespace CellRenderer {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export type CellConfig = {\n    /**\n     * The X position of the cell rectangle, in viewport coordinates.\n     */\n    readonly x: number;\n\n    /**\n     * The Y position of the cell rectangle, in viewport coordinates.\n     */\n    readonly y: number;\n\n    /**\n     * The height of the cell rectangle, in viewport pixels.\n     */\n    readonly height: number;\n\n    /**\n     * The width of the cell rectangle, in viewport pixels.\n     */\n    readonly width: number;\n\n    /**\n     * The region for the cell.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n\n    /**\n     * The value for the cell.\n     */\n    readonly value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    readonly metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a cell renderer config function.\n   *\n   * This type is used to compute a value from a cell config object.\n   */\n  export type ConfigFunc<T> = (config: CellConfig) => T;\n\n  /**\n   * A type alias for a cell renderer config option.\n   *\n   * A config option can be a static value or a config function.\n   */\n  export type ConfigOption<T> = T | ConfigFunc<T>;\n\n  /**\n   * Resolve a config option for a cell renderer.\n   *\n   * @param option - The config option to resolve.\n   *\n   * @param config - The cell config object.\n   *\n   * @returns The resolved value for the option.\n   */\n  export function resolveOption<T>(\n    option: ConfigOption<T>,\n    config: CellConfig\n  ): T {\n    return typeof option === 'function'\n      ? (option as ConfigFunc<T>)(config)\n      : option;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { CellRenderer } from './cellrenderer';\n\nimport { GraphicsContext } from './graphicscontext';\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport class TextRenderer extends CellRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: TextRenderer.IOptions = {}) {\n    super();\n    this.font = options.font || '12px sans-serif';\n    this.textColor = options.textColor || '#000000';\n    this.backgroundColor = options.backgroundColor || '';\n    this.verticalAlignment = options.verticalAlignment || 'center';\n    this.horizontalAlignment = options.horizontalAlignment || 'left';\n    this.horizontalPadding = options.horizontalPadding || 8;\n    this.format = options.format || TextRenderer.formatGeneric();\n    this.elideDirection = options.elideDirection || 'none';\n    this.wrapText = options.wrapText || false;\n  }\n\n  /**\n   * The CSS shorthand font for drawing the text.\n   */\n  readonly font: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for drawing the text.\n   */\n  readonly textColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for the cell background.\n   */\n  readonly backgroundColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The vertical alignment for the cell text.\n   */\n  readonly verticalAlignment: CellRenderer.ConfigOption<TextRenderer.VerticalAlignment>;\n\n  /**\n   * The horizontal alignment for the cell text.\n   */\n  readonly horizontalAlignment: CellRenderer.ConfigOption<TextRenderer.HorizontalAlignment>;\n\n  /**\n   * The horizontal alignment for the cell text.\n   */\n  readonly horizontalPadding: number;\n\n  /**\n   * The format function for the cell value.\n   */\n  readonly format: TextRenderer.FormatFunc;\n\n  /**\n   * Which side to draw the ellipsis. Set to 'none' to disable ellipsis.\n   */\n  readonly elideDirection: CellRenderer.ConfigOption<TextRenderer.ElideDirection>;\n\n  /**\n   * Boolean flag for applying text wrapping.\n   */\n  readonly wrapText: CellRenderer.ConfigOption<boolean>;\n\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawText(gc, config);\n  }\n\n  /**\n   * Draw the background for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawBackground(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the background color for the cell.\n    let color = CellRenderer.resolveOption(this.backgroundColor, config);\n\n    // Bail if there is no background color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Fill the cell with the background color.\n    gc.fillStyle = color;\n    gc.fillRect(config.x, config.y, config.width, config.height);\n  }\n\n  /**\n   * Get the full text to be rendered by the cell.\n   */\n  getText(config: CellRenderer.CellConfig): string {\n    return this.format(config);\n  }\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Format the cell value to text.\n    let text = this.getText(config);\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(\n      this.elideDirection,\n      config\n    );\n\n    // Resolve the text wrapping flag\n    let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = TextRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n      case 'top':\n        textY = config.y + 2 + textHeight;\n        break;\n      case 'center':\n        textY = config.y + config.height / 2 + textHeight / 2;\n        break;\n      case 'bottom':\n        textY = config.y + config.height - 2;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n      case 'left':\n        textX = config.x + this.horizontalPadding;\n        boxWidth = config.width - 14;\n        break;\n      case 'center':\n        textX = config.x + config.width / 2;\n        boxWidth = config.width;\n        break;\n      case 'right':\n        textX = config.x + config.width - this.horizontalPadding;\n        boxWidth = config.width - 14;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // Terminate call here if we're not eliding or wrapping text\n    if (elideDirection === 'none' && !wrapText) {\n      gc.fillText(text, textX, textY);\n      return;\n    }\n\n    // The current text width in pixels.\n    let textWidth = gc.measureText(text).width;\n\n    // Apply text wrapping if enabled.\n    if (wrapText && textWidth > boxWidth) {\n      // Make sure box clipping happens.\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n\n      // Split column name to words based on\n      // whitespace preceding a word boundary.\n      // \"Hello  world\" --> [\"Hello  \", \"world\"]\n      const wordsInColumn = text.split(/\\s(?=\\b)/);\n\n      // Y-coordinate offset for any additional lines\n      let curY = textY;\n      let textInCurrentLine = wordsInColumn.shift()!;\n\n      // Single word. Applying text wrap on word by splitting\n      // it into characters and fitting the maximum number of\n      // characters possible per line (box width).\n      if (wordsInColumn.length === 0) {\n        let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n        while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n          // Iterating from the end of the string until we find a\n          // substring (0,i) which has a width less than the box width.\n          for (let i = textInCurrentLine.length; i > 0; i--) {\n            const curSubString = textInCurrentLine.substring(0, i);\n            const curSubStringWidth = gc.measureText(curSubString).width;\n            if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n              // Found a substring which has a width less than the current\n              // box width. Rendering that substring on the current line\n              // and setting the remainder of the parent string as the next\n              // string to iterate on for the next line.\n              const nextLineText = textInCurrentLine.substring(\n                i,\n                textInCurrentLine.length\n              );\n              textInCurrentLine = nextLineText;\n              curLineTextWidth = gc.measureText(textInCurrentLine).width;\n              gc.fillText(curSubString, textX, curY);\n              curY += textHeight;\n              // No need to continue iterating after we identified\n              // an index to break the string on.\n              break;\n            }\n          }\n        }\n      }\n\n      // Multiple words in column header. Fitting maximum\n      // number of words possible per line (box width).\n      else {\n        while (wordsInColumn.length !== 0) {\n          // Processing the next word in the queue.\n          const curWord = wordsInColumn.shift();\n          // Joining that word with the existing text for\n          // the current line.\n          const incrementedText = [textInCurrentLine, curWord].join(' ');\n          const incrementedTextWidth = gc.measureText(incrementedText).width;\n          if (incrementedTextWidth > boxWidth) {\n            // If the newly combined text has a width larger than\n            // the box width, we render the line before the current\n            // word was added. We set the current word as the next\n            // line.\n            gc.fillText(textInCurrentLine, textX, curY);\n            curY += textHeight;\n            textInCurrentLine = curWord!;\n          } else {\n            // The combined text hasd a width less than the box width. We\n            // set the the current line text to be the new combined text.\n            textInCurrentLine = incrementedText;\n          }\n        }\n      }\n      gc.fillText(textInCurrentLine!, textX, curY);\n      // Terminating the call here as we don't want\n      // to apply text eliding when wrapping is active.\n      return;\n    }\n\n    // Elide text that is too long\n    const elide = '\\u2026';\n\n    // Loop until text width fits box or only one character remains\n    while (textWidth > boxWidth && text.length > 1) {\n      // Convert text string to array for dealing with astral symbols\n      const textArr = [...text];\n\n      if (elideDirection === 'right') {\n        // If text width is substantially bigger, take half the string\n        if (textArr.length > 4 && textWidth >= 2 * boxWidth) {\n          text =\n            textArr.slice(0, Math.floor(textArr.length / 2 + 1)).join('') +\n            elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = textArr.slice(0, textArr.length - 2).join('') + elide;\n        }\n      } else {\n        // If text width is substantially bigger, take half the string\n        if (textArr.length > 4 && textWidth >= 2 * boxWidth) {\n          text = elide + textArr.slice(Math.floor(textArr.length / 2)).join('');\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + textArr.slice(2).join('');\n        }\n      }\n\n      // Measure new text width\n      textWidth = gc.measureText(text).width;\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\n/**\n * The namespace for the `TextRenderer` class statics.\n */\nexport namespace TextRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export type ElideDirection = 'left' | 'right' | 'none';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export interface IOptions {\n    /**\n     * The font for drawing the cell text.\n     *\n     * The default is `'12px sans-serif'`.\n     */\n    font?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The color for the drawing the cell text.\n     *\n     * The default `'#000000'`.\n     */\n    textColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The background color for the cells.\n     *\n     * The default is `''`.\n     */\n    backgroundColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The vertical alignment for the cell text.\n     *\n     * The default is `'center'`.\n     */\n    verticalAlignment?: CellRenderer.ConfigOption<VerticalAlignment>;\n\n    /**\n     * The horizontal alignment for the cell text.\n     *\n     * The default is `'left'`.\n     */\n    horizontalAlignment?: CellRenderer.ConfigOption<HorizontalAlignment>;\n\n    /**\n     * The horizontal padding for the cell text in pixels.\n     *\n     * The default is `8`.\n     */\n    horizontalPadding?: number;\n\n    /**\n     * The format function for the renderer.\n     *\n     * The default is `TextRenderer.formatGeneric()`.\n     */\n    format?: FormatFunc;\n\n    /**\n     * The ellipsis direction for the cell text.\n     *\n     * The default is `'none'`.\n     */\n    elideDirection?: CellRenderer.ConfigOption<ElideDirection>;\n\n    /**\n     * Whether or not to apply text wrapping.\n     *\n     * The default is `'false'`.\n     */\n    wrapText?: CellRenderer.ConfigOption<boolean>;\n  }\n\n  /**\n   * A type alias for a format function.\n   */\n  export type FormatFunc = CellRenderer.ConfigFunc<string>;\n\n  /**\n   * Create a generic text format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new generic text format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `String()` to coerce any value\n   * to a string.\n   */\n  export function formatGeneric(\n    options: formatGeneric.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return String(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatGeneric` function statics.\n   */\n  export namespace formatGeneric {\n    /**\n     * The options for creating a generic format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a fixed decimal format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new fixed decimal format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toFixed()` to\n   * coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatFixed(options: formatFixed.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toFixed(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatFixed` function statics.\n   */\n  export namespace formatFixed {\n    /**\n     * The options for creating a fixed format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a significant figure format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new significant figure format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toPrecision()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatPrecision(\n    options: formatPrecision.IOptions = {}\n  ): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toPrecision(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatPrecision` function statics.\n   */\n  export namespace formatPrecision {\n    /**\n     * The options for creating a precision format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of significant figures to include in the value.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a scientific notation format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new scientific notation format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toExponential()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export function formatExponential(\n    options: formatExponential.IOptions = {}\n  ): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toExponential(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatExponential` function statics.\n   */\n  export namespace formatExponential {\n    /**\n     * The options for creating an exponential format function.\n     */\n    export interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international number format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international number format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.NumberFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) number formatter.\n   */\n  export function formatIntlNumber(\n    options: formatIntlNumber.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    let nft = new Intl.NumberFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return nft.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlNumber` function statics.\n   */\n  export namespace formatIntlNumber {\n    /**\n     * The options for creating an intl number format function.\n     */\n    export interface IOptions {\n      /**\n       * The locales to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.NumberFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a date format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new date format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toDateString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatDate(options: formatDate.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toDateString();\n      }\n      return new Date(value).toDateString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatDate` function statics.\n   */\n  export namespace formatDate {\n    /**\n     * The options for creating a date format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a time format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new time format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toTimeString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatTime(options: formatTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toTimeString();\n      }\n      return new Date(value).toTimeString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatTime` function statics.\n   */\n  export namespace formatTime {\n    /**\n     * The options for creating a time format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an ISO datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new ISO datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toISOString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatISODateTime(\n    options: formatISODateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      return new Date(value).toISOString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatISODateTime` function statics.\n   */\n  export namespace formatISODateTime {\n    /**\n     * The options for creating an ISO datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a UTC datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new UTC datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toUTCString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export function formatUTCDateTime(\n    options: formatUTCDateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toUTCString();\n      }\n      return new Date(value).toUTCString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatUTCDateTime` function statics.\n   */\n  export namespace formatUTCDateTime {\n    /**\n     * The options for creating a UTC datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international datetime format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.DateTimeFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) datetime formatter.\n   */\n  export function formatIntlDateTime(\n    options: formatIntlDateTime.IOptions = {}\n  ): FormatFunc {\n    let missing = options.missing || '';\n    let dtf = new Intl.DateTimeFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return dtf.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlDateTime` function statics.\n   */\n  export namespace formatIntlDateTime {\n    /**\n     * The options for creating an intl datetime format function.\n     */\n    export interface IOptions {\n      /**\n       * The locales to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.DateTimeFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Measure the height of a font.\n   *\n   * @param font - The CSS font string of interest.\n   *\n   * @returns The height of the font bounding box.\n   *\n   * #### Notes\n   * This function uses a temporary DOM node to measure the text box\n   * height for the specified font. The first call for a given font\n   * will incur a DOM reflow, but the return value is cached, so any\n   * subsequent call for the same font will return the cached value.\n   */\n  export function measureFontHeight(font: string): number {\n    // Look up the cached font height.\n    let height = Private.fontHeightCache[font];\n\n    // Return the cached font height if it exists.\n    if (height !== undefined) {\n      return height;\n    }\n\n    // Normalize the font.\n    Private.fontMeasurementGC.font = font;\n    let normFont = Private.fontMeasurementGC.font;\n\n    // Set the font on the measurement node.\n    Private.fontMeasurementNode.style.font = normFont;\n\n    // Add the measurement node to the document.\n    document.body.appendChild(Private.fontMeasurementNode);\n\n    // Measure the node height.\n    height = Private.fontMeasurementNode.offsetHeight;\n\n    // Remove the measurement node from the document.\n    document.body.removeChild(Private.fontMeasurementNode);\n\n    // Cache the measured height for the font and norm font.\n    Private.fontHeightCache[font] = height;\n    Private.fontHeightCache[normFont] = height;\n\n    // Return the measured height.\n    return height;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A cache of measured font heights.\n   */\n  export const fontHeightCache: { [font: string]: number } =\n    Object.create(null);\n\n  /**\n   * The DOM node used for font height measurement.\n   */\n  export const fontMeasurementNode = (() => {\n    let node = document.createElement('div');\n    node.style.position = 'absolute';\n    node.style.top = '-99999px';\n    node.style.left = '-99999px';\n    node.style.visibility = 'hidden';\n    node.textContent = 'M';\n    return node;\n  })();\n\n  /**\n   * The GC used for font measurement.\n   */\n  export const fontMeasurementGC = (() => {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas.getContext('2d')!;\n  })();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { Platform } from '@lumino/domutils';\n\nimport { Drag } from '@lumino/dragdrop';\n\nimport { DataGrid } from './datagrid';\n\nimport { HyperlinkRenderer } from './hyperlinkrenderer';\n\nimport { DataModel } from './datamodel';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { CellEditor } from './celleditor';\n\nimport { CellGroup } from './cellgroup';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport class BasicMouseHandler implements DataGrid.IMouseHandler {\n  /**\n   * Dispose of the resources held by the mouse handler.\n   */\n  dispose(): void {\n    // Bail early if the handler is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Release any held resources.\n    this.release();\n\n    // Mark the handler as disposed.\n    this._disposed = true;\n  }\n\n  /**\n   * Whether the mouse handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Release the resources held by the handler.\n   */\n  release(): void {\n    // Bail early if the is no press data.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the autoselect timeout.\n    if (this._pressData.type === 'select') {\n      this._pressData.timeout = -1;\n    }\n\n    // Clear the press data.\n    this._pressData.override.dispose();\n    this._pressData = null;\n  }\n\n  /**\n   * Handle the mouse hover event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseHover(grid: DataGrid, event: MouseEvent): void {\n    // Hit test the grid.\n    let hit = grid.hitTest(event.clientX, event.clientY);\n\n    // Get the resize handle for the hit test.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Hyperlink logic.\n    const config = Private.createCellConfigObject(grid, hit);\n\n    if (config) {\n      // Retrieve renderer for hovered cell.\n      const renderer = grid.cellRenderers.get(config);\n      if (renderer instanceof HyperlinkRenderer) {\n        cursor = this.cursorForHandle('hyperlink');\n      }\n    }\n\n    // Update the viewport cursor based on the part.\n    grid.viewport.node.style.cursor = cursor;\n\n    // TODO support user-defined hover items\n  }\n\n  /**\n   * Handle the mouse leave event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseLeave(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined hover popups.\n\n    // Clear the viewport cursor.\n    grid.viewport.node.style.cursor = '';\n  }\n\n  /**\n   * Handle the mouse down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse down event of interest.\n   */\n  onMouseDown(grid: DataGrid, event: MouseEvent): void {\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    const { region, row, column } = hit;\n\n    // Bail if the hit test is on an uninteresting region.\n    if (region === 'void') {\n      return;\n    }\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Hyperlink logic.\n    if (grid) {\n      // Create cell config object.\n      const config = Private.createCellConfigObject(grid, hit);\n\n      // Retrieve cell renderer.\n      let renderer = grid.cellRenderers.get(config!);\n\n      // Only process hyperlink renderers.\n      if (renderer instanceof HyperlinkRenderer) {\n        // Use the url param if it exists.\n        let url = CellRenderer.resolveOption(renderer.url, config!);\n        // Otherwise assume cell value is the URL.\n        if (!url) {\n          const format = TextRenderer.formatGeneric();\n          url = format(config!);\n        }\n\n        // Open the hyperlink only if user hit Ctrl+Click.\n        if (accel) {\n          window.open(url);\n          // Reset cursor default after clicking\n          const cursor = this.cursorForHandle('none');\n          grid.viewport.node.style.cursor = cursor;\n          // Not applying selections if navigating away.\n          return;\n        }\n      }\n    }\n\n    // If the hit test is the body region, the only option is select.\n    if (region === 'body') {\n      // Fetch the selection model.\n      let model = grid.selectionModel;\n\n      // Bail early if there is no selection model.\n      if (!model) {\n        return;\n      }\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor('default');\n\n      // Set up the press data.\n      this._pressData = {\n        type: 'select',\n        region,\n        row,\n        column,\n        override,\n        localX: -1,\n        localY: -1,\n        timeout: -1\n      };\n\n      // Set up the selection variables.\n      let r1: number;\n      let c1: number;\n      let r2: number;\n      let c2: number;\n      let cursorRow: number;\n      let cursorColumn: number;\n      let clear: SelectionModel.ClearMode;\n\n      // Accel == new selection, keep old selections.\n      if (accel) {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'none';\n      } else if (shift) {\n        r1 = model.cursorRow;\n        r2 = row;\n        c1 = model.cursorColumn;\n        c2 = column;\n        cursorRow = model.cursorRow;\n        cursorColumn = model.cursorColumn;\n        clear = 'current';\n      } else {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'all';\n      }\n\n      // Make the selection.\n      model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the hit test is on a header region.\n\n    // Convert the hit test into a part.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Handle horizontal resize.\n    if (handle === 'left' || handle === 'right') {\n      // Set up the resize data type.\n      const type = 'column-resize';\n\n      // Determine the column region.\n      let rgn: DataModel.ColumnRegion =\n        region === 'column-header' ? 'body' : 'row-header';\n\n      // Determine the section index.\n      let index = handle === 'left' ? column - 1 : column;\n\n      // Fetch the section size.\n      let size = grid.columnSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientX, override };\n\n      // Done.\n      return;\n    }\n\n    // Handle vertical resize\n    if (handle === 'top' || handle === 'bottom') {\n      // Set up the resize data type.\n      const type = 'row-resize';\n\n      // Determine the row region.\n      let rgn: DataModel.RowRegion =\n        region === 'row-header' ? 'body' : 'column-header';\n\n      // Determine the section index.\n      let index = handle === 'top' ? row - 1 : row;\n\n      // Fetch the section size.\n      let size = grid.rowSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientY, override };\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the only option is select.\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail if there is no selection model.\n    if (!model) {\n      return;\n    }\n\n    // Override the document cursor.\n    let override = Drag.overrideCursor('default');\n\n    // Set up the press data.\n    this._pressData = {\n      type: 'select',\n      region,\n      row,\n      column,\n      override,\n      localX: -1,\n      localY: -1,\n      timeout: -1\n    };\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow: number;\n    let cursorColumn: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Compute the selection based on the pressed region.\n    if (region === 'corner-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'row-header') {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n\n      const selectionGroup: CellGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['row-header', 'body'],\n        'row',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.r1 != Number.MAX_VALUE) {\n        r1 = joinedGroup.r1;\n        r2 = joinedGroup.r2;\n      }\n\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'column-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n\n      const selectionGroup: CellGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['column-header', 'body'],\n        'column',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.c1 != Number.MAX_VALUE) {\n        c1 = joinedGroup.c1;\n        c2 = joinedGroup.c2;\n      }\n\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse move event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse move event of interest.\n   */\n  onMouseMove(grid: DataGrid, event: MouseEvent): void {\n    // Fetch the press data.\n    const data = this._pressData;\n\n    // Bail early if there is no press data.\n    if (!data) {\n      return;\n    }\n\n    // Handle a row resize.\n    if (data.type === 'row-resize') {\n      let dy = event.clientY - data.clientY;\n      grid.resizeRow(data.region, data.index, data.size + dy);\n      return;\n    }\n\n    // Handle a column resize.\n    if (data.type === 'column-resize') {\n      let dx = event.clientX - data.clientX;\n      grid.resizeColumn(data.region, data.index, data.size + dx);\n      return;\n    }\n\n    // Otherwise, it's a select.\n\n    // Mouse moves during a corner header press are a no-op.\n    if (data.region === 'corner-header') {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model was removed.\n    if (!model) {\n      return;\n    }\n\n    // Map to local coordinates.\n    let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);\n\n    // Update the local mouse coordinates in the press data.\n    data.localX = lx;\n    data.localY = ly;\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n    let sx = grid.scrollX;\n    let sy = grid.scrollY;\n    let msx = grid.maxScrollY;\n    let msy = grid.maxScrollY;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Set up the timeout variable.\n    let timeout = -1;\n\n    // Compute the timemout based on hit region and mouse position.\n    if (data.region === 'row-header' || mode === 'row') {\n      if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    } else if (data.region === 'column-header' || mode === 'column') {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      }\n    } else {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      } else if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    }\n\n    // Update or initiate the autoselect if needed.\n    if (timeout >= 0) {\n      if (data.timeout < 0) {\n        data.timeout = timeout;\n        setTimeout(() => {\n          Private.autoselect(grid, data);\n        }, timeout);\n      } else {\n        data.timeout = timeout;\n      }\n      return;\n    }\n\n    // Otherwise, clear the autoselect timeout.\n    data.timeout = -1;\n\n    // Map the position to virtual coordinates.\n    let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);\n\n    // Clamp the coordinates to the limits.\n    vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));\n    vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Compute the selection based pressed region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r1 = data.row;\n      r2 = grid.rowAt('body', vy);\n\n      const selectionGroup: CellGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['row-header', 'body'],\n        'row',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.r1 != Number.MAX_VALUE) {\n        r1 = Math.min(r1, joinedGroup.r1);\n        r2 = Math.max(r2, joinedGroup.r2);\n      }\n\n      c1 = 0;\n      c2 = Infinity;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = data.column;\n      c2 = grid.columnAt('body', vx);\n\n      const selectionGroup: CellGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };\n      const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(\n        grid.dataModel!,\n        ['column-header', 'body'],\n        'column',\n        selectionGroup\n      );\n      // Check if there are any merges\n      if (joinedGroup.c1 != Number.MAX_VALUE) {\n        c1 = joinedGroup.c1;\n        c2 = joinedGroup.c2;\n      }\n    } else {\n      r1 = cursorRow;\n      r2 = grid.rowAt('body', vy);\n      c1 = cursorColumn;\n      c2 = grid.columnAt('body', vx);\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse up event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseUp(grid: DataGrid, event: MouseEvent): void {\n    this.release();\n  }\n\n  /**\n   * Handle the mouse double click event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void {\n    if (!grid.dataModel) {\n      this.release();\n      return;\n    }\n\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    if (region === 'void') {\n      this.release();\n      return;\n    }\n\n    if (region === 'column-header' || region === 'corner-header') {\n      // Convert the hit test into a part.\n      const handle = Private.resizeHandleForHitTest(hit);\n\n      if (handle === 'left' || handle === 'right') {\n        let colIndex = handle === 'left' ? column - 1 : column;\n\n        let colRegion: DataModel.ColumnRegion =\n          region === 'column-header' ? 'body' : 'row-header';\n\n        if (colIndex < 0) {\n          if (region === 'column-header') {\n            // If the column is -1, it means we are in the corner header\n            colIndex = grid.dataModel.columnCount('row-header') - 1;\n            colRegion = 'row-header';\n          } else {\n            // If we are on the left edge of the row header, do nothing\n            return;\n          }\n        }\n\n        grid.resizeColumn(colRegion, colIndex, null);\n      }\n    }\n\n    if (region === 'body') {\n      if (grid.editable) {\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n      }\n    }\n\n    this.release();\n  }\n\n  /**\n   * Handle the context menu event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The context menu event of interest.\n   */\n  onContextMenu(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined context menus\n  }\n\n  /**\n   * Handle the wheel event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The wheel event of interest.\n   */\n  onWheel(grid: DataGrid, event: WheelEvent): void {\n    // Bail if a mouse press is in progress.\n    if (this._pressData) {\n      return;\n    }\n\n    // Extract the delta X and Y movement.\n    let dx = event.deltaX;\n    let dy = event.deltaY;\n\n    // Convert the delta values to pixel values.\n    switch (event.deltaMode) {\n      case 0: // DOM_DELTA_PIXEL\n        break;\n      case 1: {\n        // DOM_DELTA_LINE\n        let ds = grid.defaultSizes;\n        dx *= ds.columnWidth;\n        dy *= ds.rowHeight;\n        break;\n      }\n      case 2: // DOM_DELTA_PAGE\n        dx *= grid.pageWidth;\n        dy *= grid.pageHeight;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Only scroll and stop the event propagation if needed.\n    if (\n      // Scrolling left and not reached min already\n      (dx < 0 && grid.scrollX !== 0) ||\n      // Scrolling right and not reached max already\n      (dx > 0 && grid.scrollX !== grid.maxScrollX) ||\n      // Scrolling top and not reached min already\n      (dy < 0 && grid.scrollY !== 0) ||\n      // Scrolling down and not reached max already\n      (dy > 0 && grid.scrollY !== grid.maxScrollY)\n    ) {\n      event.preventDefault();\n      event.stopPropagation();\n\n      // Scroll by the desired amount.\n      grid.scrollBy(dx, dy);\n    }\n  }\n\n  /**\n   * Convert a resize handle into a cursor.\n   */\n  cursorForHandle(handle: ResizeHandle): string {\n    return Private.cursorMap[handle];\n  }\n\n  /**\n   * Get the current pressData\n   */\n  get pressData(): PressData.PressData | null {\n    return this._pressData;\n  }\n\n  private _disposed = false;\n  protected _pressData: PressData.PressData | null = null;\n}\n\n/**\n * A type alias for the resize handle types.\n */\nexport type ResizeHandle =\n  | 'top'\n  | 'left'\n  | 'right'\n  | 'bottom'\n  | 'none'\n  | 'hyperlink';\n\n/**\n * The namespace for the pressdata.\n */\nexport namespace PressData {\n  /**\n   * A type alias for the row resize data.\n   */\n  export type RowResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'row-resize';\n\n    /**\n     * The row region which holds the section being resized.\n     */\n    readonly region: DataModel.RowRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client Y position of the mouse.\n     */\n    readonly clientY: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the column resize data.\n   */\n  export type ColumnResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'column-resize';\n\n    /**\n     * The column region which holds the section being resized.\n     */\n    readonly region: DataModel.ColumnRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client X position of the mouse.\n     */\n    readonly clientX: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the select data.\n   */\n  export type SelectData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'select';\n\n    /**\n     * The original region for the mouse press.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The original row that was selected.\n     */\n    readonly row: number;\n\n    /**\n     * The original column that was selected.\n     */\n    readonly column: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n\n    /**\n     * The current local X position of the mouse.\n     */\n    localX: number;\n\n    /**\n     * The current local Y position of the mouse.\n     */\n    localY: number;\n\n    /**\n     * The timeout delay for the autoselect loop.\n     */\n    timeout: number;\n  };\n\n  /**\n   * A type alias for the resize handler press data.\n   */\n  export type PressData = RowResizeData | ColumnResizeData | SelectData;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Creates a CellConfig object from a hit region.\n   */\n  export function createCellConfigObject(\n    grid: DataGrid,\n    hit: DataGrid.HitTestResult\n  ): CellRenderer.CellConfig | undefined {\n    const { region, row, column } = hit;\n\n    // Terminate call if region is void.\n    if (region === 'void') {\n      return undefined;\n    }\n\n    // Augment hit region params with value and metadata.\n    const value = grid.dataModel!.data(region, row, column);\n    const metadata = grid.dataModel!.metadata(region, row, column);\n\n    // Create cell config object to retrieve cell renderer.\n    const config = {\n      ...hit,\n      value: value,\n      metadata: metadata\n    } as CellRenderer.CellConfig;\n\n    return config;\n  }\n\n  /**\n   * Get the resize handle for a grid hit test.\n   */\n  export function resizeHandleForHitTest(\n    hit: DataGrid.HitTestResult\n  ): ResizeHandle {\n    // Fetch the row and column.\n    let r = hit.row;\n    let c = hit.column;\n\n    // Fetch the leading and trailing sizes.\n    let lw = hit.x;\n    let lh = hit.y;\n    let tw = hit.width - hit.x;\n    let th = hit.height - hit.y;\n\n    // Set up the result variable.\n    let result: ResizeHandle;\n\n    // Dispatch based on hit test region.\n    switch (hit.region) {\n      case 'corner-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'column-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'row-header':\n        if (c > 0 && lw <= 5) {\n          result = 'left';\n        } else if (tw <= 6) {\n          result = 'right';\n        } else if (r > 0 && lh <= 5) {\n          result = 'top';\n        } else if (th <= 6) {\n          result = 'bottom';\n        } else {\n          result = 'none';\n        }\n        break;\n      case 'body':\n        result = 'none';\n        break;\n      case 'void':\n        result = 'none';\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Return the result.\n    return result;\n  }\n\n  /**\n   * A timer callback for the autoselect loop.\n   *\n   * @param grid - The datagrid of interest.\n   *\n   * @param data - The select data of interest.\n   */\n  export function autoselect(grid: DataGrid, data: PressData.SelectData): void {\n    // Bail early if the timeout has been reset.\n    if (data.timeout < 0) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model has been removed.\n    if (!model) {\n      return;\n    }\n\n    // Fetch the current selection.\n    let cs = model.currentSelection();\n\n    // Bail early if there is no current selection.\n    if (!cs) {\n      return;\n    }\n\n    // Fetch local X and Y coordinates of the mouse.\n    let lx = data.localX;\n    let ly = data.localY;\n\n    // Set up the selection variables.\n    let r1 = cs.r1;\n    let c1 = cs.c1;\n    let r2 = cs.r2;\n    let c2 = cs.c2;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Update the selection based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    } else {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    }\n\n    // Update the current selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else if (data.region === 'column-header' || mode == 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else if (mode === 'cell') {\n      grid.scrollToCell(cs.r2, cs.c2);\n    }\n\n    // Schedule the next call with the current timeout.\n    setTimeout(() => {\n      autoselect(grid, data);\n    }, data.timeout);\n  }\n\n  /**\n   * Compute the scroll timeout for the given delta distance.\n   *\n   * @param delta - The delta pixels from the origin.\n   *\n   * @returns The scaled timeout in milliseconds.\n   */\n  export function computeTimeout(delta: number): number {\n    return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n  }\n\n  /**\n   * A mapping of resize handle to cursor.\n   */\n  export const cursorMap = {\n    top: 'ns-resize',\n    left: 'ew-resize',\n    right: 'ew-resize',\n    bottom: 'ns-resize',\n    hyperlink: 'pointer',\n    none: 'default'\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { some } from '@lumino/algorithm';\n\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { DataModel } from './datamodel';\n\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nexport abstract class SelectionModel {\n  /**\n   * Construct a new selection model.\n   *\n   * @param options - The options for initializing the model.\n   */\n  constructor(options: SelectionModel.IOptions) {\n    this.dataModel = options.dataModel;\n    this._selectionMode = options.selectionMode || 'cell';\n    this.dataModel.changed.connect(this.onDataModelChanged, this);\n  }\n\n  /**\n   * Whether the selection model is empty.\n   *\n   * #### Notes\n   * An empty selection model will yield an empty `selections` iterator.\n   */\n  abstract readonly isEmpty: boolean;\n\n  /**\n   * The row index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorRow: number;\n\n  /**\n   * The column index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorColumn: number;\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  abstract moveCursorWithinSelections(\n    direction: SelectionModel.CursorMoveDirection\n  ): void;\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  abstract currentSelection(): SelectionModel.Selection | null;\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the selections in the model.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  abstract selections(): IterableIterator<SelectionModel.Selection>;\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  abstract select(args: SelectionModel.SelectArgs): void;\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  abstract clear(): void;\n\n  /**\n   * A signal emitted when the selection model has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * The data model associated with the selection model.\n   */\n  readonly dataModel: DataModel;\n\n  /**\n   * Get the selection mode for the model.\n   */\n  get selectionMode(): SelectionModel.SelectionMode {\n    return this._selectionMode;\n  }\n\n  /**\n   * Set the selection mode for the model.\n   *\n   * #### Notes\n   * This will clear the selection model.\n   */\n  set selectionMode(value: SelectionModel.SelectionMode) {\n    // Bail early if the mode does not change.\n    if (this._selectionMode === value) {\n      return;\n    }\n\n    // Update the internal mode.\n    this._selectionMode = value;\n\n    // Clear the current selections.\n    this.clear();\n  }\n\n  /**\n   * Test whether any selection intersects a row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @returns Whether any selection intersects the row.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isRowSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsRow(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @returns Whether any selection intersects the column.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isColumnSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsColumn(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a cell.\n   *\n   * @param row - The row index of interest.\n   *\n   * @param column - The column index of interest.\n   *\n   * @returns Whether any selection intersects the cell.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isCellSelected(row: number, column: number): boolean {\n    return some(this.selections(), s => Private.containsCell(s, row, column));\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   *\n   * #### Notes\n   * Selection model implementations should update their selections\n   * in a manner that is relevant for the changes to the data model.\n   *\n   * The default implementation of this method is a no-op.\n   */\n  protected onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    // pass\n  }\n\n  /**\n   * Emit the `changed` signal for the selection model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the selection model\n   * has changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(): void {\n    this._changed.emit(undefined);\n  }\n\n  private _changed = new Signal<this, void>(this);\n  private _selectionMode: SelectionModel.SelectionMode = 'cell';\n}\n\n/**\n * The namespace for the `SelectionModel` class statics.\n */\nexport namespace SelectionModel {\n  /**\n   * A type alias for the selection mode.\n   */\n  export type SelectionMode = 'row' | 'column' | 'cell';\n\n  /**\n   * A type alias for the cursor move direction.\n   */\n  export type CursorMoveDirection = 'up' | 'down' | 'left' | 'right' | 'none';\n\n  /**\n   * A type alias for the clear mode.\n   */\n  export type ClearMode = 'all' | 'current' | 'none';\n\n  /**\n   * A type alias for the select args.\n   */\n  export type SelectArgs = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    c2: number;\n\n    /**\n     * The row index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorRow: number;\n\n    /**\n     * The column index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorColumn: number;\n\n    /**\n     * Which of the existing selections to clear.\n     */\n    clear: ClearMode;\n  };\n\n  /**\n   * A type alias for a selection in a selection model.\n   */\n  export type Selection = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    readonly r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    readonly c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    readonly r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    readonly c2: number;\n  };\n\n  /**\n   * An options object for initializing a selection model.\n   */\n  export interface IOptions {\n    /**\n     * The data model for the selection model.\n     */\n    dataModel: DataModel;\n\n    /**\n     * The selection mode for the model.\n     *\n     * The default is `'cell'`.\n     */\n    selectionMode?: SelectionMode;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Test whether a selection contains a given row.\n   */\n  export function containsRow(\n    selection: SelectionModel.Selection,\n    row: number\n  ): boolean {\n    let { r1, r2 } = selection;\n    return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n  }\n\n  /**\n   * Test whether a selection contains a given column.\n   */\n  export function containsColumn(\n    selection: SelectionModel.Selection,\n    column: number\n  ): boolean {\n    let { c1, c2 } = selection;\n    return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n  }\n\n  /**\n   * Test whether a selection contains a given cell.\n   */\n  export function containsCell(\n    selection: SelectionModel.Selection,\n    row: number,\n    column: number\n  ): boolean {\n    return containsRow(selection, row) && containsColumn(selection, column);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { CellRenderer } from './cellrenderer';\n\nimport { GraphicsContext } from './graphicscontext';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport class HyperlinkRenderer extends TextRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: HyperlinkRenderer.IOptions = {}) {\n    // Set default parameters before passing over the super.\n    options.textColor = options.textColor || 'navy';\n    options.font = options.font || 'bold 12px sans-serif';\n    super(options);\n    this.url = options.url;\n    this.urlName = options.urlName;\n  }\n\n  /**\n   * The URL address.\n   */\n  readonly url: CellRenderer.ConfigOption<string> | undefined;\n\n  /**\n   * The friendly link name.\n   */\n  readonly urlName: CellRenderer.ConfigOption<string> | undefined;\n\n  /**\n   * Get the full text to be rendered by the cell.\n   */\n  getText(config: CellRenderer.CellConfig): string {\n    let urlName = CellRenderer.resolveOption(this.urlName, config);\n\n    // If we have a friendly URL name, use that.\n    if (urlName) {\n      return this.format({\n        ...config,\n        value: urlName\n      } as CellRenderer.CellConfig);\n    }\n\n    // Otherwise use the raw value attribute.\n    return this.format(config);\n  }\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    let text = this.getText(config);\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(\n      this.elideDirection,\n      config\n    );\n\n    // Resolve the text wrapping flag\n    let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = HyperlinkRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n      case 'top':\n        textY = config.y + 2 + textHeight;\n        break;\n      case 'center':\n        textY = config.y + config.height / 2 + textHeight / 2;\n        break;\n      case 'bottom':\n        textY = config.y + config.height - 2;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n      case 'left':\n        textX = config.x + 8;\n        boxWidth = config.width - 14;\n        break;\n      case 'center':\n        textX = config.x + config.width / 2;\n        boxWidth = config.width;\n        break;\n      case 'right':\n        textX = config.x + config.width - 8;\n        boxWidth = config.width - 14;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // Terminate call here if we're not eliding or wrapping text\n    if (elideDirection === 'none' && !wrapText) {\n      gc.fillText(text, textX, textY);\n      return;\n    }\n\n    // The current text width in pixels.\n    let textWidth = gc.measureText(text).width;\n\n    // Apply text wrapping if enabled.\n    if (wrapText && textWidth > boxWidth) {\n      // Make sure box clipping happens.\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n\n      // Split column name to words based on\n      // whitespace preceding a word boundary.\n      // \"Hello  world\" --> [\"Hello  \", \"world\"]\n      const wordsInColumn = text.split(/\\s(?=\\b)/);\n\n      // Y-coordinate offset for any additional lines\n      let curY = textY;\n      let textInCurrentLine = wordsInColumn.shift()!;\n\n      // Single word. Applying text wrap on word by splitting\n      // it into characters and fitting the maximum number of\n      // characters possible per line (box width).\n      if (wordsInColumn.length === 0) {\n        let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n        while (curLineTextWidth > boxWidth && textInCurrentLine !== '') {\n          // Iterating from the end of the string until we find a\n          // substring (0,i) which has a width less than the box width.\n          for (let i = textInCurrentLine.length; i > 0; i--) {\n            const curSubString = textInCurrentLine.substring(0, i);\n            const curSubStringWidth = gc.measureText(curSubString).width;\n            if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n              // Found a substring which has a width less than the current\n              // box width. Rendering that substring on the current line\n              // and setting the remainder of the parent string as the next\n              // string to iterate on for the next line.\n              const nextLineText = textInCurrentLine.substring(\n                i,\n                textInCurrentLine.length\n              );\n              textInCurrentLine = nextLineText;\n              curLineTextWidth = gc.measureText(textInCurrentLine).width;\n              gc.fillText(curSubString, textX, curY);\n              curY += textHeight;\n              // No need to continue iterating after we identified\n              // an index to break the string on.\n              break;\n            }\n          }\n        }\n      }\n\n      // Multiple words in column header. Fitting maximum\n      // number of words possible per line (box width).\n      else {\n        while (wordsInColumn.length !== 0) {\n          // Processing the next word in the queue.\n          const curWord = wordsInColumn.shift();\n          // Joining that word with the existing text for\n          // the current line.\n          const incrementedText = [textInCurrentLine, curWord].join(' ');\n          const incrementedTextWidth = gc.measureText(incrementedText).width;\n          if (incrementedTextWidth > boxWidth) {\n            // If the newly combined text has a width larger than\n            // the box width, we render the line before the current\n            // word was added. We set the current word as the next\n            // line.\n            gc.fillText(textInCurrentLine, textX, curY);\n            curY += textHeight;\n            textInCurrentLine = curWord!;\n          } else {\n            // The combined text hasd a width less than the box width. We\n            // set the the current line text to be the new combined text.\n            textInCurrentLine = incrementedText;\n          }\n        }\n      }\n      gc.fillText(textInCurrentLine!, textX, curY);\n      // Terminating the call here as we don't want\n      // to apply text eliding when wrapping is active.\n      return;\n    }\n\n    // Elide text that is too long\n    let elide = '\\u2026';\n\n    // Compute elided text\n    if (elideDirection === 'right') {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = text.substring(0, text.length / 2 + 1) + elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = text.substring(0, text.length - 2) + elide;\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    } else {\n      while (textWidth > boxWidth && text.length > 1) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = elide + text.substring(text.length / 2);\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + text.substring(2);\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\nexport namespace HyperlinkRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export type ElideDirection = 'left' | 'right' | 'none';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export interface IOptions extends TextRenderer.IOptions {\n    /**\n     * The URL address\n     */\n    url?: CellRenderer.ConfigOption<string> | undefined;\n    /**\n     * The friendly link name.\n     *\n     * The default is the URL itself.\n     */\n    urlName?: CellRenderer.ConfigOption<string> | undefined;\n  }\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\nimport { DataModel } from './datamodel';\n\n/**\n * An interface describing a merged cell group.\n * r1: start row\n * r2: end row\n * c1: start column\n * c2: end column\n */\nexport interface CellGroup {\n  r1: number;\n  r2: number;\n  c1: number;\n  c2: number;\n}\n\n/**\n * A collection of helper functions relating to merged cell groups\n */\nexport namespace CellGroup {\n  /**\n   * Checks if two cell-groups are intersecting\n   * in the given axis.\n   * @param group1\n   * @param group2\n   * @param axis\n   */\n  export function areCellGroupsIntersectingAtAxis(\n    group1: CellGroup,\n    group2: CellGroup,\n    axis: 'row' | 'column'\n  ): boolean {\n    if (axis === 'row') {\n      return (\n        (group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n        (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n        (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n        (group2.r2 >= group1.r1 && group2.r2 <= group1.r2)\n      );\n    }\n    return (\n      (group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n      (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n      (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n      (group2.c2 >= group1.c1 && group2.c2 <= group1.c2)\n    );\n  }\n\n  /**\n   * Checks if cell-groups are intersecting.\n   * @param group1\n   * @param group2\n   */\n  export function areCellGroupsIntersecting(\n    group1: CellGroup,\n    group2: CellGroup\n  ): boolean {\n    return (\n      ((group1.r1 >= group2.r1 && group1.r1 <= group2.r2) ||\n        (group1.r2 >= group2.r1 && group1.r2 <= group2.r2) ||\n        (group2.r1 >= group1.r1 && group2.r1 <= group1.r2) ||\n        (group2.r2 >= group1.r1 && group2.r2 <= group1.r2)) &&\n      ((group1.c1 >= group2.c1 && group1.c1 <= group2.c2) ||\n        (group1.c2 >= group2.c1 && group1.c2 <= group2.c2) ||\n        (group2.c1 >= group1.c1 && group2.c1 <= group1.c2) ||\n        (group2.c2 >= group1.c1 && group2.c2 <= group1.c2))\n    );\n  }\n\n  /**\n   * Retrieves the index of the cell-group to which\n   * the cell at the given row, column belongs.\n   * @param dataModel\n   * @param rgn\n   * @param row\n   * @param column\n   */\n  export function getGroupIndex(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): number {\n    const numGroups = dataModel.groupCount(rgn);\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (\n        row >= group.r1 &&\n        row <= group.r2 &&\n        column >= group.c1 &&\n        column <= group.c2\n      ) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns a cell-group for the given row/index coordinates.\n   * @param dataModel\n   * @param rgn\n   * @param row\n   * @param column\n   */\n  export function getGroup(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): CellGroup | null {\n    const groupIndex = getGroupIndex(dataModel, rgn, row, column);\n    if (groupIndex === -1) {\n      return null;\n    }\n\n    return dataModel.group(rgn, groupIndex);\n  }\n\n  /**\n   * Returns all cell groups which belong to\n   * a given cell cell region.\n   * @param dataModel\n   * @param rgn\n   */\n  export function getCellGroupsAtRegion(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion\n  ): CellGroup[] {\n    let groupsAtRegion: CellGroup[] = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      groupsAtRegion.push(group);\n    }\n    return groupsAtRegion;\n  }\n\n  /**\n   * Calculates and returns a merged cell-group from\n   * two cell-group objects.\n   * @param groups\n   */\n  export function joinCellGroups(groups: CellGroup[]): CellGroup {\n    let startRow = Number.MAX_VALUE;\n    let endRow = Number.MIN_VALUE;\n    let startColumn = Number.MAX_VALUE;\n    let endColumn = Number.MIN_VALUE;\n\n    for (const group of groups) {\n      startRow = Math.min(startRow, group.r1);\n      endRow = Math.max(endRow, group.r2);\n      startColumn = Math.min(startColumn, group.c1);\n      endColumn = Math.max(endColumn, group.c2);\n    }\n\n    return { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn };\n  }\n\n  /**\n   * Merges a cell group with other cells groups in the\n   * same region if they intersect.\n   * @param dataModel the data model of the grid.\n   * @param group the target cell group.\n   * @param region the region of the cell group.\n   * @returns a new cell group after merging has happened.\n   */\n  export function joinCellGroupWithMergedCellGroups(\n    dataModel: DataModel,\n    group: CellGroup,\n    region: DataModel.CellRegion\n  ): CellGroup {\n    let joinedGroup: CellGroup = { ...group };\n\n    const mergedCellGroups: CellGroup[] = getCellGroupsAtRegion(\n      dataModel,\n      region\n    );\n\n    for (let g = 0; g < mergedCellGroups.length; g++) {\n      const mergedGroup = mergedCellGroups[g];\n      if (areCellGroupsIntersecting(joinedGroup, mergedGroup)) {\n        joinedGroup = joinCellGroups([joinedGroup, mergedGroup]);\n      }\n    }\n\n    return joinedGroup;\n  }\n\n  /**\n   * Retrieves a list of cell groups intersecting at\n   * a given row.\n   * @param dataModel data model of the grid.\n   * @param rgn the cell region.\n   * @param row the target row to look for intersections at.\n   * @returns all cell groups intersecting with the row.\n   */\n  export function getCellGroupsAtRow(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    row: number\n  ): CellGroup[] {\n    let groupsAtRow = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (row >= group.r1 && row <= group.r2) {\n        groupsAtRow.push(group);\n      }\n    }\n    return groupsAtRow;\n  }\n\n  /**\n   * Retrieves a list of cell groups intersecting at\n   * a given column.\n   * @param dataModel data model of the grid.\n   * @param rgn the cell region.\n   * @param column the target column to look for intersections at.\n   * @returns all cell groups intersecting with the column.\n   */\n  export function getCellGroupsAtColumn(\n    dataModel: DataModel,\n    rgn: DataModel.CellRegion,\n    column: number\n  ): CellGroup[] {\n    let groupsAtColumn = [];\n    const numGroups = dataModel.groupCount(rgn);\n\n    for (let i = 0; i < numGroups; i++) {\n      const group = dataModel.group(rgn, i)!;\n      if (column >= group.c1 && column <= group.c2) {\n        groupsAtColumn.push(group);\n      }\n    }\n    return groupsAtColumn;\n  }\n\n  /**\n   * Merges a target cell group with any cell groups\n   * it intersects with at a given row or column.\n   * @param dataModel data model of the grid.\n   * @param regions list of cell regions.\n   * @param axis row or column.\n   * @param group the target cell group.\n   * @returns a new merged cell group.\n   */\n  export function joinCellGroupsIntersectingAtAxis(\n    dataModel: DataModel,\n    regions: DataModel.CellRegion[],\n    axis: 'row' | 'column',\n    group: CellGroup\n  ): CellGroup {\n    let groupsAtAxis: CellGroup[] = [];\n    if (axis === 'row') {\n      for (const region of regions) {\n        for (let r = group.r1; r <= group.r2; r++) {\n          groupsAtAxis = groupsAtAxis.concat(\n            CellGroup.getCellGroupsAtRow(dataModel, region, r)\n          );\n        }\n      }\n    } else {\n      for (const region of regions) {\n        for (let c = group.c1; c <= group.c2; c++) {\n          groupsAtAxis = groupsAtAxis.concat(\n            CellGroup.getCellGroupsAtColumn(dataModel, region, c)\n          );\n        }\n      }\n    }\n\n    let mergedGroupAtAxis: CellGroup = CellGroup.joinCellGroups(groupsAtAxis);\n\n    if (groupsAtAxis.length > 0) {\n      let mergedCellGroups: CellGroup[] = [];\n      for (const region of regions) {\n        mergedCellGroups = mergedCellGroups.concat(\n          CellGroup.getCellGroupsAtRegion(dataModel, region)\n        );\n      }\n\n      for (let g = 0; g < mergedCellGroups.length; g++) {\n        const group = mergedCellGroups[g];\n        if (\n          CellGroup.areCellGroupsIntersectingAtAxis(\n            mergedGroupAtAxis,\n            group,\n            axis\n          )\n        ) {\n          mergedGroupAtAxis = CellGroup.joinCellGroups([\n            group,\n            mergedGroupAtAxis\n          ]);\n          mergedCellGroups.splice(g, 1);\n          g = 0;\n        }\n      }\n    }\n    return mergedGroupAtAxis;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2023, Lumino Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport { CellRenderer } from './cellrenderer';\nimport { GraphicsContext } from './graphicscontext';\n\n/**\n * An object which renders the cells of a data grid asynchronously.\n *\n * #### Notes\n * For performance reason, the datagrid only paints cells synchronously,\n * though if your cell renderer inherits from AsyncCellRenderer, you will\n * be able to do some asynchronous work prior to painting the cell.\n * See `ImageRenderer` for an example of an asynchronous renderer.\n */\nexport abstract class AsyncCellRenderer extends CellRenderer {\n  /**\n   * Whether the renderer is ready or not for that specific config.\n   * If it's not ready, the datagrid will paint the placeholder using `paintPlaceholder`.\n   * If it's ready, the datagrid will paint the cell synchronously using `paint`.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * @returns Whether the renderer is ready for this config or not.\n   */\n  abstract isReady(config: CellRenderer.CellConfig): boolean;\n\n  /**\n   * Do any asynchronous work prior to painting this cell config.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  abstract load(config: CellRenderer.CellConfig): Promise<void>;\n\n  /**\n   * Paint the placeholder for a cell, waiting for the renderer to be ready.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  abstract paintPlaceholder(\n    gc: GraphicsContext,\n    config: CellRenderer.CellConfig\n  ): void;\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { Message } from '@lumino/messaging';\n\nimport { Widget } from '@lumino/widgets';\n\nimport { DataGrid } from './datagrid';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { Signal } from '@lumino/signaling';\n\nimport { CellGroup } from './cellgroup';\n\n/**\n * A response object returned from cell input validator\n */\nexport interface ICellInputValidatorResponse {\n  /**\n   * Flag indicating cell input is valid or not\n   */\n  valid: boolean;\n  /**\n   * Validation error message. Set only when input is invalid\n   */\n  message?: string;\n}\n\n/**\n * An object which validates cell input values.\n */\nexport interface ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: any\n  ): ICellInputValidatorResponse;\n}\n\n/**\n * An object returned from cell editor after a successful edit.\n */\nexport interface ICellEditResponse {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  cell: CellEditor.CellConfig;\n  /**\n   * Value input.\n   */\n  value: any;\n  /**\n   * Cursor move direction based on keys pressed to end the edit.\n   */\n  cursorMovement: SelectionModel.CursorMoveDirection;\n}\n\n/**\n * An object implementing cell editing.\n */\nexport interface ICellEditor {\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void;\n  /**\n   * Cancel editing the cell.\n   */\n  cancel(): void;\n}\n\n// default validation error message\nconst DEFAULT_INVALID_INPUT_MESSAGE = 'Invalid input!';\n\n// A type alias for available cell data types\nexport type CellDataType =\n  | 'string'\n  | 'number'\n  | 'integer'\n  | 'boolean'\n  | 'date'\n  | 'string:option'\n  | 'number:option'\n  | 'integer:option'\n  | 'date:option'\n  | 'string:dynamic-option'\n  | 'number:dynamic-option'\n  | 'integer:dynamic-option'\n  | 'date:dynamic-option';\n\n/**\n * An object containing cell editing options.\n */\nexport interface ICellEditOptions {\n  /**\n   * Cell editor to use for editing.\n   *\n   * #### Notes\n   * This object is only used by cell editor controller.\n   * If not set, controller picks the most suitable editor\n   * for the particular cell configuration.\n   */\n  editor?: ICellEditor;\n  /**\n   * Cell input validator to use for value validation.\n   */\n  validator?: ICellInputValidator;\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  onCancel?: () => void;\n}\n\n/**\n * A cell input validator object which always returns valid.\n */\nexport class PassInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: unknown\n  ): ICellInputValidatorResponse {\n    return { valid: true };\n  }\n}\n\n/**\n * Text cell input validator.\n */\nexport class TextInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: string\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (typeof value !== 'string') {\n      return {\n        valid: false,\n        message: 'Input must be valid text'\n      };\n    }\n\n    if (!isNaN(this.minLength) && value.length < this.minLength) {\n      return {\n        valid: false,\n        message: `Text length must be greater than ${this.minLength}`\n      };\n    }\n\n    if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n      return {\n        valid: false,\n        message: `Text length must be less than ${this.maxLength}`\n      };\n    }\n\n    if (this.pattern && !this.pattern.test(value)) {\n      return {\n        valid: false,\n        message: `Text doesn't match the required pattern`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum text length\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  minLength: number = Number.NaN;\n  /**\n   * Maximum text length\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  maxLength: number = Number.NaN;\n  /**\n   * Required text pattern as regular expression\n   *\n   * The default is null, meaning no pattern constraint\n   */\n  pattern: RegExp | null = null;\n}\n\n/**\n * Integer cell input validator.\n */\nexport class IntegerInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: number\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value) || value % 1 !== 0) {\n      return {\n        valid: false,\n        message: 'Input must be valid integer'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * Real number cell input validator.\n */\nexport class NumberInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(\n    cell: CellEditor.CellConfig,\n    value: number\n  ): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value)) {\n      return {\n        valid: false,\n        message: 'Input must be valid number'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   *\n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   *\n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nexport abstract class CellEditor implements ICellEditor, IDisposable {\n  /**\n   * Construct a new cell editor.\n   */\n  constructor() {\n    this.inputChanged.connect(() => {\n      this.validate();\n    });\n  }\n\n  /**\n   * Whether the cell editor is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return;\n    }\n\n    if (this._gridWheelEventHandler) {\n      this.cell.grid.node.removeEventListener(\n        'wheel',\n        this._gridWheelEventHandler\n      );\n      this._gridWheelEventHandler = null;\n    }\n\n    this._closeValidityNotification();\n\n    this._disposed = true;\n    this.cell.grid.node.removeChild(this.viewportOccluder);\n  }\n\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void {\n    this.cell = cell;\n    this.onCommit = options && options.onCommit;\n    this.onCancel = options && options.onCancel;\n\n    this.validator =\n      options && options.validator\n        ? options.validator\n        : this.createValidatorBasedOnType();\n\n    this._gridWheelEventHandler = () => {\n      this._closeValidityNotification();\n      this.updatePosition();\n    };\n\n    cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n\n    this._addContainer();\n\n    this.updatePosition();\n    this.startEditing();\n  }\n\n  /**\n   * Cancel editing the cell.\n   */\n  cancel(): void {\n    if (this._disposed) {\n      return;\n    }\n\n    this.dispose();\n    if (this.onCancel) {\n      this.onCancel();\n    }\n  }\n\n  /**\n   * Start editing the cell. Usually an editor widget is created and\n   *  added to `editorContainer`\n   */\n  protected abstract startEditing(): void;\n  /**\n   * Return the current input entered. This method throws exceptions\n   * if input is invalid. Error message in exception is shown as notification.\n   */\n  protected abstract getInput(): any;\n\n  /**\n   * Whether the value input is valid.\n   */\n  protected get validInput(): boolean {\n    return this._validInput;\n  }\n\n  /**\n   * Validate the cell input. Shows validation error notification when input is invalid.\n   */\n  protected validate(): void {\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      return;\n    }\n\n    if (this.validator) {\n      const result = this.validator.validate(this.cell, value);\n      if (result.valid) {\n        this.setValidity(true);\n      } else {\n        this.setValidity(\n          false,\n          result.message || DEFAULT_INVALID_INPUT_MESSAGE\n        );\n      }\n    } else {\n      this.setValidity(true);\n    }\n  }\n\n  /**\n   * Set validity flag.\n   *\n   * @param valid - Whether the input is valid.\n   *\n   * @param message - Notification message to show.\n   *\n   * If message is set to empty string (which is the default)\n   * existing notification popup is removed if any.\n   */\n  protected setValidity(valid: boolean, message: string = ''): void {\n    this._validInput = valid;\n\n    this._closeValidityNotification();\n\n    if (valid) {\n      this.editorContainer.classList.remove('lm-mod-invalid');\n    } else {\n      this.editorContainer.classList.add('lm-mod-invalid');\n\n      // show a notification popup\n      if (message !== '') {\n        this.validityNotification = new CellEditor.Notification({\n          target: this.editorContainer,\n          message: message,\n          placement: 'bottom',\n          timeout: 5000\n        });\n        this.validityNotification.show();\n      }\n    }\n  }\n\n  /**\n   * Create and return a cell input validator based on configuration of the\n   * cell being edited. If no suitable validator can be found, it returns undefined.\n   */\n  protected createValidatorBasedOnType(): ICellInputValidator | undefined {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n\n    switch (metadata && metadata.type) {\n      case 'string':\n        {\n          const validator = new TextInputValidator();\n          if (typeof metadata!.format === 'string') {\n            const format = metadata!.format;\n            switch (format) {\n              case 'email':\n                validator.pattern = new RegExp(\n                  '^([a-z0-9_.-]+)@([da-z.-]+).([a-z.]{2,6})$'\n                );\n                break;\n              case 'uuid':\n                validator.pattern = new RegExp(\n                  '[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'\n                );\n                break;\n              case 'uri':\n                // TODO\n                break;\n              case 'binary':\n                // TODO\n                break;\n            }\n          }\n\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minLength !== undefined) {\n              validator.minLength = metadata!.constraint.minLength;\n            }\n            if (metadata!.constraint.maxLength !== undefined) {\n              validator.maxLength = metadata!.constraint.maxLength;\n            }\n            if (typeof metadata!.constraint.pattern === 'string') {\n              validator.pattern = new RegExp(metadata!.constraint.pattern);\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'number':\n        {\n          const validator = new NumberInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'integer':\n        {\n          const validator = new IntegerInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Compute cell rectangle and return with other cell properties.\n   */\n  protected getCellInfo(cell: CellEditor.CellConfig): Private.ICellInfo {\n    const { grid, row, column } = cell;\n    let data, columnX, rowY, width, height;\n    const cellGroup = CellGroup.getGroup(grid.dataModel!, 'body', row, column);\n\n    if (cellGroup) {\n      columnX =\n        grid.headerWidth -\n        grid.scrollX +\n        grid.columnOffset('body', cellGroup.c1);\n      rowY =\n        grid.headerHeight - grid.scrollY + grid.rowOffset('body', cellGroup.r1);\n      width = 0;\n      height = 0;\n\n      for (let r = cellGroup.r1; r <= cellGroup.r2; r++) {\n        height += grid.rowSize('body', r);\n      }\n\n      for (let c = cellGroup.c1; c <= cellGroup.c2; c++) {\n        width += grid.columnSize('body', c);\n      }\n\n      data = grid.dataModel!.data('body', cellGroup.r1, cellGroup.c1);\n    } else {\n      columnX =\n        grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n      rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n      width = grid.columnSize('body', column);\n      height = grid.rowSize('body', row);\n      data = grid.dataModel!.data('body', row, column);\n    }\n\n    return {\n      grid: grid,\n      row: row,\n      column: column,\n      data: data,\n      x: columnX,\n      y: rowY,\n      width: width,\n      height: height\n    };\n  }\n\n  /**\n   * Reposition cell editor by moving viewport occluder and cell editor container.\n   */\n  protected updatePosition(): void {\n    const grid = this.cell.grid;\n    const cellInfo = this.getCellInfo(this.cell);\n    const headerHeight = grid.headerHeight;\n    const headerWidth = grid.headerWidth;\n\n    this.viewportOccluder.style.top = headerHeight + 'px';\n    this.viewportOccluder.style.left = headerWidth + 'px';\n    this.viewportOccluder.style.width = grid.viewportWidth - headerWidth + 'px';\n    this.viewportOccluder.style.height =\n      grid.viewportHeight - headerHeight + 'px';\n    this.viewportOccluder.style.position = 'absolute';\n\n    this.editorContainer.style.left = cellInfo.x - 1 - headerWidth + 'px';\n    this.editorContainer.style.top = cellInfo.y - 1 - headerHeight + 'px';\n    this.editorContainer.style.width = cellInfo.width + 1 + 'px';\n    this.editorContainer.style.height = cellInfo.height + 1 + 'px';\n    this.editorContainer.style.visibility = 'visible';\n    this.editorContainer.style.position = 'absolute';\n  }\n\n  /**\n   * Commit the edited value.\n   *\n   * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n   *\n   * @returns true on valid input, false otherwise.\n   */\n  protected commit(\n    cursorMovement: SelectionModel.CursorMoveDirection = 'none'\n  ): boolean {\n    this.validate();\n\n    if (!this._validInput) {\n      return false;\n    }\n\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      return false;\n    }\n\n    this.dispose();\n\n    if (this.onCommit) {\n      this.onCommit({\n        cell: this.cell,\n        value: value,\n        cursorMovement: cursorMovement\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Create container elements needed to prevent editor widget overflow\n   * beyond viewport and to position cell editor widget.\n   */\n  private _addContainer() {\n    this.viewportOccluder = document.createElement('div');\n    this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n    this.cell.grid.node.appendChild(this.viewportOccluder);\n\n    this.editorContainer = document.createElement('div');\n    this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n    this.viewportOccluder.appendChild(this.editorContainer);\n\n    // update mouse event pass-through state based on input validity\n    this.editorContainer.addEventListener('mouseleave', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = this._validInput\n        ? 'none'\n        : 'auto';\n    });\n    this.editorContainer.addEventListener('mouseenter', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = 'none';\n    });\n  }\n\n  /**\n   * Remove validity notification popup.\n   */\n  private _closeValidityNotification() {\n    if (this.validityNotification) {\n      this.validityNotification.close();\n      this.validityNotification = null;\n    }\n  }\n\n  /**\n   * A signal emitted when input changes.\n   */\n  protected inputChanged = new Signal<this, void>(this);\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  protected onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  protected onCancel?: () => void;\n  /**\n   * Cell configuration data for the cell being edited.\n   */\n  protected cell: CellEditor.CellConfig;\n  /**\n   * Cell input validator to use for the cell being edited.\n   */\n  protected validator: ICellInputValidator | undefined;\n  /**\n   * The div element used to prevent editor widget overflow beyond grid viewport.\n   */\n  protected viewportOccluder: HTMLDivElement;\n  /**\n   * The div element used to contain and position editor widget.\n   */\n  protected editorContainer: HTMLDivElement;\n  /**\n   * Notification popup used to show validation error messages.\n   */\n  protected validityNotification: CellEditor.Notification | null = null;\n  /**\n   * Whether the cell editor is disposed.\n   */\n  private _disposed = false;\n  /**\n   * Whether the value input is valid.\n   */\n  private _validInput: boolean = true;\n  /**\n   * Grid wheel event handler.\n   */\n  private _gridWheelEventHandler:\n    | ((this: HTMLElement, ev: WheelEvent) => any)\n    | null = null;\n}\n\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nexport abstract class InputCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n      case 'input':\n        this._onInput(event);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    this.createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this.input.value = this.deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this.input);\n    this.input.focus();\n    this.input.select();\n\n    this.bindEvents();\n  }\n\n  protected deserialize(value: unknown): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return (value as any).toString();\n  }\n\n  protected createWidget(): void {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    input.spellcheck = false;\n    input.type = this.inputType;\n\n    this.input = input;\n  }\n\n  protected bindEvents(): void {\n    this.input.addEventListener('keydown', this);\n    this.input.addEventListener('blur', this);\n    this.input.addEventListener('input', this);\n  }\n\n  private _unbindEvents() {\n    this.input.removeEventListener('keydown', this);\n    this.input.removeEventListener('blur', this);\n    this.input.removeEventListener('input', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.input.focus();\n    }\n  }\n\n  private _onInput(event: Event) {\n    this.inputChanged.emit(void 0);\n  }\n\n  protected input: HTMLInputElement;\n  protected abstract inputType: string;\n}\n\n/**\n * Cell editor for text cells.\n */\nexport class TextCellEditor extends InputCellEditor {\n  /**\n   * Return the current text input entered.\n   */\n  protected getInput(): string | null {\n    return this.input.value;\n  }\n\n  protected inputType: string = 'text';\n}\n\n/**\n * Cell editor for real number cells.\n */\nexport class NumberCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    super.startEditing();\n\n    this.input.step = 'any';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current number input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    const floatValue = parseFloat(value);\n    if (isNaN(floatValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return floatValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for integer cells.\n */\nexport class IntegerCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    super.startEditing();\n\n    this.input.step = '1';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current integer input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    let intValue = parseInt(value);\n    if (isNaN(intValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return intValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for date cells.\n */\nexport class DateCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current date input entered.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.type = 'date';\n    input.pattern = 'd{4}-d{2}-d{2}';\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for boolean cells.\n */\nexport class BooleanCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        // fix focus loss problem in Safari and Firefox\n        this._input.focus();\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.checked = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current boolean input entered.\n   */\n  protected getInput(): boolean | null {\n    return this._input.checked;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return false;\n    }\n\n    return value == true;\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorCheckbox');\n    input.type = 'checkbox';\n    input.spellcheck = false;\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('mousedown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('mousedown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for option cells.\n *\n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nexport class OptionCellEditor extends CellEditor {\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    super.dispose();\n\n    if (this._isMultiSelect) {\n      document.body.removeChild(this._select);\n    }\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    this._isMultiSelect = metadata.type === 'array';\n    this._createWidget();\n\n    if (this._isMultiSelect) {\n      this._select.multiple = true;\n      const values = this._deserialize(cellInfo.data) as string[];\n      for (let i = 0; i < this._select.options.length; ++i) {\n        const option = this._select.options.item(i);\n        option!.selected = values.indexOf(option!.value) !== -1;\n      }\n      document.body.appendChild(this._select);\n    } else {\n      this._select.value = this._deserialize(cellInfo.data) as string;\n      this.editorContainer.appendChild(this._select);\n    }\n\n    this._select.focus();\n\n    this._bindEvents();\n\n    this.updatePosition();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | string[] | null {\n    if (this._isMultiSelect) {\n      const input: string[] = [];\n      for (let i = 0; i < this._select.selectedOptions.length; ++i) {\n        input.push(this._select.selectedOptions.item(i)!.value);\n      }\n      return input;\n    } else {\n      return this._select.value;\n    }\n  }\n\n  /**\n   * Reposition cell editor.\n   */\n  protected updatePosition(): void {\n    super.updatePosition();\n\n    if (!this._isMultiSelect) {\n      return;\n    }\n\n    const cellInfo = this.getCellInfo(this.cell);\n\n    this._select.style.position = 'absolute';\n    const editorContainerRect = this.editorContainer.getBoundingClientRect();\n\n    this._select.style.left = editorContainerRect.left + 'px';\n    this._select.style.top = editorContainerRect.top + cellInfo.height + 'px';\n    this._select.style.width = editorContainerRect.width + 'px';\n    this._select.style.maxHeight = '60px';\n\n    this.editorContainer.style.visibility = 'hidden';\n  }\n\n  private _deserialize(value: any): string | string[] {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (this._isMultiSelect) {\n      const values: string[] = [];\n      if (Array.isArray(value)) {\n        for (let item of value) {\n          values.push(item.toString());\n        }\n      }\n      return values;\n    } else {\n      return value.toString();\n    }\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    const items = metadata.constraint.enum;\n\n    const select = document.createElement('select');\n    select.classList.add('lm-DataGrid-cellEditorWidget');\n    for (let item of items) {\n      const option = document.createElement('option');\n      option.value = item;\n      option.text = item;\n      select.appendChild(option);\n    }\n\n    this._select = select;\n  }\n\n  private _bindEvents() {\n    this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n    this._select.addEventListener('blur', this._onBlur.bind(this));\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._select.focus();\n    }\n  }\n\n  private _select: HTMLSelectElement;\n  private _isMultiSelect: boolean = false;\n}\n\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nexport class DynamicOptionCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing(): void {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n    this._input.select();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const grid = cell.grid;\n    const dataModel = grid.dataModel!;\n    const rowCount = dataModel.rowCount('body');\n\n    const listId = 'cell-editor-list';\n    const list = document.createElement('datalist');\n    list.id = listId;\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    const valueSet = new Set<string>();\n    for (let r = 0; r < rowCount; ++r) {\n      const data = dataModel.data('body', r, cell.column);\n      if (data) {\n        valueSet.add(data);\n      }\n    }\n    valueSet.forEach((value: string) => {\n      const option = document.createElement('option');\n      option.value = value;\n      option.text = value;\n      list.appendChild(option);\n    });\n    this.editorContainer.appendChild(list);\n    input.setAttribute('list', listId);\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * The namespace for the `CellEditor` class statics.\n */\nexport namespace CellEditor {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export type CellConfig = {\n    /**\n     * The grid containing the cell.\n     */\n    readonly grid: DataGrid;\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n  };\n\n  /**\n   * A widget which implements a notification popup.\n   */\n  export class Notification extends Widget {\n    /**\n     * Construct a new notification.\n     *\n     * @param options - The options for initializing the notification.\n     */\n    constructor(options: Notification.IOptions) {\n      super({ node: Notification.createNode() });\n      this.addClass('lm-DataGrid-notification');\n      this.setFlag(Widget.Flag.DisallowLayout);\n\n      this._target = options.target;\n      this._message = options.message || '';\n      this._placement = options.placement || 'bottom';\n\n      Widget.attach(this, document.body);\n\n      if (options.timeout && options.timeout > 0) {\n        setTimeout(() => {\n          this.close();\n        }, options.timeout);\n      }\n    }\n\n    /**\n     * Handle the DOM events for the notification.\n     *\n     * @param event - The DOM event sent to the notification.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notification's DOM node.\n     *\n     * This should not be called directly by user code.\n     */\n    handleEvent(event: Event): void {\n      switch (event.type) {\n        case 'mousedown':\n          this._evtMouseDown(event as MouseEvent);\n          break;\n        case 'contextmenu':\n          event.preventDefault();\n          event.stopPropagation();\n          break;\n      }\n    }\n\n    /**\n     * Get the placement of the notification.\n     */\n    get placement(): Notification.Placement {\n      return this._placement;\n    }\n\n    /**\n     * Set the placement of the notification.\n     */\n    set placement(value: Notification.Placement) {\n      // Do nothing if the placement does not change.\n      if (this._placement === value) {\n        return;\n      }\n\n      // Update the internal placement.\n      this._placement = value;\n\n      // Schedule an update for notification.\n      this.update();\n    }\n\n    /**\n     * Get the current value of the message.\n     */\n    get message(): string {\n      return this._message;\n    }\n\n    /**\n     * Set the current value of the message.\n     *\n     */\n    set message(value: string) {\n      // Do nothing if the value does not change.\n      if (this._message === value) {\n        return;\n      }\n\n      // Update the internal value.\n      this._message = value;\n\n      // Schedule an update for notification.\n      this.update();\n    }\n\n    /**\n     * Get the node presenting the message.\n     */\n    get messageNode(): HTMLSpanElement {\n      return this.node.getElementsByClassName(\n        'lm-DataGrid-notificationMessage'\n      )[0] as HTMLSpanElement;\n    }\n\n    /**\n     * A method invoked on a 'before-attach' message.\n     */\n    protected onBeforeAttach(msg: Message): void {\n      this.node.addEventListener('mousedown', this);\n      this.update();\n    }\n\n    /**\n     * A method invoked on an 'after-detach' message.\n     */\n    protected onAfterDetach(msg: Message): void {\n      this.node.removeEventListener('mousedown', this);\n    }\n\n    /**\n     * A method invoked on an 'update-request' message.\n     */\n    protected onUpdateRequest(msg: Message): void {\n      const targetRect = this._target.getBoundingClientRect();\n      const style = this.node.style;\n\n      switch (this._placement) {\n        case 'bottom':\n          style.left = targetRect.left + 'px';\n          style.top = targetRect.bottom + 'px';\n          break;\n        case 'top':\n          style.left = targetRect.left + 'px';\n          style.height = targetRect.top + 'px';\n          style.top = '0';\n          style.alignItems = 'flex-end';\n          style.justifyContent = 'flex-end';\n          break;\n        case 'left':\n          style.left = '0';\n          style.width = targetRect.left + 'px';\n          style.top = targetRect.top + 'px';\n          style.alignItems = 'flex-end';\n          style.justifyContent = 'flex-end';\n          break;\n        case 'right':\n          style.left = targetRect.right + 'px';\n          style.top = targetRect.top + 'px';\n          break;\n      }\n\n      this.messageNode.innerHTML = this._message;\n    }\n\n    /**\n     * Handle the `'mousedown'` event for the notification.\n     */\n    private _evtMouseDown(event: MouseEvent): void {\n      // Do nothing if it's not a left mouse press.\n      if (event.button !== 0) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n      this.close();\n    }\n\n    private _target: HTMLElement;\n    private _message: string = '';\n    private _placement: Notification.Placement;\n  }\n\n  /**\n   * The namespace for the `Notification` class statics.\n   */\n  export namespace Notification {\n    /**\n     * A type alias for a notification placement.\n     */\n    export type Placement = 'top' | 'bottom' | 'left' | 'right';\n\n    /**\n     * An options object for creating a notification.\n     */\n    export interface IOptions {\n      /**\n       * Target element to attach notification to.\n       *\n       */\n      target: HTMLElement;\n\n      /**\n       * The message to show on notification.\n       */\n      message?: string;\n\n      /**\n       * The placement of the notification.\n       *\n       * The default is `'bottom'`.\n       */\n      placement?: Placement;\n\n      /**\n       * Duration in ms after which to close notification popup.\n       *\n       * The default is undefined, and notification is kept visible\n       * Timeout value needs to be greater than zero\n       */\n      timeout?: number;\n    }\n\n    /**\n     * Create the DOM node for notification.\n     */\n    export function createNode(): HTMLElement {\n      const node = document.createElement('div');\n      const container = document.createElement('div');\n      container.className = 'lm-DataGrid-notificationContainer';\n      const message = document.createElement('span');\n      message.className = 'lm-DataGrid-notificationMessage';\n      container.appendChild(message);\n      node.appendChild(container);\n\n      return node;\n    }\n  }\n}\n\n/**\n * A namespace for module-private functionality.\n */\nnamespace Private {\n  /**\n   * A type alias for cell properties.\n   */\n  export type ICellInfo = {\n    grid: DataGrid;\n    row: number;\n    column: number;\n    data: any;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  BooleanCellEditor,\n  CellDataType,\n  CellEditor,\n  DateCellEditor,\n  DynamicOptionCellEditor,\n  ICellEditOptions,\n  ICellEditor,\n  ICellEditResponse,\n  IntegerCellEditor,\n  NumberCellEditor,\n  OptionCellEditor,\n  TextCellEditor\n} from './celleditor';\n\nimport { CellGroup } from './cellgroup';\n\nimport { DataModel, MutableDataModel } from './datamodel';\n\n/**\n * A type alias for cell editor override identifier.\n */\nexport type EditorOverrideIdentifier =\n  | CellDataType\n  | DataModel.Metadata\n  | 'default';\n\n/**\n * An object which manages cell editing.\n */\nexport interface ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(\n    identifier: EditorOverrideIdentifier,\n    editor: ICellEditor | Resolver\n  ): void;\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean;\n  /**\n   * Cancel editing.\n   */\n  cancel(): void;\n}\n\n/**\n * A type alias for a cell editor config function.\n *\n * This type is used to compute a value from a cell config object.\n */\nexport type ConfigFunc<T> = (config: CellEditor.CellConfig) => T;\n\n/**\n * A type alias for a cell editor config option.\n *\n * A config option can be a static value or a config function.\n */\nexport type ConfigOption<T> = T | ConfigFunc<T>;\n\n/**\n * A type alias for a cell editor resolver function.\n */\nexport type Resolver = ConfigFunc<ICellEditor | undefined>;\n\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nexport function resolveOption<T>(\n  option: ConfigOption<T>,\n  config: CellEditor.CellConfig\n): T {\n  return typeof option === 'function'\n    ? (option as ConfigFunc<T>)(config)\n    : option;\n}\n\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nexport class CellEditorController implements ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(\n    identifier: EditorOverrideIdentifier,\n    editor: ICellEditor | Resolver\n  ): void {\n    if (typeof identifier === 'string') {\n      this._typeBasedOverrides.set(identifier, editor);\n    } else {\n      const key = this._metadataIdentifierToKey(identifier);\n      this._metadataBasedOverrides.set(key, [identifier, editor]);\n    }\n  }\n\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean {\n    const grid = cell.grid;\n\n    if (!grid.editable) {\n      console.error('Grid cannot be edited!');\n      return false;\n    }\n\n    this.cancel();\n\n    this._cell = cell;\n\n    options = options || {};\n    options.onCommit = options.onCommit || this._onCommit.bind(this);\n    options.onCancel = options.onCancel || this._onCancel.bind(this);\n\n    // if an editor is passed in with options, then use it for editing\n    if (options.editor) {\n      this._editor = options.editor;\n      options.editor.edit(cell, options);\n      return true;\n    }\n\n    // choose an editor based on overrides / cell data type\n    const editor = this._getEditor(cell);\n    if (editor) {\n      this._editor = editor;\n      editor.edit(cell, options);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel editing.\n   */\n  cancel(): void {\n    if (this._editor) {\n      this._editor.cancel();\n      this._editor = null;\n    }\n\n    this._cell = null;\n  }\n\n  private _onCommit(response: ICellEditResponse): void {\n    const cell = this._cell;\n\n    if (!cell) {\n      return;\n    }\n\n    const grid = cell.grid;\n    const dataModel = grid.dataModel as MutableDataModel;\n    let row = cell.row;\n    let column = cell.column;\n\n    const cellGroup = CellGroup.getGroup(grid.dataModel!, 'body', row, column);\n    if (cellGroup) {\n      row = cellGroup.r1;\n      column = cellGroup.c1;\n    }\n\n    dataModel.setData('body', row, column, response.value);\n    grid.viewport.node.focus();\n    if (response.cursorMovement !== 'none') {\n      grid.moveCursor(response.cursorMovement);\n      grid.scrollToCursor();\n    }\n  }\n\n  private _onCancel(): void {\n    if (!this._cell) {\n      return;\n    }\n\n    this._cell.grid.viewport.node.focus();\n  }\n\n  private _getDataTypeKey(cell: CellEditor.CellConfig): string {\n    const metadata = cell.grid.dataModel\n      ? cell.grid.dataModel.metadata('body', cell.row, cell.column)\n      : null;\n\n    if (!metadata) {\n      return 'default';\n    }\n\n    let key = '';\n\n    if (metadata) {\n      key = metadata.type;\n    }\n\n    if (metadata.constraint && metadata.constraint.enum) {\n      if (metadata.constraint.enum === 'dynamic') {\n        key += ':dynamic-option';\n      } else {\n        key += ':option';\n      }\n    }\n\n    return key;\n  }\n\n  private _objectToKey(object: any): string {\n    let str = '';\n    for (let key in object) {\n      const value = object[key];\n      if (typeof value === 'object') {\n        str += `${key}:${this._objectToKey(value)}`;\n      } else {\n        str += `[${key}:${value}]`;\n      }\n    }\n\n    return str;\n  }\n\n  private _metadataIdentifierToKey(metadata: DataModel.Metadata): string {\n    return this._objectToKey(metadata);\n  }\n\n  private _metadataMatchesIdentifier(\n    metadata: DataModel.Metadata,\n    identifier: DataModel.Metadata\n  ): boolean {\n    for (let key in identifier) {\n      if (!metadata.hasOwnProperty(key)) {\n        return false;\n      }\n\n      const identifierValue = identifier[key];\n      const metadataValue = metadata[key];\n      if (typeof identifierValue === 'object') {\n        if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n          return false;\n        }\n      } else if (metadataValue !== identifierValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _getMetadataBasedEditor(\n    cell: CellEditor.CellConfig\n  ): ICellEditor | undefined {\n    let editorMatched: ICellEditor | undefined;\n    const metadata = cell.grid.dataModel!.metadata(\n      'body',\n      cell.row,\n      cell.column\n    );\n    if (metadata) {\n      this._metadataBasedOverrides.forEach(value => {\n        if (!editorMatched) {\n          let [identifier, editor] = value;\n          if (this._metadataMatchesIdentifier(metadata, identifier)) {\n            editorMatched = resolveOption(editor, cell);\n          }\n        }\n      });\n    }\n\n    return editorMatched;\n  }\n\n  /**\n   * Choose the most appropriate cell editor to use based on overrides / cell data type.\n   *\n   * If no match is found in overrides or based on cell data type, and if cell has a primitive\n   * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n   * is overridden, then it is used instead of TextCellEditor for default.\n   */\n  private _getEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    const dtKey = this._getDataTypeKey(cell);\n\n    // find an editor based on data type based override\n    if (this._typeBasedOverrides.has(dtKey)) {\n      const editor = this._typeBasedOverrides.get(dtKey);\n      return resolveOption(editor!, cell);\n    } // find an editor based on metadata match based override\n    else if (this._metadataBasedOverrides.size > 0) {\n      const editor = this._getMetadataBasedEditor(cell);\n      if (editor) {\n        return editor;\n      }\n    }\n\n    // choose an editor based on data type\n    switch (dtKey) {\n      case 'string':\n        return new TextCellEditor();\n      case 'number':\n        return new NumberCellEditor();\n      case 'integer':\n        return new IntegerCellEditor();\n      case 'boolean':\n        return new BooleanCellEditor();\n      case 'date':\n        return new DateCellEditor();\n      case 'string:option':\n      case 'number:option':\n      case 'integer:option':\n      case 'date:option':\n      case 'array:option':\n        return new OptionCellEditor();\n      case 'string:dynamic-option':\n      case 'number:dynamic-option':\n      case 'integer:dynamic-option':\n      case 'date:dynamic-option':\n        return new DynamicOptionCellEditor();\n    }\n\n    // if an override exists for 'default', then use it\n    if (this._typeBasedOverrides.has('default')) {\n      const editor = this._typeBasedOverrides.get('default');\n      return resolveOption(editor!, cell);\n    }\n\n    // if cell has a primitive data type then use TextCellEditor\n    const data = cell.grid.dataModel!.data('body', cell.row, cell.column);\n    if (!data || typeof data !== 'object') {\n      return new TextCellEditor();\n    }\n\n    // no suitable editor found for the cell\n    return undefined;\n  }\n\n  // active cell editor\n  private _editor: ICellEditor | null = null;\n  // active cell being edited\n  private _cell: CellEditor.CellConfig | null = null;\n  // cell editor overrides based on cell data type identifier\n  private _typeBasedOverrides: Map<string, ICellEditor | Resolver> = new Map();\n  // cell editor overrides based on partial metadata match\n  private _metadataBasedOverrides: Map<\n    string,\n    [DataModel.Metadata, ICellEditor | Resolver]\n  > = new Map();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { CellGroup } from './cellgroup';\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nexport abstract class DataModel {\n  /**\n   * A signal emitted when the data model has changed.\n   */\n  get changed(): ISignal<this, DataModel.ChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract rowCount(region: DataModel.RowRegion): number;\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract columnCount(region: DataModel.ColumnRegion): number;\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The data value for the specified cell.\n   *\n   * #### Notes\n   * The returned data should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   */\n  abstract data(region: DataModel.CellRegion, row: number, column: number): any;\n\n  /**\n   * Get the count of merged cell groups pertaining to a given\n   * cell region.\n   * @param region the target cell region.\n   */\n  groupCount(region: DataModel.CellRegion): number {\n    return 0;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the specified cell.\n   *\n   * #### Notes\n   * The returned metadata should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   *\n   * The default implementation returns `{}`.\n   */\n  metadata(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): DataModel.Metadata {\n    return DataModel.emptyMetadata;\n  }\n\n  /**\n   * Get the merged cell group corresponding to a region and index number.\n   * @param region the cell region of cell group.\n   * @param groupIndex the group index of the cell group.\n   * @returns a cell group.\n   */\n  group(region: DataModel.CellRegion, groupIndex: number): CellGroup | null {\n    return null;\n  }\n\n  /**\n   * Emit the `changed` signal for the data model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the data model has\n   * changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(args: DataModel.ChangedArgs): void {\n    this._changed.emit(args);\n  }\n\n  private _changed = new Signal<this, DataModel.ChangedArgs>(this);\n}\n\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nexport abstract class MutableDataModel extends DataModel {\n  /**\n   * Set the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns true if succeeds, false otherwise.\n   *\n   */\n  abstract setData(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number,\n    value: unknown\n  ): boolean;\n}\n\n/**\n * The namespace for the `DataModel` class statics.\n */\nexport namespace DataModel {\n  /**\n   * A type alias for the data model row regions.\n   */\n  export type RowRegion = 'body' | 'column-header';\n\n  /**\n   * A type alias for the data model column regions.\n   */\n  export type ColumnRegion = 'body' | 'row-header';\n\n  /**\n   * A type alias for the data model cell regions.\n   */\n  export type CellRegion =\n    | 'body'\n    | 'row-header'\n    | 'column-header'\n    | 'corner-header';\n\n  /**\n   * The metadata for a column in a data model.\n   */\n  export type Metadata = { [key: string]: any };\n\n  /**\n   * A singleton empty metadata object.\n   */\n  export const emptyMetadata: Metadata = Object.freeze({});\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are inserted or removed.\n   */\n  export type RowsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-inserted' | 'rows-removed';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are inserted or removed.\n   */\n  export type ColumnsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-inserted' | 'columns-removed';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are moved.\n   */\n  export type RowsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-moved';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The starting index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified row.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are moved.\n   */\n  export type ColumnsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-moved';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The starting index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified column.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when cells are changed in-place.\n   */\n  export type CellsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'cells-changed';\n\n    /**\n     * The region which contains the modified cells.\n     */\n    readonly region: CellRegion;\n\n    /**\n     * The row index of the first modified cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the first modified cell.\n     */\n    readonly column: number;\n\n    /**\n     * The number of rows in the modified cell range.\n     */\n    readonly rowSpan: number;\n\n    /**\n     * The number of columns in the modified cell range.\n     */\n    readonly columnSpan: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when the model has changed in a fashion that cannot be easily\n   * expressed by the other args object types.\n   *\n   * This is the \"big hammer\" approach, and will cause any associated\n   * data grid to perform a full reset. The other changed args types\n   * should be used whenever possible.\n   */\n  export type ModelResetArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'model-reset';\n  };\n\n  /**\n   * A type alias for the args objects of the `changed` signal.\n   */\n  export type ChangedArgs =\n    | RowsChangedArgs\n    | ColumnsChangedArgs\n    | RowsMovedArgs\n    | ColumnsMovedArgs\n    | CellsChangedArgs\n    | ModelResetArgs;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nexport class GraphicsContext implements IDisposable {\n  /**\n   * Create a new graphics context object.\n   *\n   * @param context - The 2D canvas rendering context to wrap.\n   */\n  constructor(context: CanvasRenderingContext2D) {\n    this._context = context;\n    this._state = Private.State.create(context);\n  }\n\n  dispose(): void {\n    // Bail if the gc is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Mark the gc as disposed.\n    this._disposed = true;\n\n    // Pop any unrestored saves.\n    while (this._state.next) {\n      this._state = this._state.next;\n      this._context.restore();\n    }\n  }\n\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  get fillStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.fillStyle;\n  }\n\n  set fillStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.fillStyle !== value) {\n      this._state.fillStyle = value;\n      this._context.fillStyle = value;\n    }\n  }\n\n  get strokeStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.strokeStyle;\n  }\n\n  set strokeStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.strokeStyle !== value) {\n      this._state.strokeStyle = value;\n      this._context.strokeStyle = value;\n    }\n  }\n\n  get font(): string {\n    return this._context.font;\n  }\n\n  set font(value: string) {\n    if (this._state.font !== value) {\n      this._state.font = value;\n      this._context.font = value;\n    }\n  }\n\n  get textAlign(): CanvasTextAlign {\n    return this._context.textAlign;\n  }\n\n  set textAlign(value: CanvasTextAlign) {\n    if (this._state.textAlign !== value) {\n      this._state.textAlign = value;\n      this._context.textAlign = value;\n    }\n  }\n\n  get textBaseline(): CanvasTextBaseline {\n    return this._context.textBaseline;\n  }\n\n  set textBaseline(value: CanvasTextBaseline) {\n    if (this._state.textBaseline !== value) {\n      this._state.textBaseline = value;\n      this._context.textBaseline = value;\n    }\n  }\n\n  get lineCap(): CanvasLineCap {\n    return this._context.lineCap;\n  }\n\n  set lineCap(value: CanvasLineCap) {\n    if (this._state.lineCap !== value) {\n      this._state.lineCap = value;\n      this._context.lineCap = value;\n    }\n  }\n\n  get lineDashOffset(): number {\n    return this._context.lineDashOffset;\n  }\n\n  set lineDashOffset(value: number) {\n    if (this._state.lineDashOffset !== value) {\n      this._state.lineDashOffset = value;\n      this._context.lineDashOffset = value;\n    }\n  }\n\n  get lineJoin(): CanvasLineJoin {\n    return this._context.lineJoin;\n  }\n\n  set lineJoin(value: CanvasLineJoin) {\n    if (this._state.lineJoin !== value) {\n      this._state.lineJoin = value;\n      this._context.lineJoin = value;\n    }\n  }\n\n  get lineWidth(): number {\n    return this._context.lineWidth;\n  }\n\n  set lineWidth(value: number) {\n    if (this._state.lineWidth !== value) {\n      this._state.lineWidth = value;\n      this._context.lineWidth = value;\n    }\n  }\n\n  get miterLimit(): number {\n    return this._context.miterLimit;\n  }\n\n  set miterLimit(value: number) {\n    if (this._state.miterLimit !== value) {\n      this._state.miterLimit = value;\n      this._context.miterLimit = value;\n    }\n  }\n\n  get shadowBlur(): number {\n    return this._context.shadowBlur;\n  }\n\n  set shadowBlur(value: number) {\n    if (this._state.shadowBlur !== value) {\n      this._state.shadowBlur = value;\n      this._context.shadowBlur = value;\n    }\n  }\n\n  get shadowColor(): string {\n    return this._context.shadowColor;\n  }\n\n  set shadowColor(value: string) {\n    if (this._state.shadowColor !== value) {\n      this._state.shadowColor = value;\n      this._context.shadowColor = value;\n    }\n  }\n\n  get shadowOffsetX(): number {\n    return this._context.shadowOffsetX;\n  }\n\n  set shadowOffsetX(value: number) {\n    if (this._state.shadowOffsetX !== value) {\n      this._state.shadowOffsetX = value;\n      this._context.shadowOffsetX = value;\n    }\n  }\n\n  get shadowOffsetY(): number {\n    return this._context.shadowOffsetY;\n  }\n\n  set shadowOffsetY(value: number) {\n    if (this._state.shadowOffsetY !== value) {\n      this._state.shadowOffsetY = value;\n      this._context.shadowOffsetY = value;\n    }\n  }\n\n  get imageSmoothingEnabled(): boolean {\n    return this._context.imageSmoothingEnabled;\n  }\n\n  set imageSmoothingEnabled(value: boolean) {\n    if (this._state.imageSmoothingEnabled !== value) {\n      this._state.imageSmoothingEnabled = value;\n      this._context.imageSmoothingEnabled = value;\n    }\n  }\n\n  get globalAlpha(): number {\n    return this._context.globalAlpha;\n  }\n\n  set globalAlpha(value: number) {\n    if (this._state.globalAlpha !== value) {\n      this._state.globalAlpha = value;\n      this._context.globalAlpha = value;\n    }\n  }\n\n  get globalCompositeOperation(): GlobalCompositeOperation {\n    return this._context.globalCompositeOperation;\n  }\n\n  set globalCompositeOperation(value: GlobalCompositeOperation) {\n    if (this._state.globalCompositeOperation !== value) {\n      this._state.globalCompositeOperation = value;\n      this._context.globalCompositeOperation = value;\n    }\n  }\n\n  getLineDash(): number[] {\n    return this._context.getLineDash();\n  }\n\n  setLineDash(segments: number[]): void {\n    this._context.setLineDash(segments);\n  }\n\n  rotate(angle: number): void {\n    this._context.rotate(angle);\n  }\n\n  scale(x: number, y: number): void {\n    this._context.scale(x, y);\n  }\n\n  transform(\n    m11: number,\n    m12: number,\n    m21: number,\n    m22: number,\n    dx: number,\n    dy: number\n  ): void {\n    this._context.transform(m11, m12, m21, m22, dx, dy);\n  }\n\n  translate(x: number, y: number): void {\n    this._context.translate(x, y);\n  }\n\n  setTransform(\n    m11: number,\n    m12: number,\n    m21: number,\n    m22: number,\n    dx: number,\n    dy: number\n  ): void {\n    this._context.setTransform(m11, m12, m21, m22, dx, dy);\n  }\n\n  save(): void {\n    // Clone an push the current state to the stack.\n    this._state = Private.State.push(this._state);\n\n    // Save the wrapped context state.\n    this._context.save();\n  }\n\n  restore(): void {\n    // Bail if there is no state to restore.\n    if (!this._state.next) {\n      return;\n    }\n\n    // Pop the saved state from the stack.\n    this._state = Private.State.pop(this._state);\n\n    // Restore the wrapped context state.\n    this._context.restore();\n  }\n\n  beginPath(): void {\n    return this._context.beginPath();\n  }\n\n  closePath(): void {\n    this._context.closePath();\n  }\n\n  isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean {\n    let result: boolean;\n    if (arguments.length === 2) {\n      result = this._context.isPointInPath(x, y);\n    } else {\n      result = this._context.isPointInPath(x, y, fillRule);\n    }\n    return result;\n  }\n\n  arc(\n    x: number,\n    y: number,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean\n  ): void {\n    if (arguments.length === 5) {\n      this._context.arc(x, y, radius, startAngle, endAngle);\n    } else {\n      this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n\n  bezierCurveTo(\n    cp1x: number,\n    cp1y: number,\n    cp2x: number,\n    cp2y: number,\n    x: number,\n    y: number\n  ): void {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n\n  ellipse(\n    x: number,\n    y: number,\n    radiusX: number,\n    radiusY: number,\n    rotation: number,\n    startAngle: number,\n    endAngle: number,\n    anticlockwise?: boolean\n  ): void {\n    if (arguments.length === 7) {\n      this._context.ellipse(\n        x,\n        y,\n        radiusX,\n        radiusY,\n        rotation,\n        startAngle,\n        endAngle\n      );\n    } else {\n      this._context.ellipse(\n        x,\n        y,\n        radiusX,\n        radiusY,\n        rotation,\n        startAngle,\n        endAngle,\n        anticlockwise\n      );\n    }\n  }\n\n  lineTo(x: number, y: number): void {\n    this._context.lineTo(x, y);\n  }\n\n  moveTo(x: number, y: number): void {\n    this._context.moveTo(x, y);\n  }\n\n  quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    this._context.rect(x, y, w, h);\n  }\n\n  clip(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.clip();\n    } else {\n      this._context.clip(fillRule);\n    }\n  }\n\n  fill(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.fill();\n    } else {\n      this._context.fill(fillRule);\n    }\n  }\n\n  stroke(): void {\n    this._context.stroke();\n  }\n\n  clearRect(x: number, y: number, w: number, h: number): void {\n    return this._context.clearRect(x, y, w, h);\n  }\n\n  fillRect(x: number, y: number, w: number, h: number): void {\n    this._context.fillRect(x, y, w, h);\n  }\n\n  fillText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.fillText(text, x, y);\n    } else {\n      this._context.fillText(text, x, y, maxWidth);\n    }\n  }\n\n  strokeRect(x: number, y: number, w: number, h: number): void {\n    this._context.strokeRect(x, y, w, h);\n  }\n\n  strokeText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.strokeText(text, x, y);\n    } else {\n      this._context.strokeText(text, x, y, maxWidth);\n    }\n  }\n\n  measureText(text: string): TextMetrics {\n    return this._context.measureText(text);\n  }\n\n  createLinearGradient(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number\n  ): CanvasGradient {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(\n    x0: number,\n    y0: number,\n    r0: number,\n    x1: number,\n    y1: number,\n    r1: number\n  ): CanvasGradient {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  createPattern(\n    image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement,\n    repetition: string\n  ): CanvasPattern | null {\n    return this._context.createPattern(image, repetition);\n  }\n\n  createImageData(imageData: ImageData): ImageData;\n  createImageData(sw: number, sh: number): ImageData;\n  createImageData(): ImageData {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    return this._context.createImageData.apply(this._context, arguments);\n  }\n\n  getImageData(sx: number, sy: number, sw: number, sh: number): ImageData {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n\n  putImageData(imagedata: ImageData, dx: number, dy: number): void;\n  putImageData(\n    imagedata: ImageData,\n    dx: number,\n    dy: number,\n    dirtyX: number,\n    dirtyY: number,\n    dirtyWidth: number,\n    dirtyHeight: number\n  ): void;\n  putImageData(): void {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    this._context.putImageData.apply(this._context, arguments);\n  }\n\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    dstX: number,\n    dstY: number\n  ): void;\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    dstX: number,\n    dstY: number,\n    dstW: number,\n    dstH: number\n  ): void;\n  drawImage(\n    image:\n      | HTMLImageElement\n      | HTMLCanvasElement\n      | HTMLVideoElement\n      | ImageBitmap,\n    srcX: number,\n    srcY: number,\n    srcW: number,\n    srcH: number,\n    dstX: number,\n    dstY: number,\n    dstW: number,\n    dstH: number\n  ): void;\n  drawImage(): void {\n    // eslint-disable-next-line prefer-spread, prefer-rest-params\n    this._context.drawImage.apply(this._context, arguments);\n  }\n\n  drawFocusIfNeeded(element: Element): void {\n    this._context.drawFocusIfNeeded(element);\n  }\n\n  private _disposed = false;\n  private _state: Private.State;\n  private _context: CanvasRenderingContext2D;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The index of next valid pool object.\n   */\n  let pi = -1;\n\n  /**\n   * A state object allocation pool.\n   */\n  const pool: State[] = [];\n\n  /**\n   * An object which holds the state for a gc.\n   */\n  export class State {\n    /**\n     * Create a gc state object from a 2D canvas context.\n     */\n    static create(context: CanvasRenderingContext2D): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = null;\n      state.fillStyle = context.fillStyle;\n      state.font = context.font;\n      state.globalAlpha = context.globalAlpha;\n      state.globalCompositeOperation = context.globalCompositeOperation;\n      state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n      state.lineCap = context.lineCap;\n      state.lineDashOffset = context.lineDashOffset;\n      state.lineJoin = context.lineJoin;\n      state.lineWidth = context.lineWidth;\n      state.miterLimit = context.miterLimit;\n      state.shadowBlur = context.shadowBlur;\n      state.shadowColor = context.shadowColor;\n      state.shadowOffsetX = context.shadowOffsetX;\n      state.shadowOffsetY = context.shadowOffsetY;\n      state.strokeStyle = context.strokeStyle;\n      state.textAlign = context.textAlign;\n      state.textBaseline = context.textBaseline;\n      return state;\n    }\n\n    /**\n     * Clone an existing gc state object and add it to the state stack.\n     */\n    static push(other: State): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = other;\n      state.fillStyle = other.fillStyle;\n      state.font = other.font;\n      state.globalAlpha = other.globalAlpha;\n      state.globalCompositeOperation = other.globalCompositeOperation;\n      state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n      state.lineCap = other.lineCap;\n      state.lineDashOffset = other.lineDashOffset;\n      state.lineJoin = other.lineJoin;\n      state.lineWidth = other.lineWidth;\n      state.miterLimit = other.miterLimit;\n      state.shadowBlur = other.shadowBlur;\n      state.shadowColor = other.shadowColor;\n      state.shadowOffsetX = other.shadowOffsetX;\n      state.shadowOffsetY = other.shadowOffsetY;\n      state.strokeStyle = other.strokeStyle;\n      state.textAlign = other.textAlign;\n      state.textBaseline = other.textBaseline;\n      return state;\n    }\n\n    /**\n     * Pop the next state object and return the current to the pool\n     */\n    static pop(state: State): State {\n      state.fillStyle = '';\n      state.strokeStyle = '';\n      pool[++pi] = state;\n      return state.next!;\n    }\n\n    next: State | null;\n\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    font: string;\n    globalAlpha: number;\n    globalCompositeOperation: string;\n    imageSmoothingEnabled: boolean;\n    lineCap: string;\n    lineDashOffset: number;\n    lineJoin: string;\n    lineWidth: number;\n    miterLimit: number;\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    textAlign: string;\n    textBaseline: string;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ArrayExt } from '@lumino/algorithm';\n\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nexport class SectionList {\n  /**\n   * Construct a new section list.\n   *\n   * @param options - The options for initializing the list.\n   */\n  constructor(options: SectionList.IOptions) {\n    this._minimumSize = options.minimumSize || 2;\n    this._defaultSize = Math.max(\n      this._minimumSize,\n      Math.floor(options.defaultSize)\n    );\n  }\n\n  /**\n   * The total size of all sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * The total number of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Get the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get minimumSize(): number {\n    return this._minimumSize;\n  }\n\n  /**\n   * Set the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set minimumSize(value: number) {\n    // Normalize the value.\n    value = Math.max(2, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._minimumSize === value) {\n      return;\n    }\n\n    // Update the internal minimum size.\n    this._minimumSize = value;\n\n    // Update default size if larger than minimum size\n    if (value > this._defaultSize) {\n      this.defaultSize = value;\n    }\n  }\n\n  /**\n   * Get the default size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get defaultSize(): number {\n    return this._defaultSize;\n  }\n\n  /**\n   * Set the default size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set defaultSize(value: number) {\n    // Normalize the value.\n    value = Math.max(this._minimumSize, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._defaultSize === value) {\n      return;\n    }\n\n    // Compute the delta default size.\n    let delta = value - this._defaultSize;\n\n    // Update the internal default size.\n    this._defaultSize = value;\n\n    // Update the length.\n    this._length += delta * (this._count - this._sections.length);\n\n    // Bail early if there are no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Recompute the offsets of the modified sections.\n    for (let i = 0, n = this._sections.length; i < n; ++i) {\n      // Look up the previous and current modified sections.\n      let prev = this._sections[i - 1];\n      let curr = this._sections[i];\n\n      // Adjust the offset for the current section.\n      if (prev) {\n        let count = curr.index - prev.index - 1;\n        curr.offset = prev.offset + prev.size + count * value;\n      } else {\n        curr.offset = curr.index * value;\n      }\n    }\n  }\n\n  /**\n   * Clamp a size to the minimum section size\n   *\n   * @param size - The size to clamp.\n   *\n   * @returns The size or the section minimum size, whichever is larger\n   */\n  clampSize(size: number): number {\n    return Math.max(this._minimumSize, Math.floor(size));\n  }\n\n  /**\n   * Find the index of the section which covers the given offset.\n   *\n   * @param offset - The offset of the section of interest.\n   *\n   * @returns The index of the section which covers the given offset,\n   *   or `-1` if the offset is out of range.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  indexOf(offset: number): number {\n    // Bail early if the offset is out of range.\n    if (offset < 0 || offset >= this._length || this._count === 0) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Find the modified section for the given offset.\n    let i = ArrayExt.lowerBound(this._sections, offset, Private.offsetCmp);\n\n    // Return the index of an exact match.\n    if (i < this._sections.length && this._sections[i].offset <= offset) {\n      return this._sections[i].index;\n    }\n\n    // Handle the case of no modified sections before the offset.\n    if (i === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Compute the index from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = offset - (section.offset + section.size);\n    return section.index + Math.floor(span / this._defaultSize) + 1;\n  }\n\n  /**\n   * Find the offset of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The offset of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  offsetOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index - 1;\n    return section.offset + section.size + span * this._defaultSize;\n  }\n\n  /**\n   * Find the extent of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The extent of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  extentOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset + this._sections[i].size - 1;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index;\n    return section.offset + section.size + span * this._defaultSize - 1;\n  }\n\n  /**\n   * Find the size of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The size of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  sizeOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the size of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].size;\n    }\n\n    // Return the default size for all other cases.\n    return this._defaultSize;\n  }\n\n  /**\n   * Resize a section in the list.\n   *\n   * @param index - The index of the section to resize. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param size - The new size of the section. This value will be\n   *   clamped to an integer `>= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  resize(index: number, size: number): void {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return;\n    }\n\n    // Clamp the size to an integer >= minimum size.\n    size = Math.max(this._minimumSize, Math.floor(size));\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update or create the modified section as needed.\n    let delta: number;\n    if (i < this._sections.length && this._sections[i].index === index) {\n      let section = this._sections[i];\n      delta = size - section.size;\n      section.size = size;\n    } else if (i === 0) {\n      let offset = index * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    } else {\n      let section = this._sections[i - 1];\n      let span = index - section.index - 1;\n      let offset = section.offset + section.size + span * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    }\n\n    // Adjust the length.\n    this._length += delta;\n\n    // Update all modified sections after the resized section.\n    for (let j = i + 1, n = this._sections.length; j < n; ++j) {\n      this._sections[j].offset += delta;\n    }\n  }\n\n  /**\n   * Insert sections into the list.\n   *\n   * @param index - The index at which to insert the sections. This\n   *   value will be clamped to the bounds of the list.\n   *\n   * @param count - The number of sections to insert. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  insert(index: number, count: number): void {\n    // Bail early if there are no sections to insert.\n    if (count <= 0) {\n      return;\n    }\n\n    // Clamp the index to the bounds of the list.\n    index = Math.max(0, Math.min(index, this._count));\n\n    // Add the new sections to the totals.\n    let span = count * this._defaultSize;\n    this._count += count;\n    this._length += span;\n\n    // Bail early if there are no modified sections to update.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update all modified sections after the insert location.\n    for (let n = this._sections.length; i < n; ++i) {\n      let section = this._sections[i];\n      section.index += count;\n      section.offset += span;\n    }\n  }\n\n  /**\n   * Remove sections from the list.\n   *\n   * @param index - The index of the first section to remove. This\n   *   method is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to remove. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  remove(index: number, count: number): void {\n    // Bail early if there is nothing to remove.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Clamp the count to the bounds of the list.\n    count = Math.min(this._count - index, count);\n\n    // Handle the simple case of no modified sections to update.\n    if (this._sections.length === 0) {\n      this._count -= count;\n      this._length -= count * this._defaultSize;\n      return;\n    }\n\n    // Handle the simple case of removing all sections.\n    if (count === this._count) {\n      this._length = 0;\n      this._count = 0;\n      this._sections.length = 0;\n      return;\n    }\n\n    // Find the modified section for the start index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Find the modified section for the end index.\n    let j = ArrayExt.lowerBound(\n      this._sections,\n      index + count,\n      Private.indexCmp\n    );\n\n    // Remove the relevant modified sections.\n    let removed = this._sections.splice(i, j - i);\n\n    // Compute the total removed span.\n    let span = (count - removed.length) * this._defaultSize;\n    for (let k = 0, n = removed.length; k < n; ++k) {\n      span += removed[k].size;\n    }\n\n    // Adjust the totals.\n    this._count -= count;\n    this._length -= span;\n\n    // Update all modified sections after the removed span.\n    for (let k = i, n = this._sections.length; k < n; ++k) {\n      let section = this._sections[k];\n      section.index -= count;\n      section.offset -= span;\n    }\n  }\n\n  /**\n   * Move sections within the list.\n   *\n   * @param index - The index of the first section to move. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to move. This method is a\n   *   no-op if this value is `<= 0`.\n   *\n   * @param destination - The destination index for the first section.\n   *   This value will be clamped to the allowable range.\n   *\n   * #### Undefined Behavior\n   * An `index`, `count`, or `destination` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of moved resized sections.\n   */\n  move(index: number, count: number, destination: number): void {\n    // Bail early if there is nothing to move.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Clamp the move count to the limit.\n    count = Math.min(count, this._count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), this._count - count);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let i1 = Math.min(index, destination);\n\n    // Look up the first affected modified section.\n    let k1 = ArrayExt.lowerBound(this._sections, i1, Private.indexCmp);\n\n    // Bail early if there are no affected modified sections.\n    if (k1 === this._sections.length) {\n      return;\n    }\n\n    // Compute the last affected index.\n    let i2 = Math.max(index + count - 1, destination + count - 1);\n\n    // Look up the last affected modified section.\n    let k2 = ArrayExt.upperBound(this._sections, i2, Private.indexCmp) - 1;\n\n    // Bail early if there are no affected modified sections.\n    if (k2 < k1) {\n      return;\n    }\n\n    // Compute the pivot index.\n    let pivot = destination < index ? index : index + count;\n\n    // Compute the count for each side of the pivot.\n    let count1 = pivot - i1;\n    let count2 = i2 - pivot + 1;\n\n    // Compute the span for each side of the pivot.\n    let span1 = count1 * this._defaultSize;\n    let span2 = count2 * this._defaultSize;\n\n    // Adjust the spans for the modified sections.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        span1 += section.size - this._defaultSize;\n      } else {\n        span2 += section.size - this._defaultSize;\n      }\n    }\n\n    // Look up the pivot section.\n    let k3 = ArrayExt.lowerBound(this._sections, pivot, Private.indexCmp);\n\n    // Rotate the modified sections if needed.\n    if (k1 <= k3 && k3 <= k2) {\n      ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n    }\n\n    // Adjust the modified section indices and offsets.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        section.index += count2;\n        section.offset += span2;\n      } else {\n        section.index -= count1;\n        section.offset -= span1;\n      }\n    }\n  }\n\n  /**\n   * Reset all modified sections to the default size.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  reset(): void {\n    this._sections.length = 0;\n    this._length = this._count * this._defaultSize;\n  }\n\n  /**\n   * Remove all sections from the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  clear(): void {\n    this._count = 0;\n    this._length = 0;\n    this._sections.length = 0;\n  }\n\n  private _count = 0;\n  private _length = 0;\n  private _minimumSize: number;\n  private _defaultSize: number;\n  private _sections: Private.Section[] = [];\n}\n\n/**\n * The namespace for the `SectionList` class statics.\n */\nexport namespace SectionList {\n  /**\n   * An options object for initializing a section list.\n   */\n  export interface IOptions {\n    /**\n     * The size of new sections added to the list.\n     */\n    defaultSize: number;\n\n    /**\n     * The minimum size of the section list.\n     */\n    minimumSize?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which represents a modified section.\n   */\n  export type Section = {\n    /**\n     * The index of the section.\n     *\n     * This is always `>= 0`.\n     */\n    index: number;\n\n    /**\n     * The offset of the section.\n     */\n    offset: number;\n\n    /**\n     * The size of the section.\n     *\n     * This is always `>= 0`.\n     */\n    size: number;\n  };\n\n  /**\n   * A comparison function for searching by offset.\n   */\n  export function offsetCmp(section: Section, offset: number): number {\n    if (offset < section.offset) {\n      return 1;\n    }\n    if (section.offset + section.size <= offset) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * A comparison function for searching by index.\n   */\n  export function indexCmp(section: Section, index: number): number {\n    return section.index - index;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { IDisposable } from '@lumino/disposable';\n\nimport { ClipboardExt, ElementExt, Platform } from '@lumino/domutils';\n\nimport {\n  ConflatableMessage,\n  IMessageHandler,\n  Message,\n  MessageLoop\n} from '@lumino/messaging';\n\nimport { GridLayout, ScrollBar, Widget } from '@lumino/widgets';\n\nimport { AsyncCellRenderer } from './asynccellrenderer';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { DataModel, MutableDataModel } from './datamodel';\n\nimport { CellGroup } from './cellgroup';\n\nimport { GraphicsContext } from './graphicscontext';\n\nimport { RendererMap } from './renderermap';\n\nimport { SectionList } from './sectionlist';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport {\n  CellEditorController,\n  ICellEditorController\n} from './celleditorcontroller';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n */\nexport class DataGrid extends Widget {\n  /**\n   * Construct a new data grid.\n   *\n   * @param options - The options for initializing the data grid.\n   */\n  constructor(options: DataGrid.IOptions = {}) {\n    super();\n    this.addClass('lm-DataGrid');\n\n    // Parse the simple options.\n    this._style = options.style || DataGrid.defaultStyle;\n    this._stretchLastRow = options.stretchLastRow || false;\n    this._stretchLastColumn = options.stretchLastColumn || false;\n    this._headerVisibility = options.headerVisibility || 'all';\n    this._cellRenderers = options.cellRenderers || new RendererMap();\n    this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n\n    // Connect to the renderer map changed signal.\n    this._cellRenderers.changed.connect(this._onRenderersChanged, this);\n\n    // Parse the default sizes.\n    let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n    let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n\n    // Set up the sections lists.\n    this._rowSections = new SectionList({\n      defaultSize: defaultSizes.rowHeight,\n      minimumSize: minimumSizes.rowHeight\n    });\n    this._columnSections = new SectionList({\n      defaultSize: defaultSizes.columnWidth,\n      minimumSize: minimumSizes.columnWidth\n    });\n    this._rowHeaderSections = new SectionList({\n      defaultSize: defaultSizes.rowHeaderWidth,\n      minimumSize: minimumSizes.rowHeaderWidth\n    });\n    this._columnHeaderSections = new SectionList({\n      defaultSize: defaultSizes.columnHeaderHeight,\n      minimumSize: minimumSizes.columnHeaderHeight\n    });\n\n    // Create the canvas, buffer, and overlay objects.\n    this._canvas = Private.createCanvas();\n    this._buffer = Private.createCanvas();\n    this._overlay = Private.createCanvas();\n\n    // Get the graphics contexts for the canvases.\n    this._canvasGC = this._canvas.getContext('2d')!;\n    this._bufferGC = this._buffer.getContext('2d')!;\n    this._overlayGC = this._overlay.getContext('2d')!;\n\n    // Set up the on-screen canvas.\n    this._canvas.style.position = 'absolute';\n    this._canvas.style.top = '0px';\n    this._canvas.style.left = '0px';\n    this._canvas.style.width = '0px';\n    this._canvas.style.height = '0px';\n\n    // Set up the on-screen overlay.\n    this._overlay.style.position = 'absolute';\n    this._overlay.style.top = '0px';\n    this._overlay.style.left = '0px';\n    this._overlay.style.width = '0px';\n    this._overlay.style.height = '0px';\n\n    // Create the internal widgets for the data grid.\n    this._viewport = new Widget();\n    this._viewport.node.tabIndex = -1;\n    this._viewport.node.style.outline = 'none';\n    this._vScrollBar = new ScrollBar({ orientation: 'vertical' });\n    this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });\n    this._scrollCorner = new Widget();\n\n    this._editorController = new CellEditorController();\n\n    // Add the extra class names to the child widgets.\n    this._viewport.addClass('lm-DataGrid-viewport');\n    this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n\n    // Add the on-screen canvas to the viewport node.\n    this._viewport.node.appendChild(this._canvas);\n\n    // Add the on-screen overlay to the viewport node.\n    this._viewport.node.appendChild(this._overlay);\n\n    // Install the message hooks.\n    MessageLoop.installMessageHook(this._viewport, this);\n    MessageLoop.installMessageHook(this._hScrollBar, this);\n    MessageLoop.installMessageHook(this._vScrollBar, this);\n\n    // Hide the scroll bars and corner from the outset.\n    this._vScrollBar.hide();\n    this._hScrollBar.hide();\n    this._scrollCorner.hide();\n\n    // Connect to the scroll bar signals.\n    this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._vScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._hScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._vScrollBar.stepRequested.connect(this._onStepRequested, this);\n    this._hScrollBar.stepRequested.connect(this._onStepRequested, this);\n\n    // Set the layout cell config for the child widgets.\n    GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });\n    GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });\n    GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });\n    GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });\n\n    // Create the layout for the data grid.\n    let layout = new GridLayout({\n      rowCount: 2,\n      columnCount: 2,\n      rowSpacing: 0,\n      columnSpacing: 0,\n      fitPolicy: 'set-no-constraint'\n    });\n\n    // Set the stretch factors for the grid.\n    layout.setRowStretch(0, 1);\n    layout.setRowStretch(1, 0);\n    layout.setColumnStretch(0, 1);\n    layout.setColumnStretch(1, 0);\n\n    // Add the child widgets to the layout.\n    layout.addWidget(this._viewport);\n    layout.addWidget(this._vScrollBar);\n    layout.addWidget(this._hScrollBar);\n    layout.addWidget(this._scrollCorner);\n\n    // Install the layout on the data grid.\n    this.layout = layout;\n  }\n\n  /**\n   * Dispose of the resources held by the widgets.\n   */\n  dispose(): void {\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Dispose of the handlers.\n    if (this._keyHandler) {\n      this._keyHandler.dispose();\n    }\n    if (this._mouseHandler) {\n      this._mouseHandler.dispose();\n    }\n    this._keyHandler = null;\n    this._mouseHandler = null;\n\n    // Clear the models.\n    this._dataModel = null;\n    this._selectionModel = null;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * Get the data model for the data grid.\n   */\n  get dataModel(): DataModel | null {\n    return this._dataModel;\n  }\n\n  /**\n   * Set the data model for the data grid.\n   *\n   * #### Notes\n   * This will automatically remove the current selection model.\n   */\n  set dataModel(value: DataModel | null) {\n    // Do nothing if the model does not change.\n    if (this._dataModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Clear the selection model.\n    this.selectionModel = null;\n\n    // Disconnect the change handler from the old model.\n    if (this._dataModel) {\n      this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onDataModelChanged, this);\n    }\n\n    // Update the internal model reference.\n    this._dataModel = value;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Populate the section lists.\n    if (value) {\n      this._rowSections.insert(0, value.rowCount('body'));\n      this._columnSections.insert(0, value.columnCount('body'));\n      this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n      this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n    }\n\n    // Reset the scroll position.\n    this._scrollX = 0;\n    this._scrollY = 0;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the selection model for the data grid.\n   */\n  get selectionModel(): SelectionModel | null {\n    return this._selectionModel;\n  }\n\n  /**\n   * Set the selection model for the data grid.\n   */\n  set selectionModel(value: SelectionModel | null) {\n    // Do nothing if the selection model does not change.\n    if (this._selectionModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Ensure the data models are a match.\n    if (value && value.dataModel !== this._dataModel) {\n      throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n    }\n\n    // Disconnect the change handler from the old model.\n    if (this._selectionModel) {\n      this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onSelectionsChanged, this);\n    }\n\n    // Update the internal selection model reference.\n    this._selectionModel = value;\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the key handler for the data grid.\n   */\n  get keyHandler(): DataGrid.IKeyHandler | null {\n    return this._keyHandler;\n  }\n\n  /**\n   * Set the key handler for the data grid.\n   */\n  set keyHandler(value: DataGrid.IKeyHandler | null) {\n    this._keyHandler = value;\n  }\n\n  /**\n   * Get the mouse handler for the data grid.\n   */\n  get mouseHandler(): DataGrid.IMouseHandler | null {\n    return this._mouseHandler;\n  }\n\n  /**\n   * Set the mouse handler for the data grid.\n   */\n  set mouseHandler(value: DataGrid.IMouseHandler | null) {\n    // Bail early if the mouse handler does not change.\n    if (this._mouseHandler === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Update the internal mouse handler.\n    this._mouseHandler = value;\n  }\n\n  /**\n   * Get the style for the data grid.\n   */\n  get style(): DataGrid.Style {\n    return this._style;\n  }\n\n  /**\n   * Set the style for the data grid.\n   */\n  set style(value: DataGrid.Style) {\n    // Bail if the style does not change.\n    if (this._style === value) {\n      return;\n    }\n\n    // Update the internal style.\n    this._style = { ...value };\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the cell renderer map for the data grid.\n   */\n  get cellRenderers(): RendererMap {\n    return this._cellRenderers;\n  }\n\n  /**\n   * Set the cell renderer map for the data grid.\n   */\n  set cellRenderers(value: RendererMap) {\n    // Bail if the renderer map does not change.\n    if (this._cellRenderers === value) {\n      return;\n    }\n\n    // Disconnect the old map.\n    this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n\n    // Connect the new map.\n    value.changed.connect(this._onRenderersChanged, this);\n\n    // Update the internal renderer map.\n    this._cellRenderers = value;\n\n    // Schedule a repaint of the grid content.\n    this.repaintContent();\n  }\n\n  /**\n   * Get the header visibility for the data grid.\n   */\n  get headerVisibility(): DataGrid.HeaderVisibility {\n    return this._headerVisibility;\n  }\n\n  /**\n   * Set the header visibility for the data grid.\n   */\n  set headerVisibility(value: DataGrid.HeaderVisibility) {\n    // Bail if the visibility does not change.\n    if (this._headerVisibility === value) {\n      return;\n    }\n\n    // Update the internal visibility.\n    this._headerVisibility = value;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the default sizes for the various sections of the data grid.\n   */\n  get defaultSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.defaultSize;\n    let columnWidth = this._columnSections.defaultSize;\n    let rowHeaderWidth = this._rowHeaderSections.defaultSize;\n    let columnHeaderHeight = this._columnHeaderSections.defaultSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the default sizes for the various sections of the data grid.\n   */\n  set defaultSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.defaultSize = value.rowHeight;\n    this._columnSections.defaultSize = value.columnWidth;\n    this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n    this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the minimum sizes for the various sections of the data grid.\n   */\n  get minimumSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.minimumSize;\n    let columnWidth = this._columnSections.minimumSize;\n    let rowHeaderWidth = this._rowHeaderSections.minimumSize;\n    let columnHeaderHeight = this._columnHeaderSections.minimumSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the minimum sizes for the various sections of the data grid.\n   */\n  set minimumSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.minimumSize = value.rowHeight;\n    this._columnSections.minimumSize = value.columnWidth;\n    this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n    this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the copy configuration for the data grid.\n   */\n  get copyConfig(): DataGrid.CopyConfig {\n    return this._copyConfig;\n  }\n\n  /**\n   * Set the copy configuration for the data grid.\n   */\n  set copyConfig(value: DataGrid.CopyConfig) {\n    this._copyConfig = value;\n  }\n\n  /**\n   * Get whether the last row is stretched.\n   */\n  get stretchLastRow(): boolean {\n    return this._stretchLastRow;\n  }\n\n  /**\n   * Set whether the last row is stretched.\n   */\n  set stretchLastRow(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastRow) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastRow = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * Get whether the last column is stretched.\n   */\n  get stretchLastColumn(): boolean {\n    return this._stretchLastColumn;\n  }\n\n  /**\n   * Set whether the last column is stretched.\n   */\n  set stretchLastColumn(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastColumn) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastColumn = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * The virtual width of the row headers.\n   */\n  get headerWidth(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'column') {\n      return 0;\n    }\n    return this._rowHeaderSections.length;\n  }\n\n  /**\n   * The virtual height of the column headers.\n   */\n  get headerHeight(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'row') {\n      return 0;\n    }\n    return this._columnHeaderSections.length;\n  }\n\n  /**\n   * The virtual width of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get bodyWidth(): number {\n    return this._columnSections.length;\n  }\n\n  /**\n   * The virtual height of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get bodyHeight(): number {\n    return this._rowSections.length;\n  }\n\n  /**\n   * The virtual width of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get totalWidth(): number {\n    return this.headerWidth + this.bodyWidth;\n  }\n\n  /**\n   * The virtual height of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get totalHeight(): number {\n    return this.headerHeight + this.bodyHeight;\n  }\n\n  /**\n   * The actual width of the viewport.\n   */\n  get viewportWidth(): number {\n    return this._viewportWidth;\n  }\n\n  /**\n   * The actual height of the viewport.\n   */\n  get viewportHeight(): number {\n    return this._viewportHeight;\n  }\n\n  /**\n   * The width of the visible portion of the grid body.\n   */\n  get pageWidth(): number {\n    return Math.max(0, this.viewportWidth - this.headerWidth);\n  }\n\n  /**\n   * The height of the visible portion of the grid body.\n   */\n  get pageHeight(): number {\n    return Math.max(0, this.viewportHeight - this.headerHeight);\n  }\n\n  /**\n   * The current scroll X position of the viewport.\n   */\n  get scrollX(): number {\n    return this._hScrollBar.value;\n  }\n\n  /**\n   * The current scroll Y position of the viewport.\n   */\n  get scrollY(): number {\n    return this._vScrollBar.value;\n  }\n\n  /**\n   * The maximum scroll X position for the grid.\n   */\n  get maxScrollX(): number {\n    return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n  }\n\n  /**\n   * The maximum scroll Y position for the grid.\n   */\n  get maxScrollY(): number {\n    return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n  }\n\n  /**\n   * The viewport widget for the data grid.\n   */\n  get viewport(): Widget {\n    return this._viewport;\n  }\n\n  /**\n   * The cell editor controller object for the data grid.\n   */\n  get editorController(): ICellEditorController | null {\n    return this._editorController;\n  }\n\n  set editorController(controller: ICellEditorController | null) {\n    this._editorController = controller;\n  }\n\n  /**\n   * Whether the cell editing is enabled for the data grid.\n   */\n  get editingEnabled(): boolean {\n    return this._editingEnabled;\n  }\n\n  set editingEnabled(enabled: boolean) {\n    this._editingEnabled = enabled;\n  }\n\n  /**\n   * Whether the grid cells are editable.\n   *\n   * `editingEnabled` flag must be on and grid must have required\n   * selection model, editor controller and data model properties.\n   */\n  get editable(): boolean {\n    return (\n      this._editingEnabled &&\n      this._selectionModel !== null &&\n      this._editorController !== null &&\n      this.dataModel instanceof MutableDataModel\n    );\n  }\n\n  /**\n   * The rendering context for painting the data grid.\n   */\n  protected get canvasGC(): CanvasRenderingContext2D {\n    return this._canvasGC;\n  }\n\n  /**\n   * The row sections of the data grid.\n   */\n  protected get rowSections(): SectionList {\n    return this._rowSections;\n  }\n\n  /**\n   * The column sections of the data grid.\n   */\n  protected get columnSections(): SectionList {\n    return this._columnSections;\n  }\n\n  /**\n   * The row header sections of the data grid.\n   */\n  protected get rowHeaderSections(): SectionList {\n    return this._rowHeaderSections;\n  }\n\n  /**\n   * The column header sections of the data grid.\n   */\n  protected get columnHeaderSections(): SectionList {\n    return this._columnHeaderSections;\n  }\n\n  /**\n   * Scroll the grid to the specified row.\n   *\n   * @param row - The row index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the row is already visible.\n   */\n  scrollToRow(row: number): void {\n    // Fetch the row count.\n    let nr = this._rowSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0) {\n      return;\n    }\n\n    // Floor the row index.\n    row = Math.floor(row);\n\n    // Clamp the row index.\n    row = Math.max(0, Math.min(row, nr - 1));\n\n    // Get the virtual bounds of the row.\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dy = 0;\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(0, dy);\n  }\n\n  /**\n   * Scroll the grid to the specified column.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the column is already visible.\n   */\n  scrollToColumn(column: number): void {\n    // Fetch the column count.\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nc === 0) {\n      return;\n    }\n\n    // Floor the column index.\n    column = Math.floor(column);\n\n    // Clamp the column index.\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the column.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, 0);\n  }\n\n  /**\n   * Scroll the grid to the specified cell.\n   *\n   * @param row - The row index of the cell.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the cell is already visible.\n   */\n  scrollToCell(row: number, column: number): void {\n    // Fetch the row and column count.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0 || nc === 0) {\n      return;\n    }\n\n    // Floor the cell index.\n    row = Math.floor(row);\n    column = Math.floor(column);\n\n    // Clamp the cell index.\n    row = Math.max(0, Math.min(row, nr - 1));\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the cell.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n    let dy = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, dy);\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  moveCursor(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there is no selection\n    if (\n      !this.dataModel ||\n      !this._selectionModel ||\n      this._selectionModel.isEmpty\n    ) {\n      return;\n    }\n\n    const iter = this._selectionModel.selections();\n    const onlyOne = iter.next() && !iter.next();\n\n    // if there is a single selection that is a single cell selection\n    // then move the selection and cursor within grid bounds\n    if (onlyOne) {\n      const currentSel = this._selectionModel.currentSelection()!;\n      if (currentSel.r1 === currentSel.r2 && currentSel.c1 === currentSel.c2) {\n        const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        let newRow = currentSel.r1 + dr;\n        let newColumn = currentSel.c1 + dc;\n        const rowCount = this.dataModel.rowCount('body');\n        const columnCount = this.dataModel.columnCount('body');\n        if (newRow >= rowCount) {\n          newRow = 0;\n          newColumn += 1;\n        } else if (newRow === -1) {\n          newRow = rowCount - 1;\n          newColumn -= 1;\n        }\n        if (newColumn >= columnCount) {\n          newColumn = 0;\n          newRow += 1;\n          if (newRow >= rowCount) {\n            newRow = 0;\n          }\n        } else if (newColumn === -1) {\n          newColumn = columnCount - 1;\n          newRow -= 1;\n          if (newRow === -1) {\n            newRow = rowCount - 1;\n          }\n        }\n\n        this._selectionModel.select({\n          r1: newRow,\n          c1: newColumn,\n          r2: newRow,\n          c2: newColumn,\n          cursorRow: newRow,\n          cursorColumn: newColumn,\n          clear: 'all'\n        });\n\n        return;\n      }\n    }\n\n    // if there are multiple selections, move cursor\n    // within selection rectangles\n    this._selectionModel.moveCursorWithinSelections(direction);\n  }\n\n  /**\n   * Scroll the grid to the current cursor position.\n   *\n   * #### Notes\n   * This is a no-op if the cursor is already visible or\n   * if there is no selection model installed on the grid.\n   */\n  scrollToCursor(): void {\n    // Bail early if there is no selection model.\n    if (!this._selectionModel) {\n      return;\n    }\n\n    // Fetch the cursor row and column.\n    let row = this._selectionModel.cursorRow;\n    let column = this._selectionModel.cursorColumn;\n\n    // Scroll to the cursor cell.\n    this.scrollToCell(row, column);\n  }\n\n  /**\n   * Scroll the viewport by the specified amount.\n   *\n   * @param dx - The X scroll amount.\n   *\n   * @param dy - The Y scroll amount.\n   */\n  scrollBy(dx: number, dy: number): void {\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one page.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByPage(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let dx = 0;\n    let dy = 0;\n    switch (dir) {\n      case 'up':\n        dy = -this.pageHeight;\n        break;\n      case 'down':\n        dy = this.pageHeight;\n        break;\n      case 'left':\n        dx = -this.pageWidth;\n        break;\n      case 'right':\n        dx = this.pageWidth;\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one cell-aligned step.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByStep(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let r: number;\n    let c: number;\n    let x = this.scrollX;\n    let y = this.scrollY;\n    let rows = this._rowSections;\n    let columns = this._columnSections;\n    switch (dir) {\n      case 'up':\n        r = rows.indexOf(y - 1);\n        y = r < 0 ? y : rows.offsetOf(r);\n        break;\n      case 'down':\n        r = rows.indexOf(y);\n        y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n        break;\n      case 'left':\n        c = columns.indexOf(x - 1);\n        x = c < 0 ? x : columns.offsetOf(c);\n        break;\n      case 'right':\n        c = columns.indexOf(x);\n        x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.scrollTo(x, y);\n  }\n\n  /**\n   * Scroll to the specified offset position.\n   *\n   * @param x - The desired X position.\n   *\n   * @param y - The desired Y position.\n   */\n  scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Update the scroll bar values with the desired position.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Post a scroll request message to the viewport.\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Get the row count for a particular region in the data grid.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns The row count for the specified region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._rowSections.count;\n    } else {\n      count = this._columnHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the column count for a particular region in the data grid.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns The column count for the specified region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._columnSections.count;\n    } else {\n      count = this._rowHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the row at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param offset - The virtual offset of the row of interest.\n   *\n   * @returns The index of the row, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowAt(region: DataModel.RowRegion, offset: number): number {\n    // Bail early if the offset is negative.\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._rowSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Bail early if no row stretching is required.\n    if (ph <= bh) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= ph) {\n      return -1;\n    }\n\n    // Otherwise, return the last row.\n    return this._rowSections.count - 1;\n  }\n\n  /**\n   * Get the column at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param offset - The virtual offset of the column of interest.\n   *\n   * @returns The index of the column, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnAt(region: DataModel.ColumnRegion, offset: number): number {\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._columnSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Bail early if no column stretching is required.\n    if (pw <= bw) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= pw) {\n      return -1;\n    }\n\n    // Otherwise, return the last column.\n    return this._columnSections.count - 1;\n  }\n\n  /**\n   * Get the offset of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The offset of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last row has no effect on the return value.\n   */\n  rowOffset(region: DataModel.RowRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._rowSections.offsetOf(index);\n    } else {\n      offset = this._columnHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the offset of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The offset of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last column has no effect on the return value.\n   */\n  columnOffset(region: DataModel.ColumnRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._columnSections.offsetOf(index);\n    } else {\n      offset = this._rowHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the size of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The size of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowSize(region: DataModel.RowRegion, index: number): number {\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the row size.\n    let size = this._rowSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return size;\n    }\n\n    // Return early if its not the last row.\n    if (index < this._rowSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Return early if no stretching is needed.\n    if (ph <= bh) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (ph - bh);\n  }\n\n  /**\n   * Get the size of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The size of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnSize(region: DataModel.ColumnRegion, index: number): number {\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the column size.\n    let size = this._columnSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return size;\n    }\n\n    // Return early if its not the last column.\n    if (index < this._columnSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Return early if no stretching is needed.\n    if (pw <= bw) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (pw - bw);\n  }\n\n  /**\n   * Resize a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @param size - The desired size of the row.\n   */\n  resizeRow(region: DataModel.RowRegion, index: number, size: number): void {\n    let msg = new Private.RowResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Resize a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @param size - The desired size of the column.\n   */\n  resizeColumn(\n    region: DataModel.ColumnRegion,\n    index: number,\n    size: number | null\n  ): void {\n    let msg = new Private.ColumnResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Reset modified rows to their default size.\n   *\n   * @param region - The row region of interest.\n   */\n  resetRows(region: DataModel.RowRegion | 'all'): void {\n    switch (region) {\n      case 'all':\n        this._rowSections.reset();\n        this._columnHeaderSections.reset();\n        break;\n      case 'body':\n        this._rowSections.reset();\n        break;\n      case 'column-header':\n        this._columnHeaderSections.reset();\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Reset modified columns to their default size.\n   *\n   * @param region - The column region of interest.\n   */\n  resetColumns(region: DataModel.ColumnRegion | 'all'): void {\n    switch (region) {\n      case 'all':\n        this._columnSections.reset();\n        this._rowHeaderSections.reset();\n        break;\n      case 'body':\n        this._columnSections.reset();\n        break;\n      case 'row-header':\n        this._rowHeaderSections.reset();\n        break;\n      default:\n        throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Auto sizes column-header widths based on their text content.\n   * @param area which area to resize: 'body', 'row-header' or 'all'.\n   * @param padding padding added to resized columns (pixels).\n   * @param numCols specify cap on the number of column resizes (optional).\n   */\n  fitColumnNames(\n    area: DataGrid.ColumnFitType = 'all',\n    padding: number = 15,\n    numCols?: number\n  ): void {\n    // Attempt resizing only if a data model is present.\n    if (this.dataModel) {\n      // Tracking remaining columns to be resized if numCols arg passed.\n      let colsRemaining =\n        numCols === undefined || numCols < 0 ? undefined : numCols;\n\n      if (area === 'row-header' || area === 'all') {\n        // Respecting any column resize cap, if one has been passed.\n        if (colsRemaining !== undefined) {\n          const rowColumnCount = this.dataModel.columnCount('row-header');\n          /*\n            If we have more row-header columns than columns available\n            for resize, resize only remaining columns as per allowance\n            and set remaining resize allowance number to 0.\n          */\n          if (colsRemaining - rowColumnCount < 0) {\n            this._fitRowColumnHeaders(this.dataModel, padding, colsRemaining);\n            colsRemaining = 0;\n          } else {\n            /*\n              Otherwise the entire row-header column count can be resized.\n              Resize all row-header columns and subtract from remaining\n              column resize allowance.\n            */\n            this._fitRowColumnHeaders(this.dataModel, padding, rowColumnCount);\n            colsRemaining = colsRemaining - rowColumnCount;\n          }\n        } else {\n          // No column resize cap passed - resizing all columns.\n          this._fitRowColumnHeaders(this.dataModel, padding);\n        }\n      }\n\n      if (area === 'body' || area === 'all') {\n        // Respecting any column resize cap, if one has been passed.\n        if (colsRemaining !== undefined) {\n          const bodyColumnCount = this.dataModel.columnCount('body');\n          /*\n            If we have more body columns than columns available\n            for resize, resize only remaining columns as per allowance\n            and set remaining resize allowance number to 0.\n          */\n          if (colsRemaining - bodyColumnCount < 0) {\n            this._fitBodyColumnHeaders(this.dataModel, padding, colsRemaining);\n          } else {\n            /*\n              Otherwise the entire body column count can be resized.\n              Resize based on the smallest number between remaining\n              resize allowance and body column count.\n            */\n            this._fitBodyColumnHeaders(\n              this.dataModel,\n              padding,\n              Math.min(colsRemaining, bodyColumnCount)\n            );\n          }\n        } else {\n          // No column resize cap passed - resizing all columns.\n          this._fitBodyColumnHeaders(this.dataModel, padding);\n        }\n      }\n    }\n  }\n\n  /**\n   * Map a client position to local viewport coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The local viewport coordinates for the position.\n   */\n  mapToLocal(clientX: number, clientY: number): { lx: number; ly: number } {\n    // Fetch the viewport rect.\n    let rect = this._viewport.node.getBoundingClientRect();\n\n    // Extract the rect coordinates.\n    let { left, top } = rect;\n\n    // Round the rect coordinates for sub-pixel positioning.\n    left = Math.floor(left);\n    top = Math.floor(top);\n\n    // Convert to local coordinates.\n    let lx = clientX - left;\n    let ly = clientY - top;\n\n    // Return the local coordinates.\n    return { lx, ly };\n  }\n\n  /**\n   * Map a client position to virtual grid coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The virtual grid coordinates for the position.\n   */\n  mapToVirtual(clientX: number, clientY: number): { vx: number; vy: number } {\n    // Convert to local coordiates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Convert to virtual coordinates.\n    let vx = lx + this.scrollX - this.headerWidth;\n    let vy = ly + this.scrollY - this.headerHeight;\n\n    // Return the local coordinates.\n    return { vx, vy };\n  }\n\n  /**\n   * Hit test the viewport for the given client position.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The hit test result, or `null` if the client\n   *   position is out of bounds.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row and/or column.\n   */\n  hitTest(clientX: number, clientY: number): DataGrid.HitTestResult {\n    // Convert the mouse position into local coordinates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Fetch the header and body dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Adjust the body width for a stretched last column.\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Adjust the body height for a stretched last row.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n\n    // Check for a corner header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'corner-header', row, column, x, y, width, height };\n    }\n\n    // Check for a column header hit.\n    if (ly >= 0 && ly < hh && lx >= 0 && lx < hw + bw) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'column-header', row, column, x, y, width, height };\n    }\n\n    // Check for a row header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh + bh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'row-header', row, column, x, y, width, height };\n    }\n\n    // Check for a body hit.\n    if (lx >= hw && lx < hw + bw && ly >= hh && ly < hh + bh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the part coordinates.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the result.\n      return { region: 'body', row, column, x, y, width, height };\n    }\n\n    // Otherwise, it's a void space hit.\n    let row = -1;\n    let column = -1;\n    let x = -1;\n    let y = -1;\n    let width = -1;\n    let height = -1;\n\n    // Return the hit test result.\n    return { region: 'void', row, column, x, y, width, height };\n  }\n\n  /**\n   * Copy the current selection to the system clipboard.\n   *\n   * #### Notes\n   * The grid must have a data model and a selection model.\n   *\n   * The behavior can be configured via `DataGrid.copyConfig`.\n   */\n  copyToClipboard(): void {\n    // Fetch the data model.\n    let dataModel = this._dataModel;\n\n    // Bail early if there is no data model.\n    if (!dataModel) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let selectionModel = this._selectionModel;\n\n    // Bail early if there is no selection model.\n    if (!selectionModel) {\n      return;\n    }\n\n    // Coerce the selections to an array.\n    let selections = Array.from(selectionModel.selections());\n\n    // Bail early if there are no selections.\n    if (selections.length === 0) {\n      return;\n    }\n\n    // Alert that multiple selections cannot be copied.\n    if (selections.length > 1) {\n      alert('Cannot copy multiple grid selections.');\n      return;\n    }\n\n    // Fetch the model counts.\n    let br = dataModel.rowCount('body');\n    let bc = dataModel.columnCount('body');\n\n    // Bail early if there is nothing to copy.\n    if (br === 0 || bc === 0) {\n      return;\n    }\n\n    // Unpack the selection.\n    let { r1, c1, r2, c2 } = selections[0];\n\n    // Clamp the selection to the model bounds.\n    r1 = Math.max(0, Math.min(r1, br - 1));\n    c1 = Math.max(0, Math.min(c1, bc - 1));\n    r2 = Math.max(0, Math.min(r2, br - 1));\n    c2 = Math.max(0, Math.min(c2, bc - 1));\n\n    // Ensure the limits are well-orderd.\n    if (r2 < r1) [r1, r2] = [r2, r1];\n    if (c2 < c1) [c1, c2] = [c2, c1];\n\n    // Fetch the header counts.\n    let rhc = dataModel.columnCount('row-header');\n    let chr = dataModel.rowCount('column-header');\n\n    // Unpack the copy config.\n    let separator = this._copyConfig.separator;\n    let format = this._copyConfig.format;\n    let headers = this._copyConfig.headers;\n    let warningThreshold = this._copyConfig.warningThreshold;\n\n    // Compute the number of cells to be copied.\n    let rowCount = r2 - r1 + 1;\n    let colCount = c2 - c1 + 1;\n    switch (headers) {\n      case 'none':\n        rhc = 0;\n        chr = 0;\n        break;\n      case 'row':\n        chr = 0;\n        colCount += rhc;\n        break;\n      case 'column':\n        rhc = 0;\n        rowCount += chr;\n        break;\n      case 'all':\n        rowCount += chr;\n        colCount += rhc;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Compute the total cell count.\n    let cellCount = rowCount * colCount;\n\n    // Allow the user to cancel a large copy request.\n    if (cellCount > warningThreshold) {\n      let msg = `Copying ${cellCount} cells may take a while. Continue?`;\n      if (!window.confirm(msg)) {\n        return;\n      }\n    }\n\n    // Set up the format args.\n    let args = {\n      region: 'body' as DataModel.CellRegion,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: {} as DataModel.Metadata\n    };\n\n    // Allocate the array of rows.\n    let rows = new Array<string[]>(rowCount);\n\n    // Iterate over the rows.\n    for (let j = 0; j < rowCount; ++j) {\n      // Allocate the array of cells.\n      let cells = new Array<string>(colCount);\n\n      // Iterate over the columns.\n      for (let i = 0; i < colCount; ++i) {\n        // Set up the format variables.\n        let region: DataModel.CellRegion;\n        let row: number;\n        let column: number;\n\n        // Populate the format variables.\n        if (j < chr && i < rhc) {\n          region = 'corner-header';\n          row = j;\n          column = i;\n        } else if (j < chr) {\n          region = 'column-header';\n          row = j;\n          column = i - rhc + c1;\n        } else if (i < rhc) {\n          region = 'row-header';\n          row = j - chr + r1;\n          column = i;\n        } else {\n          region = 'body';\n          row = j - chr + r1;\n          column = i - rhc + c1;\n        }\n\n        // Populate the format args.\n        args.region = region;\n        args.row = row;\n        args.column = column;\n        args.value = dataModel.data(region, row, column);\n        args.metadata = dataModel.metadata(region, row, column);\n\n        // Format the cell.\n        cells[i] = format(args);\n      }\n\n      // Save the row of cells.\n      rows[j] = cells;\n    }\n\n    // Convert the cells into lines.\n    let lines = rows.map(cells => cells.join(separator));\n\n    // Convert the lines into text.\n    let text = lines.join('\\n');\n\n    // Copy the text to the clipboard.\n    ClipboardExt.copyText(text);\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   */\n  processMessage(msg: Message): void {\n    // Ignore child show/hide messages. The data grid controls the\n    // visibility of its children, and will manually dispatch the\n    // fit-request messages as a result of visibility change.\n    if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n      return;\n    }\n\n    // Recompute the scroll bar minimums before the layout refits.\n    if (msg.type === 'fit-request') {\n      let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);\n      let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);\n      this._vScrollBarMinWidth = vsbLimits.minWidth;\n      this._hScrollBarMinHeight = hsbLimits.minHeight;\n    }\n\n    // Process all other messages as normal.\n    super.processMessage(msg);\n  }\n\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean {\n    // Process viewport messages.\n    if (handler === this._viewport) {\n      this._processViewportMessage(msg);\n      return true;\n    }\n\n    // Process horizontal scroll bar messages.\n    if (handler === this._hScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Process vertical scroll bar messages.\n    if (handler === this._vScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Ignore all other messages.\n    return true;\n  }\n\n  /**\n   * Handle the DOM events for the data grid.\n   *\n   * @param event - The DOM event sent to the data grid.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the data grid's DOM node. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._evtKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        this._evtMouseDown(event as MouseEvent);\n        break;\n      case 'mousemove':\n        this._evtMouseMove(event as MouseEvent);\n        break;\n      case 'mouseup':\n        this._evtMouseUp(event as MouseEvent);\n        break;\n      case 'dblclick':\n        this._evtMouseDoubleClick(event as MouseEvent);\n        break;\n      case 'mouseleave':\n        this._evtMouseLeave(event as MouseEvent);\n        break;\n      case 'contextmenu':\n        this._evtContextMenu(event as MouseEvent);\n        break;\n      case 'wheel':\n        this._evtWheel(event as WheelEvent);\n        break;\n      case 'resize':\n        this._refreshDPI();\n        break;\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.viewport.node.focus({ preventScroll: true });\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    window.addEventListener('resize', this);\n    this.node.addEventListener('wheel', this);\n    this._viewport.node.addEventListener('keydown', this);\n    this._viewport.node.addEventListener('mousedown', this);\n    this._viewport.node.addEventListener('mousemove', this);\n    this._viewport.node.addEventListener('dblclick', this);\n    this._viewport.node.addEventListener('mouseleave', this);\n    this._viewport.node.addEventListener('contextmenu', this);\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    window.removeEventListener('resize', this);\n    this.node.removeEventListener('wheel', this);\n    this._viewport.node.removeEventListener('keydown', this);\n    this._viewport.node.removeEventListener('mousedown', this);\n    this._viewport.node.removeEventListener('mousemove', this);\n    this._viewport.node.removeEventListener('mouseleave', this);\n    this._viewport.node.removeEventListener('dblclick', this);\n    this._viewport.node.removeEventListener('contextmenu', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this._editorController) {\n      this._editorController.cancel();\n    }\n\n    this._syncScrollState();\n  }\n\n  /**\n   * Schedule a repaint of all of the grid content.\n   */\n  protected repaintContent(): void {\n    let msg = new Private.PaintRequest('all', 0, 0, 0, 0);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of specific grid content.\n   */\n  protected repaintRegion(\n    region: DataModel.CellRegion,\n    r1: number,\n    c1: number,\n    r2: number,\n    c2: number\n  ): void {\n    let msg = new Private.PaintRequest(region, r1, c1, r2, c2);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of the overlay.\n   */\n  protected repaintOverlay(): void {\n    MessageLoop.postMessage(this._viewport, Private.OverlayPaintRequest);\n  }\n\n  private _getMaxWidthInColumn(\n    index: number,\n    columnRegion: 'row-header' | 'body'\n  ): number | null {\n    const dataModel = this.dataModel;\n\n    if (!dataModel) {\n      return null;\n    }\n\n    const columnHeaderRegion =\n      columnRegion == 'row-header' ? 'corner-header' : 'column-header';\n\n    return Math.max(\n      this._getMaxWidthInArea(\n        dataModel,\n        index,\n        columnHeaderRegion,\n        'column-header'\n      ),\n      this._getMaxWidthInArea(dataModel, index, columnRegion, 'body')\n    );\n  }\n\n  private _getMaxWidthInArea(\n    dataModel: DataModel,\n    index: number,\n    region: DataModel.CellRegion,\n    rowRegion: DataModel.RowRegion\n  ): number {\n    const numRows = dataModel.rowCount(rowRegion);\n    // Will only allocate up to 1_000_000 elements otherwise performance can tank.\n    const configs = Array.from(\n      { length: Math.min(numRows, 1_000_000) },\n      (_val, idx) => DataGrid._getConfig(dataModel, idx, index, region)\n    );\n\n    // Heuristic: Sort by the length of the text to render and only fully calculate the text width\n    // for the top 100_000 rows by text length\n    if (numRows > 100_000) {\n      // Sort by descending length\n      configs.sort(x => -this._getTextToRender(x).length);\n    }\n\n    let maxWidth = 0;\n    for (let i = 0; i < numRows && i < 100_000; ++i) {\n      const textWidth = this._getCellTextWidth(configs[i]);\n      maxWidth = Math.max(maxWidth, textWidth);\n    }\n\n    return maxWidth;\n  }\n\n  private static _getConfig(\n    dataModel: DataModel,\n    row: number,\n    col: number,\n    location: DataModel.CellRegion\n  ): CellRenderer.CellConfig {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      region: location,\n      row: row,\n      column: col,\n      value: DataGrid._getCellValue(dataModel, location, row, col),\n      metadata: DataGrid._getCellMetadata(dataModel, location, row, col)\n    };\n  }\n\n  private _getTextToRender(config: CellRenderer.CellConfig): string {\n    const renderer = this.cellRenderers.get(config) as TextRenderer;\n    return renderer.getText(config);\n  }\n\n  private _getCellTextWidth(config: CellRenderer.CellConfig): number {\n    // Get the renderer for the given cell.\n    const renderer = this.cellRenderers.get(config) as TextRenderer;\n\n    // Use the canvas context to measure the cell's text width\n    const gc = this.canvasGC;\n    gc.font = CellRenderer.resolveOption(renderer.font, config);\n    gc.fillStyle = CellRenderer.resolveOption(renderer.textColor, config);\n    gc.textAlign = CellRenderer.resolveOption(\n      renderer.horizontalAlignment,\n      config\n    );\n    gc.textBaseline = 'bottom';\n\n    const text = this._getTextToRender(config);\n\n    return gc.measureText(text).width + 2 * renderer.horizontalPadding;\n  }\n\n  /**\n   * Ensure the canvas is at least the specified size.\n   *\n   * This method will retain the valid canvas content.\n   */\n  private _resizeCanvasIfNeeded(width: number, height: number): void {\n    // Scale the size by the dpi ratio.\n    width = width * this._dpiRatio;\n    height = height * this._dpiRatio;\n\n    // Compute the maximum canvas size for the given width and height.\n    let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n    let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n\n    // Get the current size of the canvas.\n    let curW = this._canvas.width;\n    let curH = this._canvas.height;\n\n    // Bail early if the canvas size is within bounds.\n    if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n      return;\n    }\n\n    // Compute the expanded canvas size.\n    let expW = maxW - 512;\n    let expH = maxH - 512;\n\n    // Set the transforms to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Resize the buffer if needed.\n    if (curW < width) {\n      this._buffer.width = expW;\n    } else if (curW > maxW) {\n      this._buffer.width = maxW;\n    }\n\n    // Resize the buffer height if needed.\n    if (curH < height) {\n      this._buffer.height = expH;\n    } else if (curH > maxH) {\n      this._buffer.height = maxH;\n    }\n\n    // Test whether there is content to blit.\n    let needBlit = curW > 0 && curH > 0 && width > 0 && height > 0;\n\n    // Copy the valid canvas content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._canvas, 0, 0);\n    }\n\n    // Resize the canvas width if needed.\n    if (curW < width) {\n      this._canvas.width = expW;\n      this._canvas.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._canvas.width = maxW;\n      this._canvas.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the canvas height if needed.\n    if (curH < height) {\n      this._canvas.height = expH;\n      this._canvas.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._canvas.height = maxH;\n      this._canvas.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid canvas content from the buffer if needed.\n    if (needBlit) {\n      this._canvasGC.drawImage(this._buffer, 0, 0);\n    }\n\n    // Copy the valid overlay content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._overlay, 0, 0);\n    }\n\n    // Resize the overlay width if needed.\n    if (curW < width) {\n      this._overlay.width = expW;\n      this._overlay.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._overlay.width = maxW;\n      this._overlay.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the overlay height if needed.\n    if (curH < height) {\n      this._overlay.height = expH;\n      this._overlay.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._overlay.height = maxH;\n      this._overlay.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid overlay content from the buffer if needed.\n    if (needBlit) {\n      this._overlayGC.drawImage(this._buffer, 0, 0);\n    }\n  }\n\n  /**\n   * Sync the scroll bars and scroll state with the viewport.\n   *\n   * #### Notes\n   * If the visibility of either scroll bar changes, a synchronous\n   * fit-request will be dispatched to the data grid to immediately\n   * resize the viewport.\n   */\n  private _syncScrollState(): void {\n    // Fetch the viewport dimensions.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Get the current scroll bar visibility.\n    let hasVScroll = !this._vScrollBar.isHidden;\n    let hasHScroll = !this._hScrollBar.isHidden;\n\n    // Get the minimum sizes of the scroll bars.\n    let vsw = this._vScrollBarMinWidth;\n    let hsh = this._hScrollBarMinHeight;\n\n    // Get the page size as if no scroll bars are visible.\n    let apw = pw + (hasVScroll ? vsw : 0);\n    let aph = ph + (hasHScroll ? hsh : 0);\n\n    // Test whether scroll bars are needed for the adjusted size.\n    let needVScroll = aph < bh - 1;\n    let needHScroll = apw < bw - 1;\n\n    // Re-test the horizontal scroll if a vertical scroll is needed.\n    if (needVScroll && !needHScroll) {\n      needHScroll = apw - vsw < bw - 1;\n    }\n\n    // Re-test the vertical scroll if a horizontal scroll is needed.\n    if (needHScroll && !needVScroll) {\n      needVScroll = aph - hsh < bh - 1;\n    }\n\n    // If the visibility changes, immediately refit the grid.\n    if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n      this._vScrollBar.setHidden(!needVScroll);\n      this._hScrollBar.setHidden(!needHScroll);\n      this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n      MessageLoop.sendMessage(this, Widget.Msg.FitRequest);\n    }\n\n    // Update the scroll bar limits.\n    this._vScrollBar.maximum = this.maxScrollY;\n    this._vScrollBar.page = this.pageHeight;\n    this._hScrollBar.maximum = this.maxScrollX;\n    this._hScrollBar.page = this.pageWidth;\n\n    // Re-clamp the scroll position.\n    this._scrollTo(this._scrollX, this._scrollY);\n  }\n\n  /**\n   * Sync the viewport to the given scroll position.\n   *\n   * #### Notes\n   * This schedules a full repaint and syncs the scroll state.\n   */\n  private _syncViewport(): void {\n    this.repaintContent();\n    this.repaintOverlay();\n    this._syncScrollState();\n  }\n\n  /**\n   * Process a message sent to the viewport\n   */\n  private _processViewportMessage(msg: Message): void {\n    switch (msg.type) {\n      case 'resize':\n        this._onViewportResize(msg as Widget.ResizeMessage);\n        break;\n      case 'scroll-request':\n        this._onViewportScrollRequest(msg);\n        break;\n      case 'paint-request':\n        this._onViewportPaintRequest(msg as Private.PaintRequest);\n        break;\n      case 'overlay-paint-request':\n        this._onViewportOverlayPaintRequest(msg);\n        break;\n      case 'row-resize-request':\n        this._onViewportRowResizeRequest(msg as Private.RowResizeRequest);\n        break;\n      case 'column-resize-request':\n        this._onViewportColumnResizeRequest(msg as Private.ColumnResizeRequest);\n        break;\n      default:\n        break;\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'resize'` message.\n   */\n  private _onViewportResize(msg: Widget.ResizeMessage): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Unpack the message data.\n    let { width, height } = msg;\n\n    // Measure the viewport node if the dimensions are unknown.\n    if (width === -1) {\n      width = this._viewport.node.offsetWidth;\n    }\n    if (height === -1) {\n      height = this._viewport.node.offsetHeight;\n    }\n\n    // Round the dimensions to the nearest pixel.\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // Get the current size of the viewport.\n    let oldWidth = this._viewportWidth;\n    let oldHeight = this._viewportHeight;\n\n    // Updated internal viewport size.\n    this._viewportWidth = width;\n    this._viewportHeight = height;\n\n    // Resize the canvas if needed.\n    this._resizeCanvasIfNeeded(width, height);\n\n    // Bail early if there is nothing to paint.\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    // Paint the whole grid if the old size was zero.\n    if (oldWidth === 0 || oldHeight === 0) {\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Paint the right edge as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n      let x = Math.min(this.headerWidth + bx, oldWidth);\n      this.paintContent(x, 0, width - x, height);\n    } else if (width > oldWidth) {\n      this.paintContent(oldWidth, 0, width - oldWidth + 1, height);\n    }\n\n    // Paint the bottom edge as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let by = this._rowSections.offsetOf(this._rowSections.count - 1);\n      let y = Math.min(this.headerHeight + by, oldHeight);\n      this.paintContent(0, y, width, height - y);\n    } else if (height > oldHeight) {\n      this.paintContent(0, oldHeight, width, height - oldHeight + 1);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'scroll-request'` message.\n   */\n  private _onViewportScrollRequest(msg: Message): void {\n    this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'paint-request'` message.\n   */\n  private _onViewportPaintRequest(msg: Private.PaintRequest): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Set up the paint limits.\n    let xMin = 0;\n    let yMin = 0;\n    let xMax = this._viewportWidth - 1;\n    let yMax = this._viewportHeight - 1;\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch the header dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the section lists.\n    let rs = this._rowSections;\n    let cs = this._columnSections;\n    let rhs = this._rowHeaderSections;\n    let chs = this._columnHeaderSections;\n\n    // Unpack the message data.\n    let { region, r1, c1, r2, c2 } = msg;\n\n    // Set up the paint variables.\n    let x1: number;\n    let y1: number;\n    let x2: number;\n    let y2: number;\n\n    // Fill the paint variables based on the paint region.\n    switch (region) {\n      case 'all':\n        x1 = xMin;\n        y1 = yMin;\n        x2 = xMax;\n        y2 = yMax;\n        break;\n      case 'body':\n        r1 = Math.max(0, Math.min(r1, rs.count));\n        c1 = Math.max(0, Math.min(c1, cs.count));\n        r2 = Math.max(0, Math.min(r2, rs.count));\n        c2 = Math.max(0, Math.min(c2, cs.count));\n        x1 = cs.offsetOf(c1) - sx + hw;\n        y1 = rs.offsetOf(r1) - sy + hh;\n        x2 = cs.extentOf(c2) - sx + hw;\n        y2 = rs.extentOf(r2) - sy + hh;\n        break;\n      case 'row-header':\n        r1 = Math.max(0, Math.min(r1, rs.count));\n        c1 = Math.max(0, Math.min(c1, rhs.count));\n        r2 = Math.max(0, Math.min(r2, rs.count));\n        c2 = Math.max(0, Math.min(c2, rhs.count));\n        x1 = rhs.offsetOf(c1);\n        y1 = rs.offsetOf(r1) - sy + hh;\n        x2 = rhs.extentOf(c2);\n        y2 = rs.extentOf(r2) - sy + hh;\n        break;\n      case 'column-header':\n        r1 = Math.max(0, Math.min(r1, chs.count));\n        c1 = Math.max(0, Math.min(c1, cs.count));\n        r2 = Math.max(0, Math.min(r2, chs.count));\n        c2 = Math.max(0, Math.min(c2, cs.count));\n        x1 = cs.offsetOf(c1) - sx + hw;\n        y1 = chs.offsetOf(r1);\n        x2 = cs.extentOf(c2) - sx + hw;\n        y2 = chs.extentOf(r2);\n        break;\n      case 'corner-header':\n        r1 = Math.max(0, Math.min(r1, chs.count));\n        c1 = Math.max(0, Math.min(c1, rhs.count));\n        r2 = Math.max(0, Math.min(r2, chs.count));\n        c2 = Math.max(0, Math.min(c2, rhs.count));\n        x1 = rhs.offsetOf(c1);\n        y1 = chs.offsetOf(r1);\n        x2 = rhs.extentOf(c2);\n        y2 = chs.extentOf(r2);\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Bail early if the dirty rect is outside the bounds.\n    if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n      return;\n    }\n\n    // Clamp the dirty rect to the paint bounds.\n    x1 = Math.max(xMin, Math.min(x1, xMax));\n    y1 = Math.max(yMin, Math.min(y1, yMax));\n    x2 = Math.max(xMin, Math.min(x2, xMax));\n    y2 = Math.max(yMin, Math.min(y2, yMax));\n\n    // Paint the content of the dirty rect.\n    this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'overlay-paint-request'` message.\n   */\n  private _onViewportOverlayPaintRequest(msg: Message): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Paint the content of the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'row-resize-request'` message.\n   */\n  private _onViewportRowResizeRequest(msg: Private.RowResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeRow(msg.index, msg.size);\n    } else {\n      this._resizeColumnHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'column-resize-request'` message.\n   */\n  private _onViewportColumnResizeRequest(\n    msg: Private.ColumnResizeRequest\n  ): void {\n    if (msg.region === 'body') {\n      this._resizeColumn(msg.index, msg.size);\n    } else {\n      this._resizeRowHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * Handle the `thumbMoved` signal from a scroll bar.\n   */\n  private _onThumbMoved(sender: ScrollBar): void {\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Handle the `pageRequested` signal from a scroll bar.\n   */\n  private _onPageRequested(\n    sender: ScrollBar,\n    dir: 'decrement' | 'increment'\n  ): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * Handle the `stepRequested` signal from a scroll bar.\n   */\n  private _onStepRequested(\n    sender: ScrollBar,\n    dir: 'decrement' | 'increment'\n  ): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   */\n  private _onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    switch (args.type) {\n      case 'rows-inserted':\n        this._onRowsInserted(args);\n        break;\n      case 'columns-inserted':\n        this._onColumnsInserted(args);\n        break;\n      case 'rows-removed':\n        this._onRowsRemoved(args);\n        break;\n      case 'columns-removed':\n        this._onColumnsRemoved(args);\n        break;\n      case 'rows-moved':\n        this._onRowsMoved(args);\n        break;\n      case 'columns-moved':\n        this._onColumnsMoved(args);\n        break;\n      case 'cells-changed':\n        this._onCellsChanged(args);\n        break;\n      case 'model-reset':\n        this._onModelReset(args);\n        break;\n      default:\n        throw 'unreachable';\n    }\n  }\n\n  /**\n   * A signal handler for the selection model `changed` signal.\n   */\n  private _onSelectionsChanged(sender: SelectionModel): void {\n    this.repaintOverlay();\n  }\n\n  /**\n   * Handle rows being inserted in the data model.\n   */\n  private _onRowsInserted(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.insert(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being inserted into the data model.\n   */\n  private _onColumnsInserted(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.insert(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows being removed from the data model.\n   */\n  private _onRowsRemoved(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.remove(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being removed from the data model.\n   */\n  private _onColumnsRemoved(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.remove(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows moving in the data model.\n   */\n  private _onRowsMoved(args: DataModel.RowsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let r1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let r2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', r1, 0, r2, Infinity);\n      this.repaintRegion('row-header', r1, 0, r2, Infinity);\n    } else {\n      this.repaintRegion('column-header', r1, 0, r2, Infinity);\n      this.repaintRegion('corner-header', r1, 0, r2, Infinity);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns moving in the data model.\n   */\n  private _onColumnsMoved(args: DataModel.ColumnsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Compute the first affected index.\n    let c1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let c2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', 0, c1, Infinity, c2);\n      this.repaintRegion('column-header', 0, c1, Infinity, c2);\n    } else {\n      this.repaintRegion('row-header', 0, c1, Infinity, c2);\n      this.repaintRegion('corner-header', 0, c1, Infinity, c2);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle cells changing in the data model.\n   */\n  private _onCellsChanged(args: DataModel.CellsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, row, column, rowSpan, columnSpan } = args;\n\n    // Bail early if there are no cells to modify.\n    if (rowSpan <= 0 && columnSpan <= 0) {\n      return;\n    }\n\n    // Compute the changed cell bounds.\n    let r1 = row;\n    let c1 = column;\n    let r2 = r1 + rowSpan - 1;\n    let c2 = c1 + columnSpan - 1;\n\n    // Schedule a repaint of the cell content.\n    this.repaintRegion(region, r1, c1, r2, c2);\n  }\n\n  /**\n   * Handle a full data model reset.\n   */\n  private _onModelReset(args: DataModel.ModelResetArgs): void {\n    // Look up the various current section counts.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n    let nrh = this._rowHeaderSections.count;\n    let nch = this._columnHeaderSections.count;\n\n    // Compute the delta count for each region.\n    let dr = this._dataModel!.rowCount('body') - nr;\n    let dc = this._dataModel!.columnCount('body') - nc;\n    let drh = this._dataModel!.columnCount('row-header') - nrh;\n    let dch = this._dataModel!.rowCount('column-header') - nch;\n\n    // Update the row sections, if needed.\n    if (dr > 0) {\n      this._rowSections.insert(nr, dr);\n    } else if (dr < 0) {\n      this._rowSections.remove(nr + dr, -dr);\n    }\n\n    // Update the column sections, if needed.\n    if (dc > 0) {\n      this._columnSections.insert(nc, dc);\n    } else if (dc < 0) {\n      this._columnSections.remove(nc + dc, -dc);\n    }\n\n    // Update the row header sections, if needed.\n    if (drh > 0) {\n      this._rowHeaderSections.insert(nrh, drh);\n    } else if (drh < 0) {\n      this._rowHeaderSections.remove(nrh + drh, -drh);\n    }\n\n    // Update the column header sections, if needed.\n    if (dch > 0) {\n      this._columnHeaderSections.insert(nch, dch);\n    } else if (dch < 0) {\n      this._columnHeaderSections.remove(nch + dch, -dch);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * A signal handler for the renderer map `changed` signal.\n   */\n  private _onRenderersChanged(): void {\n    this.repaintContent();\n  }\n\n  /**\n   * Handle the `'keydown'` event for the data grid.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._keyHandler) {\n      this._keyHandler.onKeyDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the data grid.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Activate the grid.\n    this.activate();\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('mousedown', this, true);\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Flip the mousedown flag.\n    this._mousedown = true;\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the data grid.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Stop the event propagation if the mouse is down.\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    // Bail if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Dispatch to the mouse handler.\n    if (this._mousedown) {\n      this._mouseHandler.onMouseMove(this, event);\n    } else {\n      this._mouseHandler.onMouseHover(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the data grid.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseUp(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'dblclick'` event for the data grid.\n   */\n  private _evtMouseDoubleClick(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDoubleClick(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'mouseleave'` event for the data grid.\n   */\n  private _evtMouseLeave(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onMouseLeave(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'contextmenu'` event for the data grid.\n   */\n  private _evtContextMenu(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onContextMenu(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'wheel'` event for the data grid.\n   */\n  private _evtWheel(event: WheelEvent): void {\n    // Ignore the event if `accel` is held.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Bail early if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Dispatch to the mouse handler.\n    this._mouseHandler.onWheel(this, event);\n  }\n\n  /**\n   * Release the mouse grab.\n   */\n  private _releaseMouse(): void {\n    // Clear the mousedown flag.\n    this._mousedown = false;\n\n    // Relase the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.release();\n    }\n\n    // Remove the document listeners.\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('mousedown', this, true);\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Refresh the dpi ratio.\n   */\n  private _refreshDPI(): void {\n    // Get the best integral value for the dpi ratio.\n    let dpiRatio = Math.ceil(window.devicePixelRatio);\n\n    // Bail early if the computed dpi ratio has not changed.\n    if (this._dpiRatio === dpiRatio) {\n      return;\n    }\n\n    // Update the internal dpi ratio.\n    this._dpiRatio = dpiRatio;\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n\n    // Update the canvas size for the new dpi ratio.\n    this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n\n    // Ensure the canvas style is scaled for the new ratio.\n    this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;\n    this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;\n\n    // Ensure the overlay style is scaled for the new ratio.\n    this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;\n    this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;\n  }\n\n  /**\n   * Resize a row section immediately.\n   */\n  private _resizeRow(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the column header height.\n    let hh = this.headerHeight;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hh - this._scrollY;\n\n    // Bail early if there is nothing to paint.\n    if (hh >= vh || offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hh) {\n      this._scrollY += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hh, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, pos, vw, vh - pos);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the X blit dimensions.\n    let sx = 0;\n    let sw = vw;\n    let dx = 0;\n\n    // Compute the Y blit dimensions.\n    let sy: number;\n    let sh: number;\n    let dy: number;\n    if (offset + newSize <= hh) {\n      sy = hh - delta;\n      sh = vh - sy;\n      dy = hh;\n    } else {\n      sy = offset + oldSize;\n      sh = vh - sy;\n      dy = sy + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hh) {\n      this.paintContent(0, pos, vw, offset + newSize - pos);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = hh + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Repaint merged cells that are intersected by the resized row\n    // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n    for (const rgn of ['body', 'row-header'] as DataModel.CellRegion[]) {\n      const cellGroups = CellGroup.getCellGroupsAtRow(\n        this.dataModel!,\n        rgn,\n        index\n      );\n\n      let paintRgn = {\n        region: rgn,\n        xMin: 0,\n        xMax: 0,\n        yMin: 0,\n        yMax: 0\n      };\n\n      let backgroundColor = undefined;\n\n      switch (rgn) {\n        case 'body':\n          paintRgn.xMin = this.headerWidth;\n          paintRgn.xMax = this.headerWidth + this.bodyWidth;\n          paintRgn.yMin = this.headerHeight;\n          paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n          backgroundColor = this._style.backgroundColor;\n          break;\n        case 'row-header':\n          paintRgn.xMin = 0;\n          paintRgn.xMax = this.headerWidth;\n          paintRgn.yMin = this.headerHeight;\n          paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n          backgroundColor = this._style.headerBackgroundColor;\n          break;\n      }\n\n      this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column section immediately.\n   */\n  private _resizeColumn(index: number, size: number | null): void {\n    // Look up the target section list.\n    let list = this._columnSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    const adjustedSize = size ?? this._getMaxWidthInColumn(index, 'body');\n\n    if (!adjustedSize || adjustedSize == 0) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(adjustedSize);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the row header width.\n    let hw = this.headerWidth;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hw - this._scrollX;\n\n    // Bail early if there is nothing to paint.\n    if (hw >= vw || offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hw) {\n      this._scrollX += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hw, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(pos, 0, vw - pos, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the Y blit dimensions.\n    let sy = 0;\n    let sh = vh;\n    let dy = 0;\n\n    // Compute the X blit dimensions.\n    let sx: number;\n    let sw: number;\n    let dx: number;\n    if (offset + newSize <= hw) {\n      sx = hw - delta;\n      sw = vw - sx;\n      dx = hw;\n    } else {\n      sx = offset + oldSize;\n      sw = vw - sx;\n      dx = sx + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hw) {\n      this.paintContent(pos, 0, offset + newSize - pos, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = hw + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Repaint merged cells that are intersected by the resized column\n    // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n    for (const rgn of ['body', 'column-header'] as DataModel.CellRegion[]) {\n      const cellGroups = CellGroup.getCellGroupsAtColumn(\n        this.dataModel!,\n        rgn,\n        index\n      );\n\n      let paintRgn = {\n        region: rgn,\n        xMin: 0,\n        xMax: 0,\n        yMin: 0,\n        yMax: 0\n      };\n\n      let backgroundColor = undefined;\n\n      switch (rgn) {\n        case 'body':\n          paintRgn.xMin = this.headerWidth;\n          paintRgn.xMax = this.headerWidth + this.bodyWidth;\n          paintRgn.yMin = this.headerHeight;\n          paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n          backgroundColor = this._style.backgroundColor;\n          break;\n        case 'column-header':\n          paintRgn.xMin = this.headerWidth;\n          paintRgn.xMax = this.headerWidth + this.bodyWidth;\n          paintRgn.yMin = 0;\n          paintRgn.yMax = this.headerHeight;\n\n          backgroundColor = this._style.headerBackgroundColor;\n          break;\n      }\n\n      this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a row header section immediately.\n   */\n  private _resizeRowHeader(index: number, size: number | null): void {\n    // Look up the target section list.\n    let list = this._rowHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    const adjustedSize = size ?? this._getMaxWidthInColumn(index, 'row-header');\n\n    if (!adjustedSize || adjustedSize == 0) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(adjustedSize);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(offset, 0, vw - offset, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = offset + oldSize;\n    let sy = 0;\n    let sw = vw - sx;\n    let sh = vh;\n    let dx = sx + delta;\n    let dy = 0;\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(offset, 0, newSize, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = this.headerWidth + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Repaint merged cells that are intersected by the resized row\n    // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n    for (const rgn of [\n      'corner-header',\n      'row-header'\n    ] as DataModel.CellRegion[]) {\n      const cellGroups = CellGroup.getCellGroupsAtColumn(\n        this.dataModel!,\n        rgn,\n        index\n      );\n\n      let paintRgn = {\n        region: rgn,\n        xMin: 0,\n        xMax: 0,\n        yMin: 0,\n        yMax: 0\n      };\n\n      switch (rgn) {\n        case 'corner-header':\n          paintRgn.xMin = 0;\n          paintRgn.xMax = this.headerWidth;\n          paintRgn.yMin = 0;\n          paintRgn.yMax = this.headerHeight;\n          break;\n        case 'row-header':\n          paintRgn.xMin = 0;\n          paintRgn.xMax = this.headerWidth;\n          paintRgn.yMin = this.headerHeight;\n          paintRgn.yMax = this.headerHeight + this.bodyHeight;\n          break;\n      }\n\n      this._paintMergedCells(\n        cellGroups,\n        paintRgn,\n        this._style.headerBackgroundColor\n      );\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column header section immediately.\n   */\n  private _resizeColumnHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, offset, vw, vh - offset);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = 0;\n    let sy = offset + oldSize;\n    let sw = vw;\n    let sh = vh - sy;\n    let dx = 0;\n    let dy = sy + delta;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(0, offset, vw, newSize);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = this.headerHeight + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Repaint merged cells that are intersected by the resized row\n    // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n    for (const rgn of [\n      'corner-header',\n      'column-header'\n    ] as DataModel.CellRegion[]) {\n      const cellGroups = CellGroup.getCellGroupsAtRow(\n        this.dataModel!,\n        rgn,\n        index\n      );\n\n      let paintRgn = {\n        region: rgn,\n        xMin: 0,\n        xMax: 0,\n        yMin: 0,\n        yMax: 0\n      };\n\n      switch (rgn) {\n        case 'corner-header':\n          paintRgn.xMin = 0;\n          paintRgn.xMax = this.headerWidth;\n          paintRgn.yMin = 0;\n          paintRgn.yMax = this.headerHeight;\n          break;\n        case 'column-header':\n          paintRgn.xMin = this.headerWidth;\n          paintRgn.xMax = this.headerWidth + this.bodyWidth;\n          paintRgn.yMin = 0;\n          paintRgn.yMax = this.headerHeight;\n          break;\n      }\n\n      this._paintMergedCells(\n        cellGroups,\n        paintRgn,\n        this._style.headerBackgroundColor\n      );\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Scroll immediately to the specified offset position.\n   */\n  private _scrollTo(x: number, y: number): void {\n    // Bail if no data model found.\n    if (!this.dataModel) {\n      return;\n    }\n\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Synchronize the scroll bar values.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Compute the delta scroll amount.\n    let dx = x - this._scrollX;\n    let dy = y - this._scrollY;\n\n    // Bail early if there is no effective scroll.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the current size of the viewport.\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    // Bail early if the viewport is empty.\n    if (width === 0 || height === 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Get the visible content dimensions.\n    let contentWidth = width - contentX;\n    let contentHeight = height - contentY;\n\n    // Bail early if there is no content to draw.\n    if (contentWidth <= 0 && contentHeight <= 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Compute the area which needs painting for the `dx` scroll.\n    let dxArea = 0;\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        dxArea = contentWidth * height;\n      } else {\n        dxArea = Math.abs(dx) * height;\n      }\n    }\n\n    // Compute the area which needs painting for the `dy` scroll.\n    let dyArea = 0;\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        dyArea = width * contentHeight;\n      } else {\n        dyArea = width * Math.abs(dy);\n      }\n    }\n\n    // If the area sum is larger than the total, paint everything.\n    if (dxArea + dyArea >= width * height) {\n      this._scrollX = x;\n      this._scrollY = y;\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Update the internal Y scroll position.\n    this._scrollY = y;\n\n    // Scroll the Y axis if needed. If the scroll distance exceeds\n    // the visible height, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        this.paintContent(0, contentY, width, contentHeight);\n      } else {\n        const x = 0;\n        const y = dy < 0 ? contentY : contentY + dy;\n        const w = width;\n        const h = contentHeight - Math.abs(dy);\n        this._blitContent(this._canvas, x, y, w, h, x, y - dy);\n        this.paintContent(\n          0,\n          dy < 0 ? contentY : height - dy,\n          width,\n          Math.abs(dy)\n        );\n\n        // Repaint merged cells that are intersected by the scroll level\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of ['body', 'row-header'] as DataModel.CellRegion[]) {\n          const cellgroups = CellGroup.getCellGroupsAtRegion(\n            this.dataModel,\n            rgn\n          );\n\n          let paintRgn = {\n            region: rgn,\n            xMin: 0,\n            xMax: 0,\n            yMin: 0,\n            yMax: 0\n          };\n\n          let backgroundColor = undefined;\n\n          switch (rgn) {\n            case 'body':\n              paintRgn.xMin = this.headerWidth;\n              paintRgn.xMax = this.headerWidth + this.bodyWidth;\n              paintRgn.yMin = this.headerHeight;\n              paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n              backgroundColor = this._style.backgroundColor;\n              break;\n            case 'row-header':\n              paintRgn.xMin = 0;\n              paintRgn.xMax = this.headerWidth;\n              paintRgn.yMin = this.headerHeight;\n              paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n              backgroundColor = this._style.headerBackgroundColor;\n              break;\n          }\n\n          this._paintMergedCells(cellgroups, paintRgn, backgroundColor);\n        }\n      }\n    }\n\n    // Update the internal X scroll position.\n    this._scrollX = x;\n\n    // Scroll the X axis if needed. If the scroll distance exceeds\n    // the visible width, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        this.paintContent(contentX, 0, contentWidth, height);\n      } else {\n        const x = dx < 0 ? contentX : contentX + dx;\n        const y = 0;\n        const w = contentWidth - Math.abs(dx);\n        const h = height;\n        this._blitContent(this._canvas, x, y, w, h, x - dx, y);\n        this.paintContent(\n          dx < 0 ? contentX : width - dx,\n          0,\n          Math.abs(dx),\n          height\n        );\n\n        // Repaint merged cells that are intersected by the scroll level\n        // Otherwise it will be cut in two by the valid content, and drawn incorrectly\n        for (const rgn of ['body', 'column-header'] as DataModel.CellRegion[]) {\n          const cellGroups = CellGroup.getCellGroupsAtRegion(\n            this.dataModel,\n            rgn\n          );\n\n          let paintRgn = {\n            region: rgn,\n            xMin: 0,\n            xMax: 0,\n            yMin: 0,\n            yMax: 0\n          };\n\n          let backgroundColor = undefined;\n\n          switch (rgn) {\n            case 'body':\n              paintRgn.xMin = this.headerWidth;\n              paintRgn.xMax = this.headerWidth + this.bodyWidth;\n              paintRgn.yMin = this.headerHeight;\n              paintRgn.yMax = this.headerHeight + this.bodyHeight;\n\n              backgroundColor = this._style.backgroundColor;\n              break;\n            case 'column-header':\n              paintRgn.xMin = this.headerWidth;\n              paintRgn.xMax = this.headerWidth + this.bodyWidth;\n              paintRgn.yMin = 0;\n              paintRgn.yMax = this.headerHeight;\n\n              backgroundColor = this._style.headerBackgroundColor;\n              break;\n          }\n\n          this._paintMergedCells(cellGroups, paintRgn, backgroundColor);\n        }\n      }\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n  /**\n   * Blit content into the on-screen grid canvas.\n   *\n   * The rect should be expressed in viewport coordinates.\n   *\n   * This automatically accounts for the dpi ratio.\n   */\n  private _blitContent(\n    source: HTMLCanvasElement,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    dx: number,\n    dy: number\n  ): void {\n    // Scale the blit coordinates by the dpi ratio.\n    x *= this._dpiRatio;\n    y *= this._dpiRatio;\n    w *= this._dpiRatio;\n    h *= this._dpiRatio;\n    dx *= this._dpiRatio;\n    dy *= this._dpiRatio;\n\n    // Save the current gc state.\n    this._canvasGC.save();\n\n    // Set the transform to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Draw the specified content.\n    this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n\n    // Restore the gc state.\n    this._canvasGC.restore();\n  }\n\n  /**\n   * Paint the grid content for the given dirty rect.\n   *\n   * The rect should be expressed in valid viewport coordinates.\n   *\n   * This is the primary paint entry point. The individual `_draw*`\n   * methods should not be invoked directly. This method dispatches\n   * to the drawing methods in the correct order.\n   */\n  protected paintContent(rx: number, ry: number, rw: number, rh: number): void {\n    // Scale the canvas and buffer GC for the dpi ratio.\n    this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n    this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the dirty rect of all content.\n    this._canvasGC.clearRect(rx, ry, rw, rh);\n\n    // Draw the void region.\n    this._drawVoidRegion(rx, ry, rw, rh);\n\n    // Draw the body region.\n    this._drawBodyRegion(rx, ry, rw, rh);\n\n    // Draw the row header region.\n    this._drawRowHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the column header region.\n    this._drawColumnHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the corner header region.\n    this.drawCornerHeaderRegion(rx, ry, rw, rh);\n  }\n\n  /**\n   * Resizes body column headers so their text fits\n   * without clipping or wrapping.\n   * @param dataModel\n   */\n  private _fitBodyColumnHeaders(\n    dataModel: DataModel,\n    padding: number,\n    numCols?: number\n  ): void {\n    // Get the body column count\n    const bodyColumnCount =\n      numCols === undefined ? dataModel.columnCount('body') : numCols;\n\n    for (let i = 0; i < bodyColumnCount; i++) {\n      /*\n        if we're working with nested column headers,\n        retrieve the nested levels and iterate on them.\n      */\n      const numRows = dataModel.rowCount('column-header');\n\n      /*\n        Calculate the maximum text width, across\n        all nested rows under a given column number.\n      */\n      let maxWidth = 0;\n      for (let j = 0; j < numRows; j++) {\n        const config = DataGrid._getConfig(dataModel, j, i, 'column-header');\n        const textWidth = this._getCellTextWidth(config);\n        // Update the maximum width for that column.\n        maxWidth = Math.max(maxWidth, textWidth);\n      }\n\n      /*\n        Send a resize message with new width for the given column.\n        Using a padding of 15 pixels to leave some room.\n      */\n      this.resizeColumn('body', i, maxWidth + padding);\n    }\n  }\n\n  /**\n   * Resizes row header columns so their text fits\n   * without clipping or wrapping.\n   * @param dataModel\n   */\n  private _fitRowColumnHeaders(\n    dataModel: DataModel,\n    padding: number,\n    numCols?: number\n  ): void {\n    /*\n      if we're working with nested row headers,\n      retrieve the nested levels and iterate on them.\n    */\n    const rowColumnCount =\n      numCols === undefined ? dataModel.columnCount('row-header') : numCols;\n\n    for (let i = 0; i < rowColumnCount; i++) {\n      const numCols = dataModel.rowCount('column-header');\n      /*\n        Calculate the maximum text width, across\n        all nested columns under a given row index.\n      */\n      let maxWidth = 0;\n      for (let j = 0; j < numCols; j++) {\n        const config = DataGrid._getConfig(dataModel, j, i, 'corner-header');\n        const textWidth = this._getCellTextWidth(config);\n        maxWidth = Math.max(maxWidth, textWidth);\n      }\n\n      /*\n        Send a resize message with new width for the given column.\n        Using a padding of 15 pixels to leave some room.\n      */\n      this.resizeColumn('row-header', i, maxWidth + padding);\n    }\n  }\n\n  /**\n   * Paint the overlay content for the entire grid.\n   *\n   * This is the primary overlay paint entry point. The individual\n   * `_draw*` methods should not be invoked directly. This method\n   * dispatches to the drawing methods in the correct order.\n   */\n  private _paintOverlay(): void {\n    // Scale the overlay GC for the dpi ratio.\n    this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the overlay of all content.\n    this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n\n    // Draw the body selections.\n    this._drawBodySelections();\n\n    // Draw the row header selections.\n    this._drawRowHeaderSelections();\n\n    // Draw the column header selections.\n    this._drawColumnHeaderSelections();\n\n    // Draw the cursor.\n    this._drawCursor();\n\n    // Draw the shadows.\n    this._drawShadows();\n  }\n\n  /**\n   * Draw the void region for the dirty rect.\n   */\n  private _drawVoidRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Look up the void color.\n    let color = this._style.voidColor;\n\n    // Bail if there is no void color.\n    if (!color) {\n      return;\n    }\n\n    // Fill the dirty rect with the void color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(rx, ry, rw, rh);\n  }\n\n  /**\n   * Draw the body region which intersects the dirty rect.\n   */\n  private _drawBodyRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this._columnSections.length - this._scrollX;\n    let contentH = this._rowSections.length - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let bw = this.bodyWidth;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is streched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Adjust the geometry if the last column is streched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'body',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.backgroundColor);\n\n    // Draw the row background.\n    this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n\n    // Draw the column background.\n    this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.horizontalGridLineColor || this._style.gridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.verticalGridLineColor || this._style.gridLineColor\n    );\n\n    // Get the cellgroups from the cell-region that intersects with the paint region\n    const cellGroups = CellGroup.getCellGroupsAtRegion(\n      this.dataModel!,\n      rgn.region\n    ).filter(group => {\n      return this.cellGroupInteresectsRegion(group, rgn);\n    });\n\n    // Draw merged cells\n    this._paintMergedCells(cellGroups, rgn, this._style.backgroundColor);\n  }\n\n  /**\n   * Draw the row header region which intersects the dirty rect.\n   */\n  private _drawRowHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.bodyHeight - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Fetch max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._rowHeaderSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is stretched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'row-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n\n    // Get the cellgroups from the cell-region that intersects with the paint region\n    const cellGroups = CellGroup.getCellGroupsAtRegion(\n      this.dataModel!,\n      rgn.region\n    ).filter(group => {\n      return this.cellGroupInteresectsRegion(group, rgn);\n    });\n\n    // Draw merged cells\n    this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n  }\n\n  /**\n   * Draw the column header region which intersects the dirty rect.\n   */\n  private _drawColumnHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.bodyWidth - this._scrollX;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._columnHeaderSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last column is stretched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'column-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n\n    // Get the cellgroups from the cell-region that intersects with the paint region\n    const cellGroups = CellGroup.getCellGroupsAtRegion(\n      this.dataModel!,\n      rgn.region\n    ).filter(group => {\n      return this.cellGroupInteresectsRegion(group, rgn);\n    });\n\n    // Draw merged cells\n    this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n  }\n\n  /**\n   * Draw the corner header region which intersects the dirty rect.\n   */\n  protected drawCornerHeaderRegion(\n    rx: number,\n    ry: number,\n    rw: number,\n    rh: number\n  ): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = this._columnHeaderSections.count - 1;\n    }\n    if (c2 < 0) {\n      c2 = this._rowHeaderSections.count - 1;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'corner-header',\n      xMin: x1,\n      yMin: y1,\n      xMax: x2,\n      yMax: y2,\n      x,\n      y,\n      width,\n      height,\n      row: r1,\n      column: c1,\n      rowSizes,\n      columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(\n      rgn,\n      this._style.headerHorizontalGridLineColor ||\n        this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(\n      rgn,\n      this._style.headerVerticalGridLineColor || this._style.headerGridLineColor\n    );\n\n    // Get the cellgroups from the cell-region that intersects with the paint region\n    const cellGroups = CellGroup.getCellGroupsAtRegion(\n      this.dataModel!,\n      rgn.region\n    ).filter(group => {\n      return this.cellGroupInteresectsRegion(group, rgn);\n    });\n\n    // Draw merged cells\n    this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);\n  }\n\n  /**\n   * Draw the background for the given paint region.\n   */\n  private _drawBackground(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Unpack the region.\n    let { xMin, yMin, xMax, yMax } = rgn;\n\n    // Fill the region with the specified color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n  }\n\n  /**\n   * Draw the row background for the given paint region.\n   */\n  private _drawRowBackground(\n    rgn: Private.PaintRegion,\n    colorFn: ((i: number) => string) | undefined\n  ): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the X bounds for the row.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n\n    // Draw the background for the rows in the region.\n    for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the row.\n      let color = colorFn(rgn.row + j);\n\n      // Fill the row with the background color if needed.\n      if (color) {\n        let y1 = Math.max(rgn.yMin, y);\n        let y2 = Math.min(y + size - 1, rgn.yMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n  }\n\n  /**\n   * Draw the column background for the given paint region.\n   */\n  private _drawColumnBackground(\n    rgn: Private.PaintRegion,\n    colorFn: ((i: number) => string) | undefined\n  ): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the Y bounds for the column.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Draw the background for the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the column.\n      let color = colorFn(rgn.column + i);\n\n      // Fill the column with the background color if needed.\n      if (color) {\n        let x1 = Math.max(rgn.xMin, x);\n        let x2 = Math.min(x + size - 1, rgn.xMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n  }\n\n  /**\n   * Returns column size\n   * @param region\n   * @param index\n   */\n  private _getColumnSize(region: DataModel.CellRegion, index: number): number {\n    if (region === 'corner-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n    return this.columnSize(region as DataModel.ColumnRegion, index);\n  }\n\n  /**\n   * Returns row size\n   * @param region\n   * @param index\n   */\n  private _getRowSize(region: DataModel.CellRegion, index: number): number {\n    if (region === 'corner-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n    return this.rowSize(region as DataModel.RowRegion, index);\n  }\n\n  /**\n   * Draw the cells for the given paint region.\n   */\n  private _drawCells(rgn: Private.PaintRegion): void {\n    // Bail if there is no data model.\n    if (!this._dataModel) {\n      return;\n    }\n\n    // Set up the cell config object for rendering.\n    let config = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      region: rgn.region,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: DataModel.emptyMetadata\n    };\n\n    let groupIndex = -1;\n\n    // Save the buffer gc before wrapping.\n    this._bufferGC.save();\n\n    // Wrap the buffer gc for painting the cells.\n    let gc = new GraphicsContext(this._bufferGC);\n\n    let height = 0;\n\n    // Loop over the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let width = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (width === 0) {\n        continue;\n      }\n\n      // Compute the column index.\n      let column = rgn.column + i;\n\n      // Update the config for the current column.\n      config.x = x;\n      config.width = width;\n      config.column = column;\n\n      // Loop over the rows in the column.\n      for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n        // Fetch the size of the row.\n        height = rgn.rowSizes[j];\n\n        // Skip zero sized rows.\n        if (height === 0) {\n          continue;\n        }\n\n        // Compute the row index.\n        let row = rgn.row + j;\n\n        groupIndex = CellGroup.getGroupIndex(\n          this.dataModel!,\n          config.region,\n          row,\n          column\n        );\n\n        // For merged cell regions, don't do anything, we draw merged regions later.\n        if (groupIndex !== -1) {\n          y += height;\n          continue;\n        }\n\n        // Clear the buffer rect for the cell.\n        gc.clearRect(x, y, width, height);\n\n        let value = DataGrid._getCellValue(\n          this.dataModel as DataModel,\n          rgn.region,\n          row,\n          column\n        );\n        let metadata = DataGrid._getCellMetadata(\n          this.dataModel as DataModel,\n          rgn.region,\n          row,\n          column\n        );\n\n        // Update the config for the current cell.\n        config.y = y;\n        config.height = height;\n        config.width = width;\n        config.row = row;\n        config.value = value;\n        config.metadata = metadata;\n\n        // Get the renderer for the cell.\n        let renderer = this._cellRenderers.get(config);\n\n        // Save the GC state.\n        gc.save();\n\n        // Paint the cell into the off-screen buffer.\n        try {\n          if (renderer instanceof AsyncCellRenderer) {\n            if (renderer.isReady(config)) {\n              renderer.paint(gc, config);\n            } else {\n              renderer.paintPlaceholder(gc, config);\n              renderer.load(config).then(() => {\n                const r1 = row;\n                const r2 = row + 1;\n\n                const c1 = column;\n                const c2 = column + 1;\n\n                this.repaintRegion(rgn.region, r1, c1, r2, c2);\n              });\n            }\n          } else {\n            renderer.paint(gc, config);\n          }\n        } catch (err) {\n          console.error(err);\n        }\n\n        // Restore the GC state.\n        gc.restore();\n\n        // Compute the actual X bounds for the cell.\n        let x1 = Math.max(rgn.xMin, config.x);\n        let x2 = Math.min(config.x + config.width - 1, rgn.xMax);\n\n        // Compute the actual Y bounds for the cell.\n        let y1 = Math.max(rgn.yMin, config.y);\n        let y2 = Math.min(config.y + config.height - 1, rgn.yMax);\n\n        this._blitContent(\n          this._buffer,\n          x1,\n          y1,\n          x2 - x1 + 1,\n          y2 - y1 + 1,\n          x1,\n          y1\n        );\n\n        // Increment the running Y coordinate.\n        y += height;\n      }\n\n      // Restore the GC state.\n      gc.restore();\n\n      // Increment the running X coordinate.\n      x += width;\n    }\n\n    // Dispose of the wrapped gc.\n    gc.dispose();\n\n    // Restore the final buffer gc state.\n    this._bufferGC.restore();\n  }\n\n  // TODO Move this in the utils file (but we need the PaintRegion typing)\n  private cellGroupInteresectsRegion(\n    group: CellGroup,\n    rgn: Private.PaintRegion\n  ) {\n    const rgnR1 = rgn.row;\n    const rgnR2 = rgn.row + rgn.rowSizes.length;\n\n    const rgnC1 = rgn.column;\n    const rgnC2 = rgn.column + rgn.columnSizes.length;\n\n    const dx = Math.min(group.r2, rgnR2) - Math.max(group.r1, rgnR1);\n    const dy = Math.min(group.c2, rgnC2) - Math.max(group.c1, rgnC1);\n\n    return dx >= 0 && dy >= 0;\n  }\n\n  private static _getCellValue(\n    dm: DataModel,\n    region: DataModel.CellRegion,\n    row: number,\n    col: number\n  ) {\n    // Get the value for the cell.\n    try {\n      return dm.data(region, row, col);\n    } catch (err) {\n      console.error(err);\n      return null;\n    }\n  }\n\n  private static _getCellMetadata(\n    dm: DataModel,\n    region: DataModel.CellRegion,\n    row: number,\n    col: number\n  ) {\n    // Get the metadata for the cell.\n    try {\n      return dm.metadata(region, row, col);\n    } catch (err) {\n      console.error(err);\n      return DataModel.emptyMetadata;\n    }\n  }\n\n  /**\n   * Paint group cells.\n   */\n  private _paintMergedCells(\n    cellGroups: CellGroup[],\n    rgn: Private.PixelRegion,\n    backgroundColor: string | undefined\n  ): void {\n    // Bail if there is no data model.\n    if (!this._dataModel) {\n      return;\n    }\n\n    // Set up the cell config object for rendering.\n    let config = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      region: rgn.region,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: DataModel.emptyMetadata\n    };\n\n    if (backgroundColor) {\n      this._canvasGC.fillStyle = backgroundColor;\n    }\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Save the buffer gc before wrapping.\n    this._bufferGC.save();\n\n    // Wrap the buffer gc for painting the cells.\n    let gc = new GraphicsContext(this._bufferGC);\n\n    for (const group of cellGroups) {\n      let width = 0;\n      for (let c = group.c1; c <= group.c2; c++) {\n        width += this._getColumnSize(rgn.region, c);\n      }\n\n      let height = 0;\n      for (let r = group.r1; r <= group.r2; r++) {\n        height += this._getRowSize(rgn.region, r);\n      }\n\n      let value = DataGrid._getCellValue(\n        this.dataModel as DataModel,\n        rgn.region,\n        group.r1,\n        group.c1\n      );\n      let metadata = DataGrid._getCellMetadata(\n        this.dataModel as DataModel,\n        rgn.region,\n        group.r1,\n        group.c2\n      );\n\n      let x = 0;\n      let y = 0;\n      switch (rgn.region) {\n        case 'body':\n          x =\n            this._columnSections.offsetOf(group.c1) +\n            this.headerWidth -\n            this._scrollX;\n          y =\n            this._rowSections.offsetOf(group.r1) +\n            this.headerHeight -\n            this._scrollY;\n          break;\n        case 'column-header':\n          x =\n            this._columnSections.offsetOf(group.c1) +\n            this.headerWidth -\n            this._scrollX;\n          y = this._rowSections.offsetOf(group.r1);\n          break;\n        case 'row-header':\n          x = this._columnSections.offsetOf(group.c1);\n          y =\n            this._rowSections.offsetOf(group.r1) +\n            this.headerHeight -\n            this._scrollY;\n          break;\n        case 'corner-header':\n          x = this._columnSections.offsetOf(group.c1);\n          y = this._rowSections.offsetOf(group.r1);\n          break;\n      }\n\n      config.x = x;\n      config.y = y;\n      config.width = width;\n      config.height = height;\n      config.region = rgn.region;\n      config.row = group.r1;\n      config.column = group.c1;\n      config.value = value;\n      config.metadata = metadata;\n\n      // Compute the actual X bounds for the cell.\n      const x1 = Math.max(rgn.xMin, x);\n      const x2 = Math.min(x + width - 2, rgn.xMax);\n\n      // Compute the actual Y bounds for the cell.\n      const y1 = Math.max(rgn.yMin, y);\n      const y2 = Math.min(y + height - 2, rgn.yMax);\n\n      if (x2 <= x1 || y2 <= y1) {\n        continue;\n      }\n\n      // Draw the background.\n      if (backgroundColor) {\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Get the renderer for the cell.\n      let renderer = this._cellRenderers.get(config);\n\n      // Clear the buffer rect for the cell.\n      gc.clearRect(config.x, config.y, width, height);\n\n      // Save the GC state.\n      gc.save();\n\n      // Paint the cell into the off-screen buffer.\n      try {\n        if (renderer instanceof AsyncCellRenderer) {\n          if (renderer.isReady(config)) {\n            renderer.paint(gc, config);\n          } else {\n            renderer.paintPlaceholder(gc, config);\n\n            const r1 = group.r1;\n            const r2 = group.r2;\n\n            const c1 = group.c1;\n            const c2 = group.c2;\n\n            renderer.load(config).then(() => {\n              this.repaintRegion(rgn.region, r1, c1, r2, c2);\n            });\n          }\n        } else {\n          renderer.paint(gc, config);\n        }\n      } catch (err) {\n        console.error(err);\n      }\n\n      // Restore the GC state.\n      gc.restore();\n\n      this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n    }\n\n    // Dispose of the wrapped gc.\n    gc.dispose();\n\n    // Restore the final buffer gc state.\n    this._bufferGC.restore();\n  }\n\n  /**\n   * Draw the horizontal grid lines for the given paint region.\n   */\n  private _drawHorizontalGridLines(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the X bounds for the horizontal lines.\n    const x1 = Math.max(rgn.xMin, rgn.x);\n    const x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n\n    // Begin the path for the grid lines.\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    const bh = this.bodyHeight;\n    const ph = this.pageHeight;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.rowSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastRow && ph > bh) {\n      if (rgn.row + n === this._rowSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the horizontal grid lines.\n    for (let y = rgn.y, j = 0; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the Y position of the line.\n      let pos = y + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.yMin && pos <= rgn.yMax) {\n        this._canvasGC.moveTo(x1, pos + 0.5);\n        this._canvasGC.lineTo(x2, pos + 0.5);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the vertical grid lines for the given paint region.\n   */\n  private _drawVerticalGridLines(\n    rgn: Private.PaintRegion,\n    color: string | undefined\n  ): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the Y bounds for the vertical lines.\n    const y1 = Math.max(rgn.yMin, rgn.y);\n    const y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n\n    // Begin the path for the grid lines\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    const bw = this.bodyWidth;\n    const pw = this.pageWidth;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.columnSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastColumn && pw > bw) {\n      if (rgn.column + n === this._columnSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the vertical grid lines.\n    for (let x = rgn.x, i = 0; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the X position of the line.\n      let pos = x + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.xMin && pos <= rgn.xMax) {\n        this._canvasGC.moveTo(pos + 0.5, y1);\n        this._canvasGC.lineTo(pos + 0.5, y2);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the body selections for the data grid.\n   */\n  private _drawBodySelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections.\n    if (!model || model.isEmpty) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.selectionFillColor;\n    let stroke = this._style.selectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the scroll geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Get the first visible cell of the grid.\n    let r1 = this._rowSections.indexOf(sy);\n    let c1 = this._columnSections.indexOf(sx);\n\n    // Bail early if there are no visible cells.\n    if (r1 < 0 || c1 < 0) {\n      return;\n    }\n\n    // Fetch the extra geometry.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Get the last visible cell of the grid.\n    let r2 = this._rowSections.indexOf(sy + ph);\n    let c2 = this._columnSections.indexOf(sx + pw);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Clamp the last cell if the void space is visible.\n    r2 = r2 < 0 ? maxRow : r2;\n    c2 = c2 < 0 ? maxColumn : c2;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Iterate over the selections.\n    for (let s of model.selections()) {\n      // Skip the section if it's not visible.\n      if (s.r1 < r1 && s.r2 < r1) {\n        continue;\n      }\n      if (s.r1 > r2 && s.r2 > r2) {\n        continue;\n      }\n      if (s.c1 < c1 && s.c2 < c1) {\n        continue;\n      }\n      if (s.c1 > c2 && s.c2 > c2) {\n        continue;\n      }\n\n      // Clamp the cell to the model bounds.\n      let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n      let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n      let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n      let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n      // Swap index order if needed.\n      let tmp: number;\n      if (sr1 > sr2) {\n        tmp = sr1;\n        sr1 = sr2;\n        sr2 = tmp;\n      }\n      if (sc1 > sc2) {\n        tmp = sc1;\n        sc1 = sc2;\n        sc2 = tmp;\n      }\n\n      const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(\n        this.dataModel!,\n        { r1: sr1, r2: sr2, c1: sc1, c2: sc2 },\n        'body'\n      );\n\n      sr1 = joinedGroup.r1;\n      sr2 = joinedGroup.r2;\n      sc1 = joinedGroup.c1;\n      sc2 = joinedGroup.c2;\n\n      // Convert to pixel coordinates.\n      let x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n      let y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n      let x2 = this._columnSections.extentOf(sc2) - sx + hw;\n      let y2 = this._rowSections.extentOf(sr2) - sy + hh;\n\n      // Adjust the trailing X coordinate for column stretch.\n      if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n        x2 = hw + pw - 1;\n      }\n\n      // Adjust the trailing Y coordinate for row stretch.\n      if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n        y2 = hh + ph - 1;\n      }\n\n      // Clamp the bounds to just outside of the clipping rect.\n      x1 = Math.max(hw - 1, x1);\n      y1 = Math.max(hh - 1, y1);\n      x2 = Math.min(hw + pw + 1, x2);\n      y2 = Math.min(hh + ph + 1, y2);\n\n      // Skip zero sized ranges.\n      if (x2 < x1 || y2 < y1) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Stroke the rect if needed.\n      if (stroke) {\n        gc.strokeRect(x1 - 0.5, y1 - 0.5, x2 - x1 + 1, y2 - y1 + 1);\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the row header selections for the data grid.\n   */\n  private _drawRowHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire column.\n    if (!model || model.isEmpty || model.selectionMode == 'column') {\n      return;\n    }\n\n    // Bail early if the row headers are not visible.\n    if (this.headerWidth === 0 || this.pageHeight === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sy = this._scrollY;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let rs = this._rowSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(0, hh, hw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max row.\n    let maxRow = rs.count - 1;\n\n    // Fetch the visible rows.\n    let r1 = rs.indexOf(sy);\n    let r2 = rs.indexOf(sy + ph - 1);\n    r2 = r2 < 0 ? maxRow : r2;\n\n    // Iterate over the visible rows.\n    for (let j = r1; j <= r2; ++j) {\n      // Skip rows which aren't selected.\n      if (!model.isRowSelected(j)) {\n        continue;\n      }\n\n      // Get the dimensions of the row.\n      let y = rs.offsetOf(j) - sy + hh;\n      let h = rs.sizeOf(j);\n\n      // Adjust the height for row stretch.\n      if (this._stretchLastRow && ph > bh && j === maxRow) {\n        h = hh + ph - y;\n      }\n\n      // Skip zero sized rows.\n      if (h === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(0, y, hw, h);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(hw - 0.5, y - 1);\n        gc.lineTo(hw - 0.5, y + h);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the column header selections for the data grid.\n   */\n  private _drawColumnHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire row\n    if (!model || model.isEmpty || model.selectionMode == 'row') {\n      return;\n    }\n\n    // Bail early if the column headers are not visible.\n    if (this.headerHeight === 0 || this.pageWidth === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sx = this._scrollX;\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let cs = this._columnSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(hw, 0, pw, hh);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max column.\n    let maxCol = cs.count - 1;\n\n    // Fetch the visible columns.\n    let c1 = cs.indexOf(sx);\n    let c2 = cs.indexOf(sx + pw - 1);\n    c2 = c2 < 0 ? maxCol : c2;\n\n    // Iterate over the visible columns.\n    for (let i = c1; i <= c2; ++i) {\n      // Skip columns which aren't selected.\n      if (!model.isColumnSelected(i)) {\n        continue;\n      }\n\n      // Get the dimensions of the column.\n      let x = cs.offsetOf(i) - sx + hw;\n      let w = cs.sizeOf(i);\n\n      // Adjust the width for column stretch.\n      if (this._stretchLastColumn && pw > bw && i === maxCol) {\n        w = hw + pw - x;\n      }\n\n      // Skip zero sized columns.\n      if (w === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x, 0, w, hh);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(x - 1, hh - 0.5);\n        gc.lineTo(x + w, hh - 0.5);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay cursor for the data grid.\n   */\n  private _drawCursor(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there is no cursor.\n    if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n      return;\n    }\n\n    // Extract the style information.\n    let fill = this._style.cursorFillColor;\n    let stroke = this._style.cursorBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the cursor location.\n    let startRow = model.cursorRow;\n    let startColumn = model.cursorColumn;\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Bail early if the cursor is out of bounds.\n    if (startRow < 0 || startRow > maxRow) {\n      return;\n    }\n    if (startColumn < 0 || startColumn > maxColumn) {\n      return;\n    }\n\n    let endRow = startRow;\n    let endColumn = startColumn;\n\n    const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(\n      this.dataModel!,\n      { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn },\n      'body'\n    );\n\n    startRow = joinedGroup.r1;\n    endRow = joinedGroup.r2;\n    startColumn = joinedGroup.c1;\n    endColumn = joinedGroup.c2;\n\n    // Fetch geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Get the cursor bounds in viewport coordinates.\n    let x1 = this._columnSections.offsetOf(startColumn) - sx + hw;\n    let x2 = this._columnSections.extentOf(endColumn) - sx + hw;\n    let y1 = this._rowSections.offsetOf(startRow) - sy + hh;\n    let y2 = this._rowSections.extentOf(endRow) - sy + hh;\n\n    // Adjust the trailing X coordinate for column stretch.\n    if (this._stretchLastColumn && pw > bw && startColumn === maxColumn) {\n      x2 = vw - 1;\n    }\n\n    // Adjust the trailing Y coordinate for row stretch.\n    if (this._stretchLastRow && ph > bh && startRow === maxRow) {\n      y2 = vh - 1;\n    }\n\n    // Skip zero sized cursors.\n    if (x2 < x1 || y2 < y1) {\n      return;\n    }\n\n    // Bail early if the cursor is off the screen.\n    if (x1 - 1 >= vw || y1 - 1 >= vh || x2 + 1 < hw || y2 + 1 < hh) {\n      return;\n    }\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Clear any existing overlay content.\n    gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n\n    // Fill the cursor rect if needed.\n    if (fill) {\n      // Set up the fill style.\n      gc.fillStyle = fill;\n\n      // Fill the cursor rect.\n      gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n    }\n\n    // Stroke the cursor border if needed.\n    if (stroke) {\n      // Set up the stroke style.\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 2;\n\n      // Stroke the cursor rect.\n      gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay shadows for the data grid.\n   */\n  private _drawShadows(): void {\n    // Fetch the scroll shadow from the style.\n    let shadow = this._style.scrollShadow;\n\n    // Bail early if there is no shadow to draw.\n    if (!shadow) {\n      return;\n    }\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch maximum scroll position.\n    let sxMax = this.maxScrollX;\n    let syMax = this.maxScrollY;\n\n    // Fetch the header width and height.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the page width and height.\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Fetch the viewport width and height.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Fetch the body width and height.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n\n    // Adjust the body size for row and column stretch.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Fetch the gc object.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Draw the column header shadow if needed.\n    if (sy > 0) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = hh;\n      let x1 = 0;\n      let y1 = y0 + shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = hh;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row header shadow if needed.\n    if (sx > 0) {\n      // Set up the gradient coordinates.\n      let x0 = hw;\n      let y0 = 0;\n      let x1 = x0 + shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = hw;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the column footer shadow if needed.\n    if (sy < syMax) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = vh;\n      let x1 = 0;\n      let y1 = vh - shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = vh - shadow.size;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row footer shadow if needed.\n    if (sx < sxMax) {\n      // Set up the gradient coordinates.\n      let x0 = vw;\n      let y0 = 0;\n      let x1 = vw - shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = vw - shadow.size;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  private _viewport: Widget;\n  private _vScrollBar: ScrollBar;\n  private _hScrollBar: ScrollBar;\n  private _scrollCorner: Widget;\n\n  private _scrollX = 0;\n  private _scrollY = 0;\n  private _viewportWidth = 0;\n  private _viewportHeight = 0;\n\n  private _mousedown = false;\n  private _keyHandler: DataGrid.IKeyHandler | null = null;\n  private _mouseHandler: DataGrid.IMouseHandler | null = null;\n\n  private _vScrollBarMinWidth = 0;\n  private _hScrollBarMinHeight = 0;\n  private _dpiRatio = Math.ceil(window.devicePixelRatio);\n\n  private _canvas: HTMLCanvasElement;\n  private _buffer: HTMLCanvasElement;\n  private _overlay: HTMLCanvasElement;\n  private _canvasGC: CanvasRenderingContext2D;\n  private _bufferGC: CanvasRenderingContext2D;\n  private _overlayGC: CanvasRenderingContext2D;\n\n  private _rowSections: SectionList;\n  private _columnSections: SectionList;\n  private _rowHeaderSections: SectionList;\n  private _columnHeaderSections: SectionList;\n\n  private _dataModel: DataModel | null = null;\n  private _selectionModel: SelectionModel | null = null;\n\n  private _stretchLastRow: boolean;\n  private _stretchLastColumn: boolean;\n\n  private _style: DataGrid.Style;\n  private _cellRenderers: RendererMap;\n  private _copyConfig: DataGrid.CopyConfig;\n  private _headerVisibility: DataGrid.HeaderVisibility;\n  private _editorController: ICellEditorController | null;\n  private _editingEnabled: boolean = false;\n}\n\n/**\n * The namespace for the `DataGrid` class statics.\n */\nexport namespace DataGrid {\n  /**\n   * An object which defines the style for a data grid.\n   *\n   * #### Notes\n   * All style colors support the full CSS color syntax.\n   */\n  export type Style = {\n    /**\n     * The void color for the data grid.\n     *\n     * This is the base fill color for the entire data grid.\n     */\n    readonly voidColor?: string;\n\n    /**\n     * The background color for the body cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly backgroundColor?: string;\n\n    /**\n     * A function which returns the background color for a row.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid rows.\n     */\n    readonly rowBackgroundColor?: (index: number) => string;\n\n    /**\n     * A function which returns the background color for a column.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid columns.\n     */\n    readonly columnBackgroundColor?: (index: number) => string;\n\n    /**\n     * The color for the grid lines of the body cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly gridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly verticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly horizontalGridLineColor?: string;\n\n    /**\n     * The background color for the header cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly headerBackgroundColor?: string;\n\n    /**\n     * The color for the grid lines of the header cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly headerGridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerVerticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerHorizontalGridLineColor?: string;\n\n    /**\n     * The fill color for a selection.\n     */\n    readonly selectionFillColor?: string;\n\n    /**\n     * The border color for a selection.\n     */\n    readonly selectionBorderColor?: string;\n\n    /**\n     * The fill color for the cursor.\n     */\n    readonly cursorFillColor?: string;\n\n    /**\n     * The border color for the cursor.\n     */\n    readonly cursorBorderColor?: string;\n\n    /**\n     * The fill color for a header selection.\n     */\n    readonly headerSelectionFillColor?: string;\n\n    /**\n     * The border color for a header selection.\n     */\n    readonly headerSelectionBorderColor?: string;\n\n    /**\n     * The drop shadow effect when the grid is scrolled.\n     */\n    readonly scrollShadow?: {\n      /**\n       * The size of the shadow, in pixels.\n       */\n      readonly size: number;\n\n      /**\n       * The first color stop for the shadow.\n       */\n      readonly color1: string;\n\n      /**\n       * The second color stop for the shadow.\n       */\n      readonly color2: string;\n\n      /**\n       * The third color stop for the shadow.\n       */\n      readonly color3: string;\n    };\n  };\n\n  /**\n   * An object which defines the default sizes for a data grid.\n   */\n  export type DefaultSizes = {\n    /**\n     * The default height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The default width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The default width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The default height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * An object which defines the minimum sizes for a data grid.\n   */\n  export type MinimumSizes = {\n    /**\n     * The minimum height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The minimum width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The minimum width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The minimum height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * A type alias for the supported header visibility modes.\n   */\n  export type HeaderVisibility = 'all' | 'row' | 'column' | 'none';\n\n  /**\n   * A type alias for the supported column auto resize modes.\n   */\n  export type ColumnFitType = 'all' | 'row-header' | 'body';\n\n  /**\n   * A type alias for the arguments to a copy format function.\n   */\n  export type CopyFormatArgs = {\n    /**\n     * The cell region for the value.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the value.\n     */\n    row: number;\n\n    /**\n     * The column index of the value.\n     */\n    column: number;\n\n    /**\n     * The value for the cell.\n     */\n    value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a copy format function.\n   */\n  export type CopyFormatFunc = (args: CopyFormatArgs) => string;\n\n  /**\n   * A type alias for the data grid copy config.\n   */\n  export type CopyConfig = {\n    /**\n     * The separator to use between values.\n     */\n    readonly separator: string;\n\n    /**\n     * The headers to included in the copied output.\n     */\n    readonly headers: 'none' | 'row' | 'column' | 'all';\n\n    /**\n     * The function for formatting the data values.\n     */\n    readonly format: CopyFormatFunc;\n\n    /**\n     * The cell count threshold for a copy to be considered \"large\".\n     */\n    readonly warningThreshold: number;\n  };\n\n  /**\n   * An options object for initializing a data grid.\n   */\n  export interface IOptions {\n    /**\n     * The style for the data grid.\n     *\n     * The default is `DataGrid.defaultStyle`.\n     */\n    style?: Style;\n\n    /**\n     * The default sizes for the data grid.\n     *\n     * The default is `DataGrid.defaultSizes`.\n     */\n    defaultSizes?: DefaultSizes;\n\n    /**\n     * The minimum sizes for the data grid.\n     *\n     * The default is `DataGrid.minimumSizes`.\n     */\n    minimumSizes?: MinimumSizes;\n\n    /**\n     * The header visibility for the data grid.\n     *\n     * The default is `'all'`.\n     */\n    headerVisibility?: HeaderVisibility;\n\n    /**\n     * The cell renderer map for the data grid.\n     *\n     * The default is an empty renderer map.\n     */\n    cellRenderers?: RendererMap;\n\n    /**\n     * The default cell renderer for the data grid.\n     *\n     * The default is a new `TextRenderer`.\n     */\n    defaultRenderer?: CellRenderer;\n\n    /**\n     * The copy configuration data for the grid.\n     *\n     * The default is `DataGrid.defaultCopyConfig`.\n     */\n    copyConfig?: CopyConfig;\n\n    /**\n     * Whether to stretch the last row of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastRow?: boolean;\n\n    /**\n     * Whether to stretch the last column of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastColumn?: boolean;\n  }\n\n  /**\n   * An object which handles keydown events for the data grid.\n   */\n  export interface IKeyHandler extends IDisposable {\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    onKeyDown(grid: DataGrid, event: KeyboardEvent): void;\n  }\n\n  /**\n   * An object which handles mouse events for the data grid.\n   */\n  export interface IMouseHandler extends IDisposable {\n    /**\n     * Release any resources acquired during a mouse press.\n     *\n     * #### Notes\n     * This method is called when the mouse should be released\n     * independent of a mouseup event, such as an early detach.\n     */\n    release(): void;\n\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseHover(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseLeave(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    onMouseDown(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    onMouseMove(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseUp(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse double click event of interest.\n     */\n    onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    onContextMenu(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    onWheel(grid: DataGrid, event: WheelEvent): void;\n  }\n\n  /**\n   * An object which holds the result of a grid hit test.\n   */\n  export type HitTestResult = {\n    /**\n     * The region of the data grid that was hit.\n     */\n    readonly region: DataModel.CellRegion | 'void';\n\n    /**\n     * The row index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly column: number;\n\n    /**\n     * The X coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly x: number;\n\n    /**\n     * The Y coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly y: number;\n\n    /**\n     * The width of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly width: number;\n\n    /**\n     * The height of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly height: number;\n  };\n\n  /**\n   * A generic format function for the copy handler.\n   *\n   * @param args - The format args for the function.\n   *\n   * @returns The string representation of the value.\n   *\n   * #### Notes\n   * This function uses `String()` to coerce a value to a string.\n   */\n  export function copyFormatGeneric(args: CopyFormatArgs): string {\n    if (args.value === null || args.value === undefined) {\n      return '';\n    }\n    return String(args.value);\n  }\n\n  /**\n   * The default theme for a data grid.\n   */\n  export const defaultStyle: Style = {\n    voidColor: '#F3F3F3',\n    backgroundColor: '#FFFFFF',\n    gridLineColor: 'rgba(20, 20, 20, 0.15)',\n    headerBackgroundColor: '#F3F3F3',\n    headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n    selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n    selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n    headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n    headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    scrollShadow: {\n      size: 10,\n      color1: 'rgba(0, 0, 0, 0.20)',\n      color2: 'rgba(0, 0, 0, 0.05)',\n      color3: 'rgba(0, 0, 0, 0.00)'\n    }\n  };\n\n  /**\n   * The default sizes for a data grid.\n   */\n  export const defaultSizes: DefaultSizes = {\n    rowHeight: 20,\n    columnWidth: 64,\n    rowHeaderWidth: 64,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default minimum sizes for a data grid.\n   */\n  export const minimumSizes: MinimumSizes = {\n    rowHeight: 20,\n    columnWidth: 10,\n    rowHeaderWidth: 10,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default copy config for a data grid.\n   */\n  export const defaultCopyConfig: CopyConfig = {\n    separator: '\\t',\n    format: copyFormatGeneric,\n    headers: 'none',\n    warningThreshold: 1e6\n  };\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A singleton `scroll-request` conflatable message.\n   */\n  export const ScrollRequest = new ConflatableMessage('scroll-request');\n\n  /**\n   * A singleton `overlay-paint-request` conflatable message.\n   */\n  export const OverlayPaintRequest = new ConflatableMessage(\n    'overlay-paint-request'\n  );\n\n  /**\n   * Create a new zero-sized canvas element.\n   */\n  export function createCanvas(): HTMLCanvasElement {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas;\n  }\n\n  /**\n   * Checks whether a given regions has merged cells in it.\n   * @param dataModel grid's data model.\n   * @param region the paint region to be checked.\n   * @returns boolean.\n   */\n  export function regionHasMergedCells(\n    dataModel: DataModel,\n    region: DataModel.CellRegion\n  ): boolean {\n    const regionGroups = CellGroup.getCellGroupsAtRegion(dataModel!, region);\n    return regionGroups.length > 0;\n  }\n\n  /**\n   * An object which represents a canvas region in pixels.\n   */\n  export type PixelRegion = {\n    /**\n     * The min X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMin: number;\n\n    /**\n     * The min Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMin: number;\n\n    /**\n     * The max X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMax: number;\n\n    /**\n     * The max Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMax: number;\n\n    /**\n     * The cell region.\n     */\n    region: DataModel.CellRegion;\n  };\n\n  /**\n   * An object which represents a region to be painted.\n   */\n  export type PaintRegion = PixelRegion & {\n    /**\n     * The X coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    x: number;\n\n    /**\n     * The Y coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    y: number;\n\n    /**\n     * The total width of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    width: number;\n\n    /**\n     * The total height of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    height: number;\n\n    /**\n     * The row index of the first cell in the region.\n     */\n    row: number;\n\n    /**\n     * The column index of the first cell in the region.\n     */\n    column: number;\n\n    /**\n     * The row sizes for the rows in the region.\n     */\n    rowSizes: number[];\n\n    /**\n     * The column sizes for the columns in the region.\n     */\n    columnSizes: number[];\n  };\n\n  /**\n   * A conflatable message which merges dirty paint regions.\n   */\n  export class PaintRequest extends ConflatableMessage {\n    /**\n     * Construct a new paint request messages.\n     *\n     * @param region - The cell region for the paint.\n     *\n     * @param r1 - The top-left row of the dirty region.\n     *\n     * @param c1 - The top-left column of the dirty region.\n     *\n     * @param r2 - The bottom-right row of the dirty region.\n     *\n     * @param c2 - The bottom-right column of the dirty region.\n     */\n    constructor(\n      region: DataModel.CellRegion | 'all',\n      r1: number,\n      c1: number,\n      r2: number,\n      c2: number\n    ) {\n      super('paint-request');\n      this._region = region;\n      this._r1 = r1;\n      this._c1 = c1;\n      this._r2 = r2;\n      this._c2 = c2;\n    }\n\n    /**\n     * The cell region for the paint.\n     */\n    get region(): DataModel.CellRegion | 'all' {\n      return this._region;\n    }\n\n    /**\n     * The top-left row of the dirty region.\n     */\n    get r1(): number {\n      return this._r1;\n    }\n\n    /**\n     * The top-left column of the dirty region.\n     */\n    get c1(): number {\n      return this._c1;\n    }\n\n    /**\n     * The bottom-right row of the dirty region.\n     */\n    get r2(): number {\n      return this._r2;\n    }\n\n    /**\n     * The bottom-right column of the dirty region.\n     */\n    get c2(): number {\n      return this._c2;\n    }\n\n    /**\n     * Conflate this message with another paint request.\n     */\n    conflate(other: PaintRequest): boolean {\n      // Bail early if the request is already painting everything.\n      if (this._region === 'all') {\n        return true;\n      }\n\n      // Any region can conflate with the `'all'` region.\n      if (other._region === 'all') {\n        this._region = 'all';\n        return true;\n      }\n\n      // Otherwise, do not conflate with a different region.\n      if (this._region !== other._region) {\n        return false;\n      }\n\n      // Conflate the region to the total boundary.\n      this._r1 = Math.min(this._r1, other._r1);\n      this._c1 = Math.min(this._c1, other._c1);\n      this._r2 = Math.max(this._r2, other._r2);\n      this._c2 = Math.max(this._c2, other._c2);\n      return true;\n    }\n\n    private _region: DataModel.CellRegion | 'all';\n    private _r1: number;\n    private _c1: number;\n    private _r2: number;\n    private _c2: number;\n  }\n\n  /**\n   * A conflatable message for resizing rows.\n   */\n  export class RowResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new row resize request.\n     *\n     * @param region - The row region which holds the section.\n     *\n     * @param index - The index of row in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.RowRegion, index: number, size: number) {\n      super('row-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The row region which holds the section.\n     */\n    get region(): DataModel.RowRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the row in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another row resize request.\n     */\n    conflate(other: RowResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.RowRegion;\n    private _index: number;\n    private _size: number;\n  }\n\n  /**\n   * A conflatable message for resizing columns.\n   */\n  export class ColumnResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new column resize request.\n     *\n     * @param region - The column region which holds the section.\n     *\n     * @param index - The index of column in the region.\n     *\n     * @param size - The target size of the section.\n     *               If null, then infer the size to fit.\n     */\n    constructor(\n      region: DataModel.ColumnRegion,\n      index: number,\n      size: number | null\n    ) {\n      super('column-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The column region which holds the section.\n     */\n    get region(): DataModel.ColumnRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the column in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number | null {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another column resize request.\n     */\n    conflate(other: ColumnResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.ColumnRegion;\n    private _index: number;\n    private _size: number | null;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ReadonlyJSONObject } from '@lumino/coreutils';\n\nimport { DataModel } from './datamodel';\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nexport class JSONModel extends DataModel {\n  /**\n   * Create a data model with static JSON data.\n   *\n   * @param options - The options for initializing the data model.\n   */\n  constructor(options: JSONModel.IOptions) {\n    super();\n    let split = Private.splitFields(options.schema);\n    this._data = options.data;\n    this._bodyFields = split.bodyFields;\n    this._headerFields = split.headerFields;\n    this._missingValues = Private.createMissingMap(options.schema);\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    if (region === 'body') {\n      return this._data.length;\n    }\n    return 1; // TODO multiple column-header rows?\n  }\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    if (region === 'body') {\n      return this._bodyFields.length;\n    }\n    return this._headerFields.length;\n  }\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns - The data value for the specified cell.\n   *\n   * #### Notes\n   * A `missingValue` as defined by the schema is converted to `null`.\n   */\n  data(region: DataModel.CellRegion, row: number, column: number): any {\n    // Set up the field and value variables.\n    let field: JSONModel.Field;\n    let value: any;\n\n    // Look up the field and value for the region.\n    switch (region) {\n      case 'body':\n        field = this._bodyFields[column];\n        value = this._data[row][field.name];\n        break;\n      case 'column-header':\n        field = this._bodyFields[column];\n        value = field.title || field.name;\n        break;\n      case 'row-header':\n        field = this._headerFields[column];\n        value = this._data[row][field.name];\n        break;\n      case 'corner-header':\n        field = this._headerFields[column];\n        value = field.title || field.name;\n        break;\n      default:\n        throw 'unreachable';\n    }\n\n    // Test whether the value is a missing value.\n    let missing =\n      this._missingValues !== null &&\n      typeof value === 'string' &&\n      this._missingValues[value] === true;\n\n    // Return the final value.\n    return missing ? null : value;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the cell.\n   */\n  metadata(\n    region: DataModel.CellRegion,\n    row: number,\n    column: number\n  ): DataModel.Metadata {\n    if (region === 'body' || region === 'column-header') {\n      return this._bodyFields[column];\n    }\n    return this._headerFields[column];\n  }\n\n  private _data: JSONModel.DataSource;\n  private _bodyFields: JSONModel.Field[];\n  private _headerFields: JSONModel.Field[];\n  private _missingValues: Private.MissingValuesMap | null;\n}\n\n/**\n * The namespace for the `JSONModel` class statics.\n */\nexport namespace JSONModel {\n  /**\n   * An object which describes a column of data in the model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export type Field = {\n    /**\n     * The name of the column.\n     *\n     * This is used as the key to extract a value from a data record.\n     * It is also used as the column header label, unless the `title`\n     * property is provided.\n     */\n    readonly name: string;\n\n    /**\n     * The type of data held in the column.\n     */\n    readonly type?: string;\n\n    /**\n     * The format of the data in the column.\n     */\n    readonly format?: string;\n\n    /**\n     * The human readable name for the column.\n     *\n     * This is used as the label for the column header.\n     */\n    readonly title?: string;\n\n    // TODO want/need support for any these?\n    // description?: string;\n    // constraints?: IConstraints;\n    // rdfType?: string;\n  };\n\n  /**\n   * An object when specifies the schema for a data model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export type Schema = {\n    /**\n     * The fields which describe the data model columns.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly fields: Field[];\n\n    /**\n     * The values to treat as \"missing\" data.\n     *\n     * Missing values are automatically converted to `null`.\n     */\n    readonly missingValues?: string[];\n\n    /**\n     * The field names which act as primary keys.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly primaryKey?: string | string[];\n\n    // TODO want/need support for this?\n    // foreignKeys?: IForeignKey[];\n  };\n\n  /**\n   * A type alias for a data source for a JSON data model.\n   *\n   * A data source is an array of JSON object records which represent\n   * the rows of the table. The keys of the records correspond to the\n   * field names of the columns.\n   */\n  export type DataSource = ReadonlyArray<ReadonlyJSONObject>;\n\n  /**\n   * An options object for initializing a JSON data model.\n   */\n  export interface IOptions {\n    /**\n     * The schema for the for the data model.\n     *\n     * The schema should be treated as an immutable object.\n     */\n    schema: Schema;\n\n    /**\n     * The data source for the data model.\n     *\n     * The data model takes full ownership of the data source.\n     */\n    data: DataSource;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the results of splitting schema fields.\n   */\n  export type SplitFieldsResult = {\n    /**\n     * The non-primary key fields to use for the grid body.\n     */\n    bodyFields: JSONModel.Field[];\n\n    /**\n     * The primary key fields to use for the grid headers.\n     */\n    headerFields: JSONModel.Field[];\n  };\n\n  /**\n   * Split the schema fields into header and body fields.\n   */\n  export function splitFields(schema: JSONModel.Schema): SplitFieldsResult {\n    // Normalize the primary keys.\n    let primaryKeys: string[];\n    if (schema.primaryKey === undefined) {\n      primaryKeys = [];\n    } else if (typeof schema.primaryKey === 'string') {\n      primaryKeys = [schema.primaryKey];\n    } else {\n      primaryKeys = schema.primaryKey;\n    }\n\n    // Separate the fields for the body and header.\n    let bodyFields: JSONModel.Field[] = [];\n    let headerFields: JSONModel.Field[] = [];\n    for (let field of schema.fields) {\n      if (primaryKeys.indexOf(field.name) === -1) {\n        bodyFields.push(field);\n      } else {\n        headerFields.push(field);\n      }\n    }\n\n    // Return the separated fields.\n    return { bodyFields, headerFields };\n  }\n\n  /**\n   * A type alias for a missing value map.\n   */\n  export type MissingValuesMap = { [key: string]: boolean };\n\n  /**\n   * Create a missing values map for a schema.\n   *\n   * This returns `null` if there are no missing values.\n   */\n  export function createMissingMap(\n    schema: JSONModel.Schema\n  ): MissingValuesMap | null {\n    // Bail early if there are no missing values.\n    if (!schema.missingValues || schema.missingValues.length === 0) {\n      return null;\n    }\n\n    // Collect the missing values into a map.\n    let result: MissingValuesMap = Object.create(null);\n    for (let value of schema.missingValues) {\n      result[value] = true;\n    }\n\n    // Return the populated map.\n    return result;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { ISignal, Signal } from '@lumino/signaling';\n\nimport { CellRenderer } from './cellrenderer';\n\nimport { DataModel } from './datamodel';\n\nimport { TextRenderer } from './textrenderer';\n\n/**\n * A class which manages the mapping of cell renderers.\n */\nexport class RendererMap {\n  /**\n   * Construct a new renderer map.\n   *\n   * @param values - The initial values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   */\n  constructor(values: RendererMap.Values = {}, fallback?: CellRenderer) {\n    this._values = { ...values };\n    this._fallback = fallback || new TextRenderer();\n  }\n\n  /**\n   * A signal emitted when the renderer map has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * Get the cell renderer to use for the given cell config.\n   *\n   * @param config - The cell config of interest.\n   *\n   * @returns The renderer to use for the cell.\n   */\n  get(config: CellRenderer.CellConfig): CellRenderer {\n    // Fetch the renderer from the values map.\n    let renderer = this._values[config.region];\n\n    // Execute a resolver function if necessary.\n    if (typeof renderer === 'function') {\n      try {\n        renderer = renderer(config);\n      } catch (err) {\n        renderer = undefined;\n        console.error(err);\n      }\n    }\n\n    // Return the renderer or the fallback.\n    return renderer || this._fallback;\n  }\n\n  /**\n   * Update the renderer map with new values\n   *\n   * @param values - The updated values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   *\n   * #### Notes\n   * This method always emits the `changed` signal.\n   */\n  update(values: RendererMap.Values = {}, fallback?: CellRenderer): void {\n    this._values = { ...this._values, ...values };\n    this._fallback = fallback || this._fallback;\n    this._changed.emit(undefined);\n  }\n\n  private _fallback: CellRenderer;\n  private _values: RendererMap.Values;\n  private _changed = new Signal<this, void>(this);\n}\n\n/**\n * The namespace for the `RendererMap` class statics.\n */\nexport namespace RendererMap {\n  /**\n   * A type alias for a cell renderer resolver function.\n   */\n  export type Resolver = CellRenderer.ConfigFunc<CellRenderer | undefined>;\n\n  /**\n   * A type alias for a `RendererMap` values type.\n   */\n  export type Values = {\n    [R in DataModel.CellRegion]?: Resolver | CellRenderer | undefined;\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2023, Lumino Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { AsyncCellRenderer } from './asynccellrenderer';\nimport { CellRenderer } from './cellrenderer';\n\nimport { GraphicsContext } from './graphicscontext';\n\nconst PERCENTAGE_REGEX = /^(\\d+(\\.\\d+)?)%$/;\nconst PIXEL_REGEX = /^(\\d+(\\.\\d+)?)px$/;\n\n/**\n * A cell renderer which renders data values as images.\n */\nexport class ImageRenderer extends AsyncCellRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: ImageRenderer.IOptions = {}) {\n    super();\n\n    this.backgroundColor = options.backgroundColor || '';\n    this.textColor = options.textColor || '#000000';\n    this.placeholder = options.placeholder || '...';\n\n    this.width = options.width || '';\n    // Not using the || operator, because the empty string '' is a valid value\n    this.height = options.height === undefined ? '100%' : options.height;\n  }\n\n  /**\n   * The CSS color for drawing the placeholder text.\n   */\n  readonly textColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for the cell background.\n   */\n  readonly backgroundColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The placeholder text.\n   */\n  readonly placeholder: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The width of the image.\n   */\n  readonly width: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The height of the image.\n   */\n  readonly height: CellRenderer.ConfigOption<string>;\n\n  /**\n   * Whether the renderer is ready or not for that specific config.\n   * If it's not ready, the datagrid will paint the placeholder.\n   * If it's ready, the datagrid will paint the image synchronously.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * @returns Whether the renderer is ready for this config or not.\n   */\n  isReady(config: CellRenderer.CellConfig): boolean {\n    return (\n      !config.value || ImageRenderer.dataCache.get(config.value) !== undefined\n    );\n  }\n\n  /**\n   * Load the image asynchronously for a specific config.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  async load(config: CellRenderer.CellConfig): Promise<void> {\n    // Bail early if there is nothing to do\n    if (!config.value) {\n      return;\n    }\n\n    const value = config.value;\n    const loadedPromise = new PromiseDelegate<void>();\n\n    ImageRenderer.dataCache.set(value, undefined);\n\n    const img = new Image();\n    img.onload = () => {\n      ImageRenderer.dataCache.set(value, img);\n\n      loadedPromise.resolve();\n    };\n    img.src = value;\n\n    return loadedPromise.promise;\n  }\n\n  /**\n   * Paint the placeholder for a cell, waiting for the renderer to be ready.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paintPlaceholder(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawPlaceholder(gc, config);\n  }\n\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawImage(gc, config);\n  }\n\n  /**\n   * Draw the background for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawBackground(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the background color for the cell.\n    const color = CellRenderer.resolveOption(this.backgroundColor, config);\n\n    // Bail if there is no background color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Fill the cell with the background color.\n    gc.fillStyle = color;\n    gc.fillRect(config.x, config.y, config.width, config.height);\n  }\n\n  /**\n   * Draw the placeholder for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawPlaceholder(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    const placeholder = CellRenderer.resolveOption(this.placeholder, config);\n    const color = CellRenderer.resolveOption(this.textColor, config);\n\n    const textX = config.x + config.width / 2;\n    const textY = config.y + config.height / 2;\n\n    // Draw the placeholder.\n    gc.fillStyle = color;\n    gc.fillText(placeholder, textX, textY);\n  }\n\n  /**\n   * Draw the image for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawImage(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Bail early if there is nothing to draw\n    if (!config.value) {\n      return;\n    }\n\n    const img = ImageRenderer.dataCache.get(config.value);\n\n    // If it's not loaded yet, show the placeholder\n    if (!img) {\n      return this.drawPlaceholder(gc, config);\n    }\n\n    const width = CellRenderer.resolveOption(this.width, config);\n    const height = CellRenderer.resolveOption(this.height, config);\n\n    // width and height are unset, we display the image with its original size\n    if (!width && !height) {\n      gc.drawImage(img, config.x, config.y);\n      return;\n    }\n\n    let requestedWidth = img.width;\n    let requestedHeight = img.height;\n\n    let widthPercentageMatch: RegExpMatchArray | null;\n    let widthPixelMatch: RegExpMatchArray | null;\n    let heightPercentageMatch: RegExpMatchArray | null;\n    let heightPixelMatch: RegExpMatchArray | null;\n\n    if ((widthPercentageMatch = width.match(PERCENTAGE_REGEX))) {\n      requestedWidth =\n        (parseFloat(widthPercentageMatch[1]) / 100) * config.width;\n    } else if ((widthPixelMatch = width.match(PIXEL_REGEX))) {\n      requestedWidth = parseFloat(widthPixelMatch[1]);\n    }\n\n    if ((heightPercentageMatch = height.match(PERCENTAGE_REGEX))) {\n      requestedHeight =\n        (parseFloat(heightPercentageMatch[1]) / 100) * config.height;\n    } else if ((heightPixelMatch = height.match(PIXEL_REGEX))) {\n      requestedHeight = parseFloat(heightPixelMatch[1]);\n    }\n\n    // If width is not set, we compute it respecting the image size ratio\n    if (!width) {\n      requestedWidth = (img.width / img.height) * requestedHeight;\n    }\n\n    // If height is not set, we compute it respecting the image size ratio\n    if (!height) {\n      requestedHeight = (img.height / img.width) * requestedWidth;\n    }\n\n    gc.drawImage(img, config.x, config.y, requestedWidth, requestedHeight);\n  }\n\n  private static dataCache = new Map<string, HTMLImageElement | undefined>();\n}\n\n/**\n * The namespace for the `ImageRenderer` class statics.\n */\nexport namespace ImageRenderer {\n  /**\n   * An options object for initializing an image renderer.\n   */\n  export interface IOptions {\n    /**\n     * The background color for the cells.\n     *\n     * The default is `''`.\n     */\n    backgroundColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The placeholder text while the cell is loading.\n     *\n     * The default is `'...'`.\n     */\n    placeholder?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The color for the drawing the placeholder text.\n     *\n     * The default is `'#000000'`.\n     */\n    textColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The width of the image. Can be a percentage of the available space (e.g. '50%'), a\n     * number of pixels (e.g. '123px') or an empty string.\n     * If it's an empty string, it will respect the image size ratio depending on the height value\n     * Examples:\n     * - if height='100%' and width='', it will take the available height in the cell and compute the width so\n     * that the image is not malformed.\n     * - if height='' and width='50%', it will take half of the available width in the cell and compute the height so\n     * that the image is not malformed.\n     * - if height='' and width='', the image will keep its original size.\n     *\n     * The default is `''`.\n     */\n    width?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The height of the image. Can be a percentage of the available space (e.g. '50%'), a\n     * number of pixels (e.g. '123px') or an empty string.\n     * If it's an empty string, it will respect the image size ratio depending on the width value\n     * Examples:\n     * - if height='100%' and width='', it will take the available height in the cell and compute the width so\n     * that the image is not malformed.\n     * - if height='' and width='50%', it will take half of the available width in the cell and compute the height so\n     * that the image is not malformed.\n     * - if height='' and width='', the image will keep its original size.\n     *\n     * The default is `'100%'`.\n     */\n    height?: CellRenderer.ConfigOption<string>;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Platform } from '@lumino/domutils';\n\nimport { getKeyboardLayout } from '@lumino/keyboard';\n\nimport { DataGrid } from './datagrid';\n\nimport { SelectionModel } from './selectionmodel';\n\nimport { CellEditor } from './celleditor';\n\nimport { MutableDataModel } from './datamodel';\n\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport class BasicKeyHandler implements DataGrid.IKeyHandler {\n  /**\n   * Whether the key handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by the key handler.\n   */\n  dispose(): void {\n    this._disposed = true;\n  }\n\n  /**\n   * Handle the key down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keydown event of interest.\n   *\n   * #### Notes\n   * This will not be called if the mouse button is pressed.\n   */\n  onKeyDown(grid: DataGrid, event: KeyboardEvent): void {\n    // if grid is editable and cell selection available, start cell editing\n    // on key press (letters, numbers and space only)\n    if (\n      grid.editable &&\n      grid.selectionModel!.cursorRow !== -1 &&\n      grid.selectionModel!.cursorColumn !== -1\n    ) {\n      const input = String.fromCharCode(event.keyCode);\n      if (/[a-zA-Z0-9-_ ]/.test(input)) {\n        const row = grid.selectionModel!.cursorRow;\n        const column = grid.selectionModel!.cursorColumn;\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n        if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        return;\n      }\n    }\n\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'ArrowLeft':\n        this.onArrowLeft(grid, event);\n        break;\n      case 'ArrowRight':\n        this.onArrowRight(grid, event);\n        break;\n      case 'ArrowUp':\n        this.onArrowUp(grid, event);\n        break;\n      case 'ArrowDown':\n        this.onArrowDown(grid, event);\n        break;\n      case 'PageUp':\n        this.onPageUp(grid, event);\n        break;\n      case 'PageDown':\n        this.onPageDown(grid, event);\n        break;\n      case 'Escape':\n        this.onEscape(grid, event);\n        break;\n      case 'Delete':\n        this.onDelete(grid, event);\n        break;\n      case 'C':\n        this.onKeyC(grid, event);\n        break;\n      case 'Enter':\n        if (grid.selectionModel) {\n          grid.moveCursor(event.shiftKey ? 'up' : 'down');\n          grid.scrollToCursor();\n        }\n        break;\n      case 'Tab':\n        if (grid.selectionModel) {\n          grid.moveCursor(event.shiftKey ? 'left' : 'right');\n          grid.scrollToCursor();\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        break;\n    }\n  }\n\n  /**\n   * Handle the `'ArrowLeft'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowLeft(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection mode with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 - 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = 0;\n      c2 = 0;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c - 1;\n      c2 = c - 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowRight'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowRight(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection model with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = Infinity;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 + 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = Infinity;\n      c2 = Infinity;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c + 1;\n      c2 = c + 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = 0;\n      r2 = 0;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r - 1;\n      r2 = r - 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = Infinity;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = Infinity;\n      r2 = Infinity;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r + 1;\n      r2 = r + 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'PageUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('up');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 - n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'PageDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('down');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 + n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'Escape'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onEscape(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.selectionModel) {\n      grid.selectionModel.clear();\n    }\n  }\n\n  /**\n   * Handle the `'Delete'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onDelete(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.editable && !grid.selectionModel!.isEmpty) {\n      const dataModel = grid.dataModel as MutableDataModel;\n      // Fetch the max row and column.\n      let maxRow = dataModel.rowCount('body') - 1;\n      let maxColumn = dataModel.columnCount('body') - 1;\n\n      for (let s of grid.selectionModel!.selections()) {\n        // Clamp the cell to the model bounds.\n        let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n        let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n        let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n        let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n        for (let r = sr1; r <= sr2; ++r) {\n          for (let c = sc1; c <= sc2; ++c) {\n            dataModel.setData('body', r, c, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle the `'C'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onKeyC(grid: DataGrid, event: KeyboardEvent): void {\n    // Bail early if the modifiers aren't correct for copy.\n    if (event.shiftKey || !Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Copy the current selection to the clipboard.\n    grid.copyToClipboard();\n  }\n\n  private _disposed = false;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { DataModel } from './datamodel';\n\nimport { SelectionModel } from './selectionmodel';\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nexport class BasicSelectionModel extends SelectionModel {\n  /**\n   * Whether the selection model is empty.\n   */\n  get isEmpty(): boolean {\n    return this._selections.length === 0;\n  }\n\n  /**\n   * The row index of the cursor.\n   */\n  get cursorRow(): number {\n    return this._cursorRow;\n  }\n\n  /**\n   * The column index of the cursor.\n   */\n  get cursorColumn(): number {\n    return this._cursorColumn;\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  moveCursorWithinSelections(\n    direction: SelectionModel.CursorMoveDirection\n  ): void {\n    // Bail early if there are no selections or no existing cursor\n    if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n      return;\n    }\n\n    // Bail early if only single cell is selected\n    const firstSelection = this._selections[0];\n    if (\n      this._selections.length === 1 &&\n      firstSelection.r1 === firstSelection.r2 &&\n      firstSelection.c1 === firstSelection.c2\n    ) {\n      return;\n    }\n\n    // start from last selection rectangle\n    if (this._cursorRectIndex === -1) {\n      this._cursorRectIndex = this._selections.length - 1;\n    }\n\n    let cursorRect = this._selections[this._cursorRectIndex];\n    const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n    const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n    let newRow = this._cursorRow + dr;\n    let newColumn = this._cursorColumn + dc;\n    const r1 = Math.min(cursorRect.r1, cursorRect.r2);\n    const r2 = Math.max(cursorRect.r1, cursorRect.r2);\n    const c1 = Math.min(cursorRect.c1, cursorRect.c2);\n    const c2 = Math.max(cursorRect.c1, cursorRect.c2);\n\n    const moveToNextRect = () => {\n      this._cursorRectIndex =\n        (this._cursorRectIndex + 1) % this._selections.length;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.min(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n    };\n\n    const moveToPreviousRect = () => {\n      this._cursorRectIndex =\n        this._cursorRectIndex === 0\n          ? this._selections.length - 1\n          : this._cursorRectIndex - 1;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.max(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n    };\n\n    if (newRow > r2) {\n      newRow = r1;\n      newColumn += 1;\n      if (newColumn > c2) {\n        moveToNextRect();\n      }\n    } else if (newRow < r1) {\n      newRow = r2;\n      newColumn -= 1;\n      if (newColumn < c1) {\n        moveToPreviousRect();\n      }\n    } else if (newColumn > c2) {\n      newColumn = c1;\n      newRow += 1;\n      if (newRow > r2) {\n        moveToNextRect();\n      }\n    } else if (newColumn < c1) {\n      newColumn = c2;\n      newRow -= 1;\n      if (newRow < r1) {\n        moveToPreviousRect();\n      }\n    }\n\n    this._cursorRow = newRow;\n    this._cursorColumn = newColumn;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  currentSelection(): SelectionModel.Selection | null {\n    return this._selections[this._selections.length - 1] || null;\n  }\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the current selections.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  *selections(): IterableIterator<SelectionModel.Selection> {\n    yield* this._selections;\n  }\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  select(args: SelectionModel.SelectArgs): void {\n    // Fetch the current row and column counts;\n    let rowCount = this.dataModel.rowCount('body');\n    let columnCount = this.dataModel.columnCount('body');\n\n    // Bail early if there is no content.\n    if (rowCount <= 0 || columnCount <= 0) {\n      return;\n    }\n\n    // Unpack the arguments.\n    let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;\n\n    // Clear the necessary selections.\n    if (clear === 'all') {\n      this._selections.length = 0;\n    } else if (clear === 'current') {\n      this._selections.pop();\n    }\n\n    // Clamp to the data model bounds.\n    r1 = Math.max(0, Math.min(r1, rowCount - 1));\n    r2 = Math.max(0, Math.min(r2, rowCount - 1));\n    c1 = Math.max(0, Math.min(c1, columnCount - 1));\n    c2 = Math.max(0, Math.min(c2, columnCount - 1));\n\n    // Indicate if a row/column has already been selected.\n    let alreadySelected = false;\n\n    // Handle the selection mode.\n    if (this.selectionMode === 'row') {\n      c1 = 0;\n      c2 = columnCount - 1;\n      alreadySelected =\n        this._selections.filter(selection => selection.r1 === r1).length !== 0;\n      // Remove from selections if already selected.\n      this._selections = alreadySelected\n        ? this._selections.filter(selection => selection.r1 !== r1)\n        : this._selections;\n    } else if (this.selectionMode === 'column') {\n      r1 = 0;\n      r2 = rowCount - 1;\n      alreadySelected =\n        this._selections.filter(selection => selection.c1 === c1).length !== 0;\n      // Remove from selections if already selected.\n      this._selections = alreadySelected\n        ? this._selections.filter(selection => selection.c1 !== c1)\n        : this._selections;\n    }\n\n    // Alias the cursor row and column.\n    let cr = cursorRow;\n    let cc = cursorColumn;\n\n    // Compute the new cursor location.\n    if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n      cr = r1;\n    }\n    if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n      cc = c1;\n    }\n\n    // Update the cursor.\n    this._cursorRow = cr;\n    this._cursorColumn = cc;\n    this._cursorRectIndex = this._selections.length;\n\n    // Add the new selection if it wasn't already selected.\n    if (!alreadySelected) {\n      this._selections.push({ r1, c1, r2, c2 });\n    }\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  clear(): void {\n    // Bail early if there are no selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Reset the internal state.\n    this._cursorRow = -1;\n    this._cursorColumn = -1;\n    this._cursorRectIndex = -1;\n    this._selections.length = 0;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   */\n  protected onDataModelChanged(\n    sender: DataModel,\n    args: DataModel.ChangedArgs\n  ): void {\n    // Bail early if the model has no current selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Bail early if the cells have changed in place.\n    if (args.type === 'cells-changed') {\n      return;\n    }\n\n    // Bail early if there is no change to the row or column count.\n    if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n      return;\n    }\n\n    // Fetch the last row and column index.\n    let lr = sender.rowCount('body') - 1;\n    let lc = sender.columnCount('body') - 1;\n\n    // Bail early if the data model is empty.\n    if (lr < 0 || lc < 0) {\n      this._selections.length = 0;\n      this.emitChanged();\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = this.selectionMode;\n\n    // Set up the assignment index variable.\n    let j = 0;\n\n    // Iterate over the current selections.\n    for (let i = 0, n = this._selections.length; i < n; ++i) {\n      // Unpack the selection.\n      let { r1, c1, r2, c2 } = this._selections[i];\n\n      // Skip the selection if it will disappear.\n      if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n        continue;\n      }\n\n      // Modify the bounds based on the selection mode.\n      if (mode === 'row') {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = 0;\n        c2 = lc;\n      } else if (mode === 'column') {\n        r1 = 0;\n        r2 = lr;\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      } else {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      }\n\n      // Assign the modified selection to the array.\n      this._selections[j++] = { r1, c1, r2, c2 };\n    }\n\n    // Remove the stale selections.\n    this._selections.length = j;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  private _cursorRow = -1;\n  private _cursorColumn = -1;\n  private _cursorRectIndex = -1;\n  private _selections: SelectionModel.Selection[] = [];\n}\n"],"mappings":"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"}