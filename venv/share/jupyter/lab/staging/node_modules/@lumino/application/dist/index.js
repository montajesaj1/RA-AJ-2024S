(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@lumino/commands'), require('@lumino/coreutils'), require('@lumino/widgets')) :
    typeof define === 'function' && define.amd ? define(['exports', '@lumino/commands', '@lumino/coreutils', '@lumino/widgets'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.lumino_application = {}, global.lumino_commands, global.lumino_coreutils, global.lumino_widgets));
})(this, (function (exports, commands, coreutils, widgets) { 'use strict';

    // Copyright (c) Jupyter Development Team.
    // Distributed under the terms of the Modified BSD License.
    /*-----------------------------------------------------------------------------
    | Copyright (c) 2014-2017, PhosphorJS Contributors
    |
    | Distributed under the terms of the BSD 3-Clause License.
    |
    | The full license is in the file LICENSE, distributed with this software.
    |----------------------------------------------------------------------------*/
    /**
     * The namespace for array-specific algorithms.
     */
    var ArrayExt;
    (function (ArrayExt) {
        /**
         * Find the index of the first occurrence of a value in an array.
         *
         * @param array - The array-like object to search.
         *
         * @param value - The value to locate in the array. Values are
         *   compared using strict `===` equality.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the first occurrence of the value, or `-1`
         *   if the value is not found.
         *
         * #### Notes
         * If `stop < start` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = ['one', 'two', 'three', 'four', 'one'];
         * ArrayExt.firstIndexOf(data, 'red');        // -1
         * ArrayExt.firstIndexOf(data, 'one');        // 0
         * ArrayExt.firstIndexOf(data, 'one', 1);     // 4
         * ArrayExt.firstIndexOf(data, 'two', 2);     // -1
         * ArrayExt.firstIndexOf(data, 'two', 2, 1);  // 1
         * ```
         */
        function firstIndexOf(array, value, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return -1;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let span;
            if (stop < start) {
                span = stop + 1 + (n - start);
            }
            else {
                span = stop - start + 1;
            }
            for (let i = 0; i < span; ++i) {
                let j = (start + i) % n;
                if (array[j] === value) {
                    return j;
                }
            }
            return -1;
        }
        ArrayExt.firstIndexOf = firstIndexOf;
        /**
         * Find the index of the last occurrence of a value in an array.
         *
         * @param array - The array-like object to search.
         *
         * @param value - The value to locate in the array. Values are
         *   compared using strict `===` equality.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the last occurrence of the value, or `-1`
         *   if the value is not found.
         *
         * #### Notes
         * If `start < stop` the search will wrap at the front of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = ['one', 'two', 'three', 'four', 'one'];
         * ArrayExt.lastIndexOf(data, 'red');        // -1
         * ArrayExt.lastIndexOf(data, 'one');        // 4
         * ArrayExt.lastIndexOf(data, 'one', 1);     // 0
         * ArrayExt.lastIndexOf(data, 'two', 0);     // -1
         * ArrayExt.lastIndexOf(data, 'two', 0, 1);  // 1
         * ```
         */
        function lastIndexOf(array, value, start = -1, stop = 0) {
            let n = array.length;
            if (n === 0) {
                return -1;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let span;
            if (start < stop) {
                span = start + 1 + (n - stop);
            }
            else {
                span = start - stop + 1;
            }
            for (let i = 0; i < span; ++i) {
                let j = (start - i + n) % n;
                if (array[j] === value) {
                    return j;
                }
            }
            return -1;
        }
        ArrayExt.lastIndexOf = lastIndexOf;
        /**
         * Find the index of the first value which matches a predicate.
         *
         * @param array - The array-like object to search.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the first matching value, or `-1` if no
         *   matching value is found.
         *
         * #### Notes
         * If `stop < start` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [1, 2, 3, 4, 3, 2, 1];
         * ArrayExt.findFirstIndex(data, isEven);       // 1
         * ArrayExt.findFirstIndex(data, isEven, 4);    // 5
         * ArrayExt.findFirstIndex(data, isEven, 6);    // -1
         * ArrayExt.findFirstIndex(data, isEven, 6, 5); // 1
         * ```
         */
        function findFirstIndex(array, fn, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return -1;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let span;
            if (stop < start) {
                span = stop + 1 + (n - start);
            }
            else {
                span = stop - start + 1;
            }
            for (let i = 0; i < span; ++i) {
                let j = (start + i) % n;
                if (fn(array[j], j)) {
                    return j;
                }
            }
            return -1;
        }
        ArrayExt.findFirstIndex = findFirstIndex;
        /**
         * Find the index of the last value which matches a predicate.
         *
         * @param object - The array-like object to search.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the last matching value, or `-1` if no
         *   matching value is found.
         *
         * #### Notes
         * If `start < stop` the search will wrap at the front of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [1, 2, 3, 4, 3, 2, 1];
         * ArrayExt.findLastIndex(data, isEven);        // 5
         * ArrayExt.findLastIndex(data, isEven, 4);     // 3
         * ArrayExt.findLastIndex(data, isEven, 0);     // -1
         * ArrayExt.findLastIndex(data, isEven, 0, 1);  // 5
         * ```
         */
        function findLastIndex(array, fn, start = -1, stop = 0) {
            let n = array.length;
            if (n === 0) {
                return -1;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let d;
            if (start < stop) {
                d = start + 1 + (n - stop);
            }
            else {
                d = start - stop + 1;
            }
            for (let i = 0; i < d; ++i) {
                let j = (start - i + n) % n;
                if (fn(array[j], j)) {
                    return j;
                }
            }
            return -1;
        }
        ArrayExt.findLastIndex = findLastIndex;
        /**
         * Find the first value which matches a predicate.
         *
         * @param array - The array-like object to search.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The first matching value, or `undefined` if no matching
         *   value is found.
         *
         * #### Notes
         * If `stop < start` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [1, 2, 3, 4, 3, 2, 1];
         * ArrayExt.findFirstValue(data, isEven);       // 2
         * ArrayExt.findFirstValue(data, isEven, 2);    // 4
         * ArrayExt.findFirstValue(data, isEven, 6);    // undefined
         * ArrayExt.findFirstValue(data, isEven, 6, 5); // 2
         * ```
         */
        function findFirstValue(array, fn, start = 0, stop = -1) {
            let index = findFirstIndex(array, fn, start, stop);
            return index !== -1 ? array[index] : undefined;
        }
        ArrayExt.findFirstValue = findFirstValue;
        /**
         * Find the last value which matches a predicate.
         *
         * @param object - The array-like object to search.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The last matching value, or `undefined` if no matching
         *   value is found.
         *
         * #### Notes
         * If `start < stop` the search will wrap at the front of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [1, 2, 3, 4, 3, 2, 1];
         * ArrayExt.findLastValue(data, isEven);        // 2
         * ArrayExt.findLastValue(data, isEven, 4);     // 4
         * ArrayExt.findLastValue(data, isEven, 0);     // undefined
         * ArrayExt.findLastValue(data, isEven, 0, 1);  // 2
         * ```
         */
        function findLastValue(array, fn, start = -1, stop = 0) {
            let index = findLastIndex(array, fn, start, stop);
            return index !== -1 ? array[index] : undefined;
        }
        ArrayExt.findLastValue = findLastValue;
        /**
         * Find the index of the first element which compares `>=` to a value.
         *
         * @param array - The sorted array-like object to search.
         *
         * @param value - The value to locate in the array.
         *
         * @param fn - The 3-way comparison function to apply to the values.
         *   It should return `< 0` if an element is less than a value, `0` if
         *   an element is equal to a value, or `> 0` if an element is greater
         *   than a value.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the first element which compares `>=` to the
         *   value, or `length` if there is no such element. If the computed
         *   index for `stop` is less than `start`, then the computed index
         *   for `start` is returned.
         *
         * #### Notes
         * The array must already be sorted in ascending order according to
         * the comparison function.
         *
         * #### Complexity
         * Logarithmic.
         *
         * #### Undefined Behavior
         * Searching a range which is not sorted in ascending order.
         *
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function numberCmp(a: number, b: number): number {
         *   return a - b;
         * }
         *
         * let data = [0, 3, 4, 7, 7, 9];
         * ArrayExt.lowerBound(data, 0, numberCmp);   // 0
         * ArrayExt.lowerBound(data, 6, numberCmp);   // 3
         * ArrayExt.lowerBound(data, 7, numberCmp);   // 3
         * ArrayExt.lowerBound(data, -1, numberCmp);  // 0
         * ArrayExt.lowerBound(data, 10, numberCmp);  // 6
         * ```
         */
        function lowerBound(array, value, fn, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return 0;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let begin = start;
            let span = stop - start + 1;
            while (span > 0) {
                let half = span >> 1;
                let middle = begin + half;
                if (fn(array[middle], value) < 0) {
                    begin = middle + 1;
                    span -= half + 1;
                }
                else {
                    span = half;
                }
            }
            return begin;
        }
        ArrayExt.lowerBound = lowerBound;
        /**
         * Find the index of the first element which compares `>` than a value.
         *
         * @param array - The sorted array-like object to search.
         *
         * @param value - The value to locate in the array.
         *
         * @param fn - The 3-way comparison function to apply to the values.
         *   It should return `< 0` if an element is less than a value, `0` if
         *   an element is equal to a value, or `> 0` if an element is greater
         *   than a value.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the first element which compares `>` than the
         *   value, or `length` if there is no such element. If the computed
         *   index for `stop` is less than `start`, then the computed index
         *   for `start` is returned.
         *
         * #### Notes
         * The array must already be sorted in ascending order according to
         * the comparison function.
         *
         * #### Complexity
         * Logarithmic.
         *
         * #### Undefined Behavior
         * Searching a range which is not sorted in ascending order.
         *
         * A `start` or `stop` which is non-integral.
         *
         * Modifying the length of the array while searching.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function numberCmp(a: number, b: number): number {
         *   return a - b;
         * }
         *
         * let data = [0, 3, 4, 7, 7, 9];
         * ArrayExt.upperBound(data, 0, numberCmp);   // 1
         * ArrayExt.upperBound(data, 6, numberCmp);   // 3
         * ArrayExt.upperBound(data, 7, numberCmp);   // 5
         * ArrayExt.upperBound(data, -1, numberCmp);  // 0
         * ArrayExt.upperBound(data, 10, numberCmp);  // 6
         * ```
         */
        function upperBound(array, value, fn, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return 0;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let begin = start;
            let span = stop - start + 1;
            while (span > 0) {
                let half = span >> 1;
                let middle = begin + half;
                if (fn(array[middle], value) > 0) {
                    span = half;
                }
                else {
                    begin = middle + 1;
                    span -= half + 1;
                }
            }
            return begin;
        }
        ArrayExt.upperBound = upperBound;
        /**
         * Test whether two arrays are shallowly equal.
         *
         * @param a - The first array-like object to compare.
         *
         * @param b - The second array-like object to compare.
         *
         * @param fn - The comparison function to apply to the elements. It
         *   should return `true` if the elements are "equal". The default
         *   compares elements using strict `===` equality.
         *
         * @returns Whether the two arrays are shallowly equal.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * Modifying the length of the arrays while comparing.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let d1 = [0, 3, 4, 7, 7, 9];
         * let d2 = [0, 3, 4, 7, 7, 9];
         * let d3 = [42];
         * ArrayExt.shallowEqual(d1, d2);  // true
         * ArrayExt.shallowEqual(d2, d3);  // false
         * ```
         */
        function shallowEqual(a, b, fn) {
            // Check for object identity first.
            if (a === b) {
                return true;
            }
            // Bail early if the lengths are different.
            if (a.length !== b.length) {
                return false;
            }
            // Compare each element for equality.
            for (let i = 0, n = a.length; i < n; ++i) {
                if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
                    return false;
                }
            }
            // The array are shallowly equal.
            return true;
        }
        ArrayExt.shallowEqual = shallowEqual;
        /**
         * Create a slice of an array subject to an optional step.
         *
         * @param array - The array-like object of interest.
         *
         * @param options - The options for configuring the slice.
         *
         * @returns A new array with the specified values.
         *
         * @throws An exception if the slice `step` is `0`.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start`, `stop`, or `step` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 3, 4, 7, 7, 9];
         * ArrayExt.slice(data);                         // [0, 3, 4, 7, 7, 9]
         * ArrayExt.slice(data, { start: 2 });           // [4, 7, 7, 9]
         * ArrayExt.slice(data, { start: 0, stop: 4 });  // [0, 3, 4, 7]
         * ArrayExt.slice(data, { step: 2 });            // [0, 4, 7]
         * ArrayExt.slice(data, { step: -1 });           // [9, 7, 7, 4, 3, 0]
         * ```
         */
        function slice(array, options = {}) {
            // Extract the options.
            let { start, stop, step } = options;
            // Set up the `step` value.
            if (step === undefined) {
                step = 1;
            }
            // Validate the step size.
            if (step === 0) {
                throw new Error('Slice `step` cannot be zero.');
            }
            // Look up the length of the array.
            let n = array.length;
            // Set up the `start` value.
            if (start === undefined) {
                start = step < 0 ? n - 1 : 0;
            }
            else if (start < 0) {
                start = Math.max(start + n, step < 0 ? -1 : 0);
            }
            else if (start >= n) {
                start = step < 0 ? n - 1 : n;
            }
            // Set up the `stop` value.
            if (stop === undefined) {
                stop = step < 0 ? -1 : n;
            }
            else if (stop < 0) {
                stop = Math.max(stop + n, step < 0 ? -1 : 0);
            }
            else if (stop >= n) {
                stop = step < 0 ? n - 1 : n;
            }
            // Compute the slice length.
            let length;
            if ((step < 0 && stop >= start) || (step > 0 && start >= stop)) {
                length = 0;
            }
            else if (step < 0) {
                length = Math.floor((stop - start + 1) / step + 1);
            }
            else {
                length = Math.floor((stop - start - 1) / step + 1);
            }
            // Compute the sliced result.
            let result = [];
            for (let i = 0; i < length; ++i) {
                result[i] = array[start + i * step];
            }
            // Return the result.
            return result;
        }
        ArrayExt.slice = slice;
        /**
         * Move an element in an array from one index to another.
         *
         * @param array - The mutable array-like object of interest.
         *
         * @param fromIndex - The index of the element to move. Negative
         *   values are taken as an offset from the end of the array.
         *
         * @param toIndex - The target index of the element. Negative
         *   values are taken as an offset from the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `fromIndex` or `toIndex` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from from '@lumino/algorithm';
         *
         * let data = [0, 1, 2, 3, 4];
         * ArrayExt.move(data, 1, 2);  // [0, 2, 1, 3, 4]
         * ArrayExt.move(data, 4, 2);  // [0, 2, 4, 1, 3]
         * ```
         */
        function move(array, fromIndex, toIndex) {
            let n = array.length;
            if (n <= 1) {
                return;
            }
            if (fromIndex < 0) {
                fromIndex = Math.max(0, fromIndex + n);
            }
            else {
                fromIndex = Math.min(fromIndex, n - 1);
            }
            if (toIndex < 0) {
                toIndex = Math.max(0, toIndex + n);
            }
            else {
                toIndex = Math.min(toIndex, n - 1);
            }
            if (fromIndex === toIndex) {
                return;
            }
            let value = array[fromIndex];
            let d = fromIndex < toIndex ? 1 : -1;
            for (let i = fromIndex; i !== toIndex; i += d) {
                array[i] = array[i + d];
            }
            array[toIndex] = value;
        }
        ArrayExt.move = move;
        /**
         * Reverse an array in-place.
         *
         * @param array - The mutable array-like object of interest.
         *
         * @param start - The index of the first element in the range to be
         *   reversed, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   reversed, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or  `stop` index which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 1, 2, 3, 4];
         * ArrayExt.reverse(data, 1, 3);  // [0, 3, 2, 1, 4]
         * ArrayExt.reverse(data, 3);     // [0, 3, 2, 4, 1]
         * ArrayExt.reverse(data);        // [1, 4, 2, 3, 0]
         * ```
         */
        function reverse(array, start = 0, stop = -1) {
            let n = array.length;
            if (n <= 1) {
                return;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            while (start < stop) {
                let a = array[start];
                let b = array[stop];
                array[start++] = b;
                array[stop--] = a;
            }
        }
        ArrayExt.reverse = reverse;
        /**
         * Rotate the elements of an array in-place.
         *
         * @param array - The mutable array-like object of interest.
         *
         * @param delta - The amount of rotation to apply to the elements. A
         *   positive value will rotate the elements to the left. A negative
         *   value will rotate the elements to the right.
         *
         * @param start - The index of the first element in the range to be
         *   rotated, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   rotated, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `delta`, `start`, or `stop` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 1, 2, 3, 4];
         * ArrayExt.rotate(data, 2);        // [2, 3, 4, 0, 1]
         * ArrayExt.rotate(data, -2);       // [0, 1, 2, 3, 4]
         * ArrayExt.rotate(data, 10);       // [0, 1, 2, 3, 4]
         * ArrayExt.rotate(data, 9);        // [4, 0, 1, 2, 3]
         * ArrayExt.rotate(data, 2, 1, 3);  // [4, 2, 0, 1, 3]
         * ```
         */
        function rotate(array, delta, start = 0, stop = -1) {
            let n = array.length;
            if (n <= 1) {
                return;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            if (start >= stop) {
                return;
            }
            let length = stop - start + 1;
            if (delta > 0) {
                delta = delta % length;
            }
            else if (delta < 0) {
                delta = ((delta % length) + length) % length;
            }
            if (delta === 0) {
                return;
            }
            let pivot = start + delta;
            reverse(array, start, pivot - 1);
            reverse(array, pivot, stop);
            reverse(array, start, stop);
        }
        ArrayExt.rotate = rotate;
        /**
         * Fill an array with a static value.
         *
         * @param array - The mutable array-like object to fill.
         *
         * @param value - The static value to use to fill the array.
         *
         * @param start - The index of the first element in the range to be
         *   filled, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   filled, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * #### Notes
         * If `stop < start` the fill will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * A `start` or `stop` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = ['one', 'two', 'three', 'four'];
         * ArrayExt.fill(data, 'r');        // ['r', 'r', 'r', 'r']
         * ArrayExt.fill(data, 'g', 1);     // ['r', 'g', 'g', 'g']
         * ArrayExt.fill(data, 'b', 2, 3);  // ['r', 'g', 'b', 'b']
         * ArrayExt.fill(data, 'z', 3, 1);  // ['z', 'z', 'b', 'z']
         * ```
         */
        function fill(array, value, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let span;
            if (stop < start) {
                span = stop + 1 + (n - start);
            }
            else {
                span = stop - start + 1;
            }
            for (let i = 0; i < span; ++i) {
                array[(start + i) % n] = value;
            }
        }
        ArrayExt.fill = fill;
        /**
         * Insert a value into an array at a specific index.
         *
         * @param array - The array of interest.
         *
         * @param index - The index at which to insert the value. Negative
         *   values are taken as an offset from the end of the array.
         *
         * @param value - The value to set at the specified index.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * An `index` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 1, 2];
         * ArrayExt.insert(data, 0, -1);  // [-1, 0, 1, 2]
         * ArrayExt.insert(data, 2, 12);  // [-1, 0, 12, 1, 2]
         * ArrayExt.insert(data, -1, 7);  // [-1, 0, 12, 1, 7, 2]
         * ArrayExt.insert(data, 6, 19);  // [-1, 0, 12, 1, 7, 2, 19]
         * ```
         */
        function insert(array, index, value) {
            let n = array.length;
            if (index < 0) {
                index = Math.max(0, index + n);
            }
            else {
                index = Math.min(index, n);
            }
            for (let i = n; i > index; --i) {
                array[i] = array[i - 1];
            }
            array[index] = value;
        }
        ArrayExt.insert = insert;
        /**
         * Remove and return a value at a specific index in an array.
         *
         * @param array - The array of interest.
         *
         * @param index - The index of the value to remove. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The value at the specified index, or `undefined` if the
         *   index is out of range.
         *
         * #### Complexity
         * Linear.
         *
         * #### Undefined Behavior
         * An `index` which is non-integral.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 12, 23, 39, 14, 12, 75];
         * ArrayExt.removeAt(data, 2);   // 23
         * ArrayExt.removeAt(data, -2);  // 12
         * ArrayExt.removeAt(data, 10);  // undefined;
         * ```
         */
        function removeAt(array, index) {
            let n = array.length;
            if (index < 0) {
                index += n;
            }
            if (index < 0 || index >= n) {
                return undefined;
            }
            let value = array[index];
            for (let i = index + 1; i < n; ++i) {
                array[i - 1] = array[i];
            }
            array.length = n - 1;
            return value;
        }
        ArrayExt.removeAt = removeAt;
        /**
         * Remove the first occurrence of a value from an array.
         *
         * @param array - The array of interest.
         *
         * @param value - The value to remove from the array. Values are
         *   compared using strict `===` equality.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the removed value, or `-1` if the value
         *   is not contained in the array.
         *
         * #### Notes
         * If `stop < start` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 12, 23, 39, 14, 12, 75];
         * ArrayExt.removeFirstOf(data, 12);        // 1
         * ArrayExt.removeFirstOf(data, 17);        // -1
         * ArrayExt.removeFirstOf(data, 39, 3);     // -1
         * ArrayExt.removeFirstOf(data, 39, 3, 2);  // 2
         * ```
         */
        function removeFirstOf(array, value, start = 0, stop = -1) {
            let index = firstIndexOf(array, value, start, stop);
            if (index !== -1) {
                removeAt(array, index);
            }
            return index;
        }
        ArrayExt.removeFirstOf = removeFirstOf;
        /**
         * Remove the last occurrence of a value from an array.
         *
         * @param array - The array of interest.
         *
         * @param value - The value to remove from the array. Values are
         *   compared using strict `===` equality.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The index of the removed value, or `-1` if the value
         *   is not contained in the array.
         *
         * #### Notes
         * If `start < stop` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [0, 12, 23, 39, 14, 12, 75];
         * ArrayExt.removeLastOf(data, 12);        // 5
         * ArrayExt.removeLastOf(data, 17);        // -1
         * ArrayExt.removeLastOf(data, 39, 2);     // -1
         * ArrayExt.removeLastOf(data, 39, 2, 3);  // 3
         * ```
         */
        function removeLastOf(array, value, start = -1, stop = 0) {
            let index = lastIndexOf(array, value, start, stop);
            if (index !== -1) {
                removeAt(array, index);
            }
            return index;
        }
        ArrayExt.removeLastOf = removeLastOf;
        /**
         * Remove all occurrences of a value from an array.
         *
         * @param array - The array of interest.
         *
         * @param value - The value to remove from the array. Values are
         *   compared using strict `===` equality.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The number of elements removed from the array.
         *
         * #### Notes
         * If `stop < start` the search will conceptually wrap at the end of
         * the array, however the array will be traversed front-to-back.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * let data = [14, 12, 23, 39, 14, 12, 19, 14];
         * ArrayExt.removeAllOf(data, 12);        // 2
         * ArrayExt.removeAllOf(data, 17);        // 0
         * ArrayExt.removeAllOf(data, 14, 1, 4);  // 1
         * ```
         */
        function removeAllOf(array, value, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return 0;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let count = 0;
            for (let i = 0; i < n; ++i) {
                if (start <= stop && i >= start && i <= stop && array[i] === value) {
                    count++;
                }
                else if (stop < start &&
                    (i <= stop || i >= start) &&
                    array[i] === value) {
                    count++;
                }
                else if (count > 0) {
                    array[i - count] = array[i];
                }
            }
            if (count > 0) {
                array.length = n - count;
            }
            return count;
        }
        ArrayExt.removeAllOf = removeAllOf;
        /**
         * Remove the first occurrence of a value which matches a predicate.
         *
         * @param array - The array of interest.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The removed `{ index, value }`, which will be `-1` and
         *   `undefined` if the value is not contained in the array.
         *
         * #### Notes
         * If `stop < start` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [0, 12, 23, 39, 14, 12, 75];
         * ArrayExt.removeFirstWhere(data, isEven);     // { index: 0, value: 0 }
         * ArrayExt.removeFirstWhere(data, isEven, 2);  // { index: 3, value: 14 }
         * ArrayExt.removeFirstWhere(data, isEven, 4);  // { index: -1, value: undefined }
         * ```
         */
        function removeFirstWhere(array, fn, start = 0, stop = -1) {
            let value;
            let index = findFirstIndex(array, fn, start, stop);
            if (index !== -1) {
                value = removeAt(array, index);
            }
            return { index, value };
        }
        ArrayExt.removeFirstWhere = removeFirstWhere;
        /**
         * Remove the last occurrence of a value which matches a predicate.
         *
         * @param array - The array of interest.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The removed `{ index, value }`, which will be `-1` and
         *   `undefined` if the value is not contained in the array.
         *
         * #### Notes
         * If `start < stop` the search will wrap at the end of the array.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * let data = [0, 12, 23, 39, 14, 12, 75];
         * ArrayExt.removeLastWhere(data, isEven);        // { index: 5, value: 12 }
         * ArrayExt.removeLastWhere(data, isEven, 2);     // { index: 1, value: 12 }
         * ArrayExt.removeLastWhere(data, isEven, 2, 1);  // { index: -1, value: undefined }
         * ```
         */
        function removeLastWhere(array, fn, start = -1, stop = 0) {
            let value;
            let index = findLastIndex(array, fn, start, stop);
            if (index !== -1) {
                value = removeAt(array, index);
            }
            return { index, value };
        }
        ArrayExt.removeLastWhere = removeLastWhere;
        /**
         * Remove all occurrences of values which match a predicate.
         *
         * @param array - The array of interest.
         *
         * @param fn - The predicate function to apply to the values.
         *
         * @param start - The index of the first element in the range to be
         *   searched, inclusive. The default value is `0`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @param stop - The index of the last element in the range to be
         *   searched, inclusive. The default value is `-1`. Negative values
         *   are taken as an offset from the end of the array.
         *
         * @returns The number of elements removed from the array.
         *
         * #### Notes
         * If `stop < start` the search will conceptually wrap at the end of
         * the array, however the array will be traversed front-to-back.
         *
         * #### Complexity
         * Linear.
         *
         * #### Example
         * ```typescript
         * import { ArrayExt } from '@lumino/algorithm';
         *
         * function isEven(value: number): boolean {
         *   return value % 2 === 0;
         * }
         *
         * function isNegative(value: number): boolean {
         *   return value < 0;
         * }
         *
         * let data = [0, 12, -13, -9, 23, 39, 14, -15, 12, 75];
         * ArrayExt.removeAllWhere(data, isEven);            // 4
         * ArrayExt.removeAllWhere(data, isNegative, 0, 3);  // 2
         * ```
         */
        function removeAllWhere(array, fn, start = 0, stop = -1) {
            let n = array.length;
            if (n === 0) {
                return 0;
            }
            if (start < 0) {
                start = Math.max(0, start + n);
            }
            else {
                start = Math.min(start, n - 1);
            }
            if (stop < 0) {
                stop = Math.max(0, stop + n);
            }
            else {
                stop = Math.min(stop, n - 1);
            }
            let count = 0;
            for (let i = 0; i < n; ++i) {
                if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
                    count++;
                }
                else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
                    count++;
                }
                else if (count > 0) {
                    array[i - count] = array[i];
                }
            }
            if (count > 0) {
                array.length = n - count;
            }
            return count;
        }
        ArrayExt.removeAllWhere = removeAllWhere;
    })(ArrayExt || (ArrayExt = {}));
    /**
     * The namespace for the module implementation details.
     */
    var Private$1;
    (function (Private) {
        /**
         * Compute the effective length of a range.
         *
         * @param start - The starting value for the range, inclusive.
         *
         * @param stop - The stopping value for the range, exclusive.
         *
         * @param step - The distance between each value.
         *
         * @returns The number of steps need to traverse the range.
         */
        function rangeLength(start, stop, step) {
            if (step === 0) {
                return Infinity;
            }
            if (start > stop && step > 0) {
                return 0;
            }
            if (start < stop && step < 0) {
                return 0;
            }
            return Math.ceil((stop - start) / step);
        }
        Private.rangeLength = rangeLength;
    })(Private$1 || (Private$1 = {}));

    // Copyright (c) Jupyter Development Team.
    // Distributed under the terms of the Modified BSD License.
    /*-----------------------------------------------------------------------------
    | Copyright (c) 2014-2017, PhosphorJS Contributors
    |
    | Distributed under the terms of the BSD 3-Clause License.
    |
    | The full license is in the file LICENSE, distributed with this software.
    |----------------------------------------------------------------------------*/
    /**
     * Topologically sort an iterable of edges.
     *
     * @param edges - The iterable object of edges to sort.
     *   An edge is represented as a 2-tuple of `[fromNode, toNode]`.
     *
     * @returns The topologically sorted array of nodes.
     *
     * #### Notes
     * If a cycle is present in the graph, the cycle will be ignored and
     * the return value will be only approximately sorted.
     *
     * #### Example
     * ```typescript
     * import { topologicSort } from '@lumino/algorithm';
     *
     * let data = [
     *   ['d', 'e'],
     *   ['c', 'd'],
     *   ['a', 'b'],
     *   ['b', 'c']
     * ];
     *
     * topologicSort(data);  // ['a', 'b', 'c', 'd', 'e']
     * ```
     */
    function topologicSort(edges) {
        // Setup the shared sorting state.
        let sorted = [];
        let visited = new Set();
        let graph = new Map();
        // Add the edges to the graph.
        for (const edge of edges) {
            addEdge(edge);
        }
        // Visit each node in the graph.
        for (const [k] of graph) {
            visit(k);
        }
        // Return the sorted results.
        return sorted;
        // Add an edge to the graph.
        function addEdge(edge) {
            let [fromNode, toNode] = edge;
            let children = graph.get(toNode);
            if (children) {
                children.push(fromNode);
            }
            else {
                graph.set(toNode, [fromNode]);
            }
        }
        // Recursively visit the node.
        function visit(node) {
            if (visited.has(node)) {
                return;
            }
            visited.add(node);
            let children = graph.get(node);
            if (children) {
                for (const child of children) {
                    visit(child);
                }
            }
            sorted.push(node);
        }
    }

    // Copyright (c) Jupyter Development Team.
    // Distributed under the terms of the Modified BSD License.
    /*-----------------------------------------------------------------------------
    | Copyright (c) 2014-2017, PhosphorJS Contributors
    |
    | Distributed under the terms of the BSD 3-Clause License.
    |
    | The full license is in the file LICENSE, distributed with this software.
    |----------------------------------------------------------------------------*/
    /**
     * The namespace for string-specific algorithms.
     */
    var StringExt;
    (function (StringExt) {
        /**
         * Find the indices of characters in a source text.
         *
         * @param source - The source text which should be searched.
         *
         * @param query - The characters to locate in the source text.
         *
         * @param start - The index to start the search.
         *
         * @returns The matched indices, or `null` if there is no match.
         *
         * #### Complexity
         * Linear on `sourceText`.
         *
         * #### Notes
         * In order for there to be a match, all of the characters in `query`
         * **must** appear in `source` in the order given by `query`.
         *
         * Characters are matched using strict `===` equality.
         */
        function findIndices(source, query, start = 0) {
            let indices = new Array(query.length);
            for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
                j = source.indexOf(query[i], j);
                if (j === -1) {
                    return null;
                }
                indices[i] = j;
            }
            return indices;
        }
        StringExt.findIndices = findIndices;
        /**
         * A string matcher which uses a sum-of-squares algorithm.
         *
         * @param source - The source text which should be searched.
         *
         * @param query - The characters to locate in the source text.
         *
         * @param start - The index to start the search.
         *
         * @returns The match result, or `null` if there is no match.
         *   A lower `score` represents a stronger match.
         *
         * #### Complexity
         * Linear on `sourceText`.
         *
         * #### Notes
         * This scoring algorithm uses a sum-of-squares approach to determine
         * the score. In order for there to be a match, all of the characters
         * in `query` **must** appear in `source` in order. The index of each
         * matching character is squared and added to the score. This means
         * that early and consecutive character matches are preferred, while
         * late matches are heavily penalized.
         */
        function matchSumOfSquares(source, query, start = 0) {
            let indices = findIndices(source, query, start);
            if (!indices) {
                return null;
            }
            let score = 0;
            for (let i = 0, n = indices.length; i < n; ++i) {
                let j = indices[i] - start;
                score += j * j;
            }
            return { score, indices };
        }
        StringExt.matchSumOfSquares = matchSumOfSquares;
        /**
         * A string matcher which uses a sum-of-deltas algorithm.
         *
         * @param source - The source text which should be searched.
         *
         * @param query - The characters to locate in the source text.
         *
         * @param start - The index to start the search.
         *
         * @returns The match result, or `null` if there is no match.
         *   A lower `score` represents a stronger match.
         *
         * #### Complexity
         * Linear on `sourceText`.
         *
         * #### Notes
         * This scoring algorithm uses a sum-of-deltas approach to determine
         * the score. In order for there to be a match, all of the characters
         * in `query` **must** appear in `source` in order. The delta between
         * the indices are summed to create the score. This means that groups
         * of matched characters are preferred, while fragmented matches are
         * penalized.
         */
        function matchSumOfDeltas(source, query, start = 0) {
            let indices = findIndices(source, query, start);
            if (!indices) {
                return null;
            }
            let score = 0;
            let last = start - 1;
            for (let i = 0, n = indices.length; i < n; ++i) {
                let j = indices[i];
                score += j - last - 1;
                last = j;
            }
            return { score, indices };
        }
        StringExt.matchSumOfDeltas = matchSumOfDeltas;
        /**
         * Highlight the matched characters of a source text.
         *
         * @param source - The text which should be highlighted.
         *
         * @param indices - The indices of the matched characters. They must
         *   appear in increasing order and must be in bounds of the source.
         *
         * @param fn - The function to apply to the matched chunks.
         *
         * @returns An array of unmatched and highlighted chunks.
         */
        function highlight(source, indices, fn) {
            // Set up the result array.
            let result = [];
            // Set up the counter variables.
            let k = 0;
            let last = 0;
            let n = indices.length;
            // Iterator over each index.
            while (k < n) {
                // Set up the chunk indices.
                let i = indices[k];
                let j = indices[k];
                // Advance the right chunk index until it's non-contiguous.
                while (++k < n && indices[k] === j + 1) {
                    j++;
                }
                // Extract the unmatched text.
                if (last < i) {
                    result.push(source.slice(last, i));
                }
                // Extract and highlight the matched text.
                if (i < j + 1) {
                    result.push(fn(source.slice(i, j + 1)));
                }
                // Update the last visited index.
                last = j + 1;
            }
            // Extract any remaining unmatched text.
            if (last < source.length) {
                result.push(source.slice(last));
            }
            // Return the highlighted result.
            return result;
        }
        StringExt.highlight = highlight;
        /**
         * A 3-way string comparison function.
         *
         * @param a - The first string of interest.
         *
         * @param b - The second string of interest.
         *
         * @returns `-1` if `a < b`, else `1` if `a > b`, else `0`.
         */
        function cmp(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        StringExt.cmp = cmp;
    })(StringExt || (StringExt = {}));

    // Copyright (c) Jupyter Development Team.
    // Distributed under the terms of the Modified BSD License.
    /*-----------------------------------------------------------------------------
    | Copyright (c) 2014-2017, PhosphorJS Contributors
    |
    | Distributed under the terms of the BSD 3-Clause License.
    |
    | The full license is in the file LICENSE, distributed with this software.
    |----------------------------------------------------------------------------*/
    /**
     * @packageDocumentation
     * @module application
     */
    /**
     * A class for creating pluggable applications.
     *
     * @typeparam T - The type of the application shell.
     *
     * #### Notes
     * The `Application` class is useful when creating large, complex
     * UI applications with the ability to be safely extended by third
     * party code via plugins.
     */
    class Application {
        /**
         * Construct a new application.
         *
         * @param options - The options for creating the application.
         */
        constructor(options) {
            this._delegate = new coreutils.PromiseDelegate();
            this._plugins = new Map();
            this._services = new Map();
            this._started = false;
            this._bubblingKeydown = false;
            // Initialize the application state.
            this.commands = new commands.CommandRegistry();
            this.contextMenu = new widgets.ContextMenu({
                commands: this.commands,
                renderer: options.contextMenuRenderer
            });
            this.shell = options.shell;
        }
        /**
         * A promise which resolves after the application has started.
         *
         * #### Notes
         * This promise will resolve after the `start()` method is called,
         * when all the bootstrapping and shell mounting work is complete.
         */
        get started() {
            return this._delegate.promise;
        }
        /**
         * Get a plugin description.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @returns The plugin description.
         */
        getPluginDescription(id) {
            var _a, _b;
            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : '';
        }
        /**
         * Test whether a plugin is registered with the application.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @returns `true` if the plugin is registered, `false` otherwise.
         */
        hasPlugin(id) {
            return this._plugins.has(id);
        }
        /**
         * Test whether a plugin is activated with the application.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @returns `true` if the plugin is activated, `false` otherwise.
         */
        isPluginActivated(id) {
            var _a, _b;
            return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;
        }
        /**
         * List the IDs of the plugins registered with the application.
         *
         * @returns A new array of the registered plugin IDs.
         */
        listPlugins() {
            return Array.from(this._plugins.keys());
        }
        /**
         * Register a plugin with the application.
         *
         * @param plugin - The plugin to register.
         *
         * #### Notes
         * An error will be thrown if a plugin with the same ID is already
         * registered, or if the plugin has a circular dependency.
         *
         * If the plugin provides a service which has already been provided
         * by another plugin, the new service will override the old service.
         */
        registerPlugin(plugin) {
            // Throw an error if the plugin ID is already registered.
            if (this._plugins.has(plugin.id)) {
                throw new TypeError(`Plugin '${plugin.id}' is already registered.`);
            }
            // Create the normalized plugin data.
            const data = Private.createPluginData(plugin);
            // Ensure the plugin does not cause a cyclic dependency.
            Private.ensureNoCycle(data, this._plugins, this._services);
            // Add the service token to the service map.
            if (data.provides) {
                this._services.set(data.provides, data.id);
            }
            // Add the plugin to the plugin map.
            this._plugins.set(data.id, data);
        }
        /**
         * Register multiple plugins with the application.
         *
         * @param plugins - The plugins to register.
         *
         * #### Notes
         * This calls `registerPlugin()` for each of the given plugins.
         */
        registerPlugins(plugins) {
            for (const plugin of plugins) {
                this.registerPlugin(plugin);
            }
        }
        /**
         * Deregister a plugin with the application.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @param force - Whether to deregister the plugin even if it is active.
         */
        deregisterPlugin(id, force) {
            const plugin = this._plugins.get(id);
            if (!plugin) {
                return;
            }
            if (plugin.activated && !force) {
                throw new Error(`Plugin '${id}' is still active.`);
            }
            this._plugins.delete(id);
        }
        /**
         * Activate the plugin with the given ID.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @returns A promise which resolves when the plugin is activated
         *   or rejects with an error if it cannot be activated.
         */
        async activatePlugin(id) {
            // Reject the promise if the plugin is not registered.
            const plugin = this._plugins.get(id);
            if (!plugin) {
                throw new ReferenceError(`Plugin '${id}' is not registered.`);
            }
            // Resolve immediately if the plugin is already activated.
            if (plugin.activated) {
                return;
            }
            // Return the pending resolver promise if it exists.
            if (plugin.promise) {
                return plugin.promise;
            }
            // Resolve the required services for the plugin.
            const required = plugin.requires.map(t => this.resolveRequiredService(t));
            // Resolve the optional services for the plugin.
            const optional = plugin.optional.map(t => this.resolveOptionalService(t));
            // Setup the resolver promise for the plugin.
            plugin.promise = Promise.all([...required, ...optional])
                .then(services => plugin.activate.apply(undefined, [this, ...services]))
                .then(service => {
                plugin.service = service;
                plugin.activated = true;
                plugin.promise = null;
            })
                .catch(error => {
                plugin.promise = null;
                throw error;
            });
            // Return the pending resolver promise.
            return plugin.promise;
        }
        /**
         * Deactivate the plugin and its downstream dependents if and only if the
         * plugin and its dependents all support `deactivate`.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @returns A list of IDs of downstream plugins deactivated with this one.
         */
        async deactivatePlugin(id) {
            // Reject the promise if the plugin is not registered.
            const plugin = this._plugins.get(id);
            if (!plugin) {
                throw new ReferenceError(`Plugin '${id}' is not registered.`);
            }
            // Bail early if the plugin is not activated.
            if (!plugin.activated) {
                return [];
            }
            // Check that this plugin can deactivate.
            if (!plugin.deactivate) {
                throw new TypeError(`Plugin '${id}'#deactivate() method missing`);
            }
            // Find the optimal deactivation order for plugins downstream of this one.
            const manifest = Private.findDependents(id, this._plugins, this._services);
            const downstream = manifest.map(id => this._plugins.get(id));
            // Check that all downstream plugins can deactivate.
            for (const plugin of downstream) {
                if (!plugin.deactivate) {
                    throw new TypeError(`Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`);
                }
            }
            // Deactivate all downstream plugins.
            for (const plugin of downstream) {
                const services = [...plugin.requires, ...plugin.optional].map(service => {
                    const id = this._services.get(service);
                    return id ? this._plugins.get(id).service : null;
                });
                // Await deactivation so the next plugins only receive active services.
                await plugin.deactivate(this, ...services);
                plugin.service = null;
                plugin.activated = false;
            }
            // Remove plugin ID and return manifest of deactivated plugins.
            manifest.pop();
            return manifest;
        }
        /**
         * Resolve a required service of a given type.
         *
         * @param token - The token for the service type of interest.
         *
         * @returns A promise which resolves to an instance of the requested
         *   service, or rejects with an error if it cannot be resolved.
         *
         * #### Notes
         * Services are singletons. The same instance will be returned each
         * time a given service token is resolved.
         *
         * If the plugin which provides the service has not been activated,
         * resolving the service will automatically activate the plugin.
         *
         * User code will not typically call this method directly. Instead,
         * the required services for the user's plugins will be resolved
         * automatically when the plugin is activated.
         */
        async resolveRequiredService(token) {
            // Reject the promise if there is no provider for the type.
            const id = this._services.get(token);
            if (!id) {
                throw new TypeError(`No provider for: ${token.name}.`);
            }
            // Activate the plugin if necessary.
            const plugin = this._plugins.get(id);
            if (!plugin.activated) {
                await this.activatePlugin(id);
            }
            return plugin.service;
        }
        /**
         * Resolve an optional service of a given type.
         *
         * @param token - The token for the service type of interest.
         *
         * @returns A promise which resolves to an instance of the requested
         *   service, or `null` if it cannot be resolved.
         *
         * #### Notes
         * Services are singletons. The same instance will be returned each
         * time a given service token is resolved.
         *
         * If the plugin which provides the service has not been activated,
         * resolving the service will automatically activate the plugin.
         *
         * User code will not typically call this method directly. Instead,
         * the optional services for the user's plugins will be resolved
         * automatically when the plugin is activated.
         */
        async resolveOptionalService(token) {
            // Resolve with `null` if there is no provider for the type.
            const id = this._services.get(token);
            if (!id) {
                return null;
            }
            // Activate the plugin if necessary.
            const plugin = this._plugins.get(id);
            if (!plugin.activated) {
                try {
                    await this.activatePlugin(id);
                }
                catch (reason) {
                    console.error(reason);
                    return null;
                }
            }
            return plugin.service;
        }
        /**
         * Start the application.
         *
         * @param options - The options for starting the application.
         *
         * @returns A promise which resolves when all bootstrapping work
         *   is complete and the shell is mounted to the DOM.
         *
         * #### Notes
         * This should be called once by the application creator after all
         * initial plugins have been registered.
         *
         * If a plugin fails to the load, the error will be logged and the
         * other valid plugins will continue to be loaded.
         *
         * Bootstrapping the application consists of the following steps:
         * 1. Activate the startup plugins
         * 2. Wait for those plugins to activate
         * 3. Attach the shell widget to the DOM
         * 4. Add the application event listeners
         */
        start(options = {}) {
            // Return immediately if the application is already started.
            if (this._started) {
                return this._delegate.promise;
            }
            // Mark the application as started;
            this._started = true;
            this._bubblingKeydown = options.bubblingKeydown || false;
            // Parse the host ID for attaching the shell.
            const hostID = options.hostID || '';
            // Collect the ids of the startup plugins.
            const startups = Private.collectStartupPlugins(this._plugins, options);
            // Generate the activation promises.
            const promises = startups.map(id => {
                return this.activatePlugin(id).catch(error => {
                    console.error(`Plugin '${id}' failed to activate.`);
                    console.error(error);
                });
            });
            // Wait for the plugins to activate, then finalize startup.
            Promise.all(promises).then(() => {
                this.attachShell(hostID);
                this.addEventListeners();
                this._delegate.resolve();
            });
            // Return the pending delegate promise.
            return this._delegate.promise;
        }
        /**
         * The list of all the deferred plugins.
         */
        get deferredPlugins() {
            return Array.from(this._plugins)
                .filter(([id, plugin]) => plugin.autoStart === 'defer')
                .map(([id, plugin]) => id);
        }
        /**
         * Activate all the deferred plugins.
         *
         * @returns A promise which will resolve when each plugin is activated
         * or rejects with an error if one cannot be activated.
         */
        async activateDeferredPlugins() {
            const promises = this.deferredPlugins
                .filter(pluginId => this._plugins.get(pluginId).autoStart)
                .map(pluginId => {
                return this.activatePlugin(pluginId);
            });
            await Promise.all(promises);
        }
        /**
         * Handle the DOM events for the application.
         *
         * @param event - The DOM event sent to the application.
         *
         * #### Notes
         * This method implements the DOM `EventListener` interface and is
         * called in response to events registered for the application. It
         * should not be called directly by user code.
         */
        handleEvent(event) {
            switch (event.type) {
                case 'resize':
                    this.evtResize(event);
                    break;
                case 'keydown':
                    this.evtKeydown(event);
                    break;
                case 'contextmenu':
                    this.evtContextMenu(event);
                    break;
            }
        }
        /**
         * Attach the application shell to the DOM.
         *
         * @param id - The ID of the host node for the shell, or `''`.
         *
         * #### Notes
         * If the ID is not provided, the document body will be the host.
         *
         * A subclass may reimplement this method as needed.
         */
        attachShell(id) {
            widgets.Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);
        }
        /**
         * Add the application event listeners.
         *
         * #### Notes
         * The default implementation of this method adds listeners for
         * `'keydown'` and `'resize'` events.
         *
         * A subclass may reimplement this method as needed.
         */
        addEventListeners() {
            document.addEventListener('contextmenu', this);
            document.addEventListener('keydown', this, !this._bubblingKeydown);
            window.addEventListener('resize', this);
        }
        /**
         * A method invoked on a document `'keydown'` event.
         *
         * #### Notes
         * The default implementation of this method invokes the key down
         * processing method of the application command registry.
         *
         * A subclass may reimplement this method as needed.
         */
        evtKeydown(event) {
            this.commands.processKeydownEvent(event);
        }
        /**
         * A method invoked on a document `'contextmenu'` event.
         *
         * #### Notes
         * The default implementation of this method opens the application
         * `contextMenu` at the current mouse position.
         *
         * If the application context menu has no matching content *or* if
         * the shift key is pressed, the default browser context menu will
         * be opened instead.
         *
         * A subclass may reimplement this method as needed.
         */
        evtContextMenu(event) {
            if (event.shiftKey) {
                return;
            }
            if (this.contextMenu.open(event)) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
        /**
         * A method invoked on a window `'resize'` event.
         *
         * #### Notes
         * The default implementation of this method updates the shell.
         *
         * A subclass may reimplement this method as needed.
         */
        evtResize(event) {
            this.shell.update();
        }
    }
    /**
     * The namespace for the module implementation details.
     */
    var Private;
    (function (Private) {
        /**
         * Create a normalized plugin data object for the given plugin.
         */
        function createPluginData(plugin) {
            var _a, _b, _c, _d;
            return {
                id: plugin.id,
                description: (_a = plugin.description) !== null && _a !== void 0 ? _a : '',
                service: null,
                promise: null,
                activated: false,
                activate: plugin.activate,
                deactivate: (_b = plugin.deactivate) !== null && _b !== void 0 ? _b : null,
                provides: (_c = plugin.provides) !== null && _c !== void 0 ? _c : null,
                autoStart: (_d = plugin.autoStart) !== null && _d !== void 0 ? _d : false,
                requires: plugin.requires ? plugin.requires.slice() : [],
                optional: plugin.optional ? plugin.optional.slice() : []
            };
        }
        Private.createPluginData = createPluginData;
        /**
         * Ensure no cycle is present in the plugin resolution graph.
         *
         * If a cycle is detected, an error will be thrown.
         */
        function ensureNoCycle(plugin, plugins, services) {
            const dependencies = [...plugin.requires, ...plugin.optional];
            const visit = (token) => {
                if (token === plugin.provides) {
                    return true;
                }
                const id = services.get(token);
                if (!id) {
                    return false;
                }
                const visited = plugins.get(id);
                const dependencies = [...visited.requires, ...visited.optional];
                if (dependencies.length === 0) {
                    return false;
                }
                trace.push(id);
                if (dependencies.some(visit)) {
                    return true;
                }
                trace.pop();
                return false;
            };
            // Bail early if there cannot be a cycle.
            if (!plugin.provides || dependencies.length === 0) {
                return;
            }
            // Setup a stack to trace service resolution.
            const trace = [plugin.id];
            // Throw an exception if a cycle is present.
            if (dependencies.some(visit)) {
                throw new ReferenceError(`Cycle detected: ${trace.join(' -> ')}.`);
            }
        }
        Private.ensureNoCycle = ensureNoCycle;
        /**
         * Find dependents in deactivation order.
         *
         * @param id - The ID of the plugin of interest.
         *
         * @param plugins - The map containing all plugins.
         *
         * @param services - The map containing all services.
         *
         * @returns A list of dependent plugin IDs in order of deactivation
         *
         * #### Notes
         * The final item of the returned list is always the plugin of interest.
         */
        function findDependents(id, plugins, services) {
            const edges = new Array();
            const add = (id) => {
                const plugin = plugins.get(id);
                // FIXME In the case of missing optional dependencies, we may consider
                // deactivating and reactivating the plugin without the missing service.
                const dependencies = [...plugin.requires, ...plugin.optional];
                edges.push(...dependencies.reduce((acc, dep) => {
                    const service = services.get(dep);
                    if (service) {
                        // An edge is oriented from dependent to provider.
                        acc.push([id, service]);
                    }
                    return acc;
                }, []));
            };
            for (const id of plugins.keys()) {
                add(id);
            }
            // Filter edges
            // - Get all packages that dependent on the package to be deactivated
            const newEdges = edges.filter(edge => edge[1] === id);
            let oldSize = 0;
            while (newEdges.length > oldSize) {
                const previousSize = newEdges.length;
                // Get all packages that dependent on packages that will be deactivated
                const packagesOfInterest = new Set(newEdges.map(edge => edge[0]));
                for (const poi of packagesOfInterest) {
                    edges
                        .filter(edge => edge[1] === poi)
                        .forEach(edge => {
                        // We check it is not already included to deal with circular dependencies
                        if (!newEdges.includes(edge)) {
                            newEdges.push(edge);
                        }
                    });
                }
                oldSize = previousSize;
            }
            const sorted = topologicSort(newEdges);
            const index = sorted.findIndex(candidate => candidate === id);
            if (index === -1) {
                return [id];
            }
            return sorted.slice(0, index + 1);
        }
        Private.findDependents = findDependents;
        /**
         * Collect the IDs of the plugins to activate on startup.
         */
        function collectStartupPlugins(plugins, options) {
            // Create a set to hold the plugin IDs.
            const collection = new Set();
            // Collect the auto-start (non deferred) plugins.
            for (const id of plugins.keys()) {
                if (plugins.get(id).autoStart === true) {
                    collection.add(id);
                }
            }
            // Add the startup plugins.
            if (options.startPlugins) {
                for (const id of options.startPlugins) {
                    collection.add(id);
                }
            }
            // Remove the ignored plugins.
            if (options.ignorePlugins) {
                for (const id of options.ignorePlugins) {
                    collection.delete(id);
                }
            }
            // Return the collected startup plugins.
            return Array.from(collection);
        }
        Private.collectStartupPlugins = collectStartupPlugins;
    })(Private || (Private = {}));

    exports.Application = Application;

}));
//# sourceMappingURL=index.js.map
